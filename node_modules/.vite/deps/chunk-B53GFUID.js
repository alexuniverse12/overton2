import {
  require_buffer
} from "./chunk-4ZGY4V5J.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number2, base, endian) {
        if (BN.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max5(left4, right4) {
        if (left4.cmp(right4) > 0)
          return left4;
        return right4;
      };
      BN.min = function min5(left4, right4) {
        if (left4.cmp(right4) < 0)
          return left4;
        return right4;
      };
      BN.prototype._init = function init4(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number2, base, endian) {
        assert(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
            w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number2.length; i += 3) {
            w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c = string2.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number2.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number2, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
            w = parseHexByte(number2, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i, number2.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size4) {
        while (this.length < size4) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType2, size4) {
        if (ArrayType2.allocUnsafe) {
          return ArrayType2.allocUnsafe(size4);
        }
        return new ArrayType2(size4);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType2, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right4 = (num.words[i] | 0) * mul;
          w -= right4 & 67108863;
          carry = (w >> 26) - (right4 / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/symbol.inspect/index.js
var require_symbol = __commonJS({
  "node_modules/symbol.inspect/index.js"(exports, module) {
    "use strict";
    var SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
    module.exports = SymbolInspect;
  }
});

// node_modules/ton/dist/boc/BitString.js
var require_BitString = __commonJS({
  "node_modules/ton/dist/boc/BitString.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _BitString_instances;
    var _BitString_length;
    var _BitString_cursor;
    var _BitString_buffer;
    var _BitString_checkRange;
    var _a;
    var _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitString = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var symbol_inspect_1 = __importDefault(require_symbol());
    var __1 = require_dist2();
    var BitString = class {
      constructor(buffer, length, cursor) {
        _BitString_instances.add(this);
        _BitString_length.set(this, void 0);
        _BitString_cursor.set(this, void 0);
        _BitString_buffer.set(this, void 0);
        this[_a] = () => {
          let offset = 0;
          let end = __classPrivateFieldGet(this, _BitString_cursor, "f");
          return {
            next: () => {
              if (offset < end) {
                let v = this.get(offset);
                offset++;
                return {
                  done: false,
                  value: v
                };
              } else {
                return {
                  done: true
                };
              }
            }
          };
        };
        this.get = (n) => {
          __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
          return (__classPrivateFieldGet(this, _BitString_buffer, "f")[n / 8 | 0] & 1 << 7 - n % 8) > 0;
        };
        this.on = (n) => {
          __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
          __classPrivateFieldGet(this, _BitString_buffer, "f")[n / 8 | 0] |= 1 << 7 - n % 8;
        };
        this.off = (n) => {
          __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
          __classPrivateFieldGet(this, _BitString_buffer, "f")[n / 8 | 0] &= ~(1 << 7 - n % 8);
        };
        this.toggle = (n) => {
          __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
          __classPrivateFieldGet(this, _BitString_buffer, "f")[n / 8 | 0] ^= 1 << 7 - n % 8;
        };
        this.writeBit = (value) => {
          var _c;
          if (value === true || value > 0) {
            this.on(__classPrivateFieldGet(this, _BitString_cursor, "f"));
          } else {
            this.off(__classPrivateFieldGet(this, _BitString_cursor, "f"));
          }
          __classPrivateFieldSet(this, _BitString_cursor, (_c = __classPrivateFieldGet(this, _BitString_cursor, "f"), _c++, _c), "f");
        };
        this.writeUint = (value, bitLength) => {
          let v = new bn_js_1.default(value);
          if (bitLength == 0 || value.toString(2).length > bitLength) {
            if (v.isZero()) {
              return;
            }
            throw Error(`bitLength is too small for a value ${v.toString()}. Got ${bitLength}, expected >= ${value.toString(2).length}`);
          }
          const s = v.toString(2, bitLength);
          for (let i = 0; i < bitLength; i++) {
            this.writeBit(s[i] === "1");
          }
        };
        this.writeInt = (value, bitLength) => {
          let v = new bn_js_1.default(value);
          if (bitLength == 1) {
            if (v.eq(new bn_js_1.default(-1))) {
              this.writeBit(true);
              return;
            }
            if (v.isZero()) {
              this.writeBit(false);
              return;
            }
            throw Error(`bitlength is too small for a value ${v}`);
          } else {
            if (v.isNeg()) {
              this.writeBit(true);
              const b = new bn_js_1.default(2);
              const nb = b.pow(new bn_js_1.default(bitLength - 1));
              this.writeUint(nb.add(v), bitLength - 1);
            } else {
              this.writeBit(false);
              this.writeUint(v, bitLength - 1);
            }
          }
        };
        this.writeUint8 = (value) => {
          this.writeUint(value, 8);
        };
        this.writeBuffer = (buffer2) => {
          for (let i = 0; i < buffer2.length; i++) {
            this.writeUint8(buffer2[i]);
          }
        };
        this.writeCoins = (amount) => {
          if (amount == 0) {
            this.writeUint(0, 4);
          } else {
            amount = new bn_js_1.default(amount);
            const l = Math.ceil(amount.toString(16).length / 2);
            this.writeUint(l, 4);
            this.writeUint(amount, l * 8);
          }
        };
        this.writeAddress = (address) => {
          if (address === null) {
            this.writeUint(0, 2);
          } else {
            this.writeUint(2, 2);
            this.writeUint(0, 1);
            this.writeInt(address.workChain, 8);
            this.writeBuffer(address.hash);
          }
        };
        this.writeBitString = (value) => {
          for (let v of value) {
            this.writeBit(v);
          }
        };
        this[_b] = () => this.toFiftHex();
        __classPrivateFieldSet(this, _BitString_buffer, buffer, "f");
        __classPrivateFieldSet(this, _BitString_length, length, "f");
        __classPrivateFieldSet(this, _BitString_cursor, cursor, "f");
      }
      static alloc(length) {
        return new BitString(Buffer.alloc(Math.ceil(length / 8), 0), length, 0);
      }
      get available() {
        return this.length - this.cursor;
      }
      get length() {
        return __classPrivateFieldGet(this, _BitString_length, "f");
      }
      get cursor() {
        return __classPrivateFieldGet(this, _BitString_cursor, "f");
      }
      get buffer() {
        return __classPrivateFieldGet(this, _BitString_buffer, "f");
      }
      writeBitArray(value) {
        for (let v of value) {
          this.writeBit(v);
        }
      }
      writeVarUInt(value, headerBits) {
        let v = new bn_js_1.default(value);
        if (v.eq(new bn_js_1.default(0))) {
          this.writeUint(0, headerBits);
        } else {
          let h = v.toString("hex");
          while (h.length % 2 !== 0) {
            h = "0" + h;
          }
          const l = Math.ceil(h.length / 2);
          this.writeUint(l, headerBits);
          this.writeBuffer(Buffer.from(h, "hex"));
        }
      }
      clone() {
        let buf = Buffer.alloc(__classPrivateFieldGet(this, _BitString_buffer, "f").length);
        __classPrivateFieldGet(this, _BitString_buffer, "f").copy(buf);
        return new BitString(buf, __classPrivateFieldGet(this, _BitString_length, "f"), __classPrivateFieldGet(this, _BitString_cursor, "f"));
      }
      toString() {
        let res = "";
        for (let v of this) {
          if (v) {
            res = res + "1";
          } else {
            res = res + "0";
          }
        }
        return res;
      }
      toFiftHex() {
        if (this.cursor % 4 === 0) {
          const s = __classPrivateFieldGet(this, _BitString_buffer, "f").slice(0, Math.ceil(this.cursor / 8)).toString("hex").toUpperCase();
          if (this.cursor % 8 === 0) {
            return s;
          } else {
            return s.substr(0, s.length - 1);
          }
        } else {
          const temp = this.clone();
          temp.writeBit(1);
          while (temp.cursor % 4 !== 0) {
            temp.writeBit(0);
          }
          const hex = temp.toFiftHex().toUpperCase();
          return hex + "_";
        }
      }
      setTopUppedArray(array3, fullfilledBytes = true) {
        __classPrivateFieldSet(this, _BitString_length, array3.length * 8, "f");
        __classPrivateFieldSet(this, _BitString_buffer, Buffer.alloc(array3.length), "f");
        array3.copy(__classPrivateFieldGet(this, _BitString_buffer, "f"));
        __classPrivateFieldSet(this, _BitString_cursor, this.length, "f");
        if (fullfilledBytes || !this.length) {
          return;
        } else {
          let foundEndBit = false;
          for (let c = 0; c < 7; c++) {
            __classPrivateFieldSet(this, _BitString_cursor, __classPrivateFieldGet(this, _BitString_cursor, "f") - 1, "f");
            if (this.get(this.cursor)) {
              foundEndBit = true;
              this.off(this.cursor);
              break;
            }
          }
          if (!foundEndBit) {
            throw new Error("Incorrect TopUppedArray");
          }
        }
      }
      getTopUppedArray() {
        const ret = this.clone();
        let tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;
        if (tu > 0) {
          tu = tu - 1;
          ret.writeBit(true);
          while (tu > 0) {
            tu = tu - 1;
            ret.writeBit(false);
          }
        }
        __classPrivateFieldSet(ret, _BitString_buffer, __classPrivateFieldGet(ret, _BitString_buffer, "f").slice(0, Math.ceil(ret.cursor / 8)), "f");
        return __classPrivateFieldGet(ret, _BitString_buffer, "f");
      }
      equals(src) {
        if (src.cursor !== this.cursor) {
          return false;
        }
        if (src.length !== this.length) {
          return false;
        }
        let sr = new __1.BitStringReader(src);
        let tr = new __1.BitStringReader(this);
        for (let i = 0; i < src.cursor; i++) {
          if (sr.readBit() !== tr.readBit()) {
            return false;
          }
        }
        return true;
      }
    };
    exports.BitString = BitString;
    _BitString_length = /* @__PURE__ */ new WeakMap(), _BitString_cursor = /* @__PURE__ */ new WeakMap(), _BitString_buffer = /* @__PURE__ */ new WeakMap(), _BitString_instances = /* @__PURE__ */ new WeakSet(), _a = Symbol.iterator, _b = symbol_inspect_1.default, _BitString_checkRange = function _BitString_checkRange2(n) {
      if (n > this.length) {
        throw Error("Invalid index: " + n);
      }
    };
  }
});

// node_modules/ton/dist/address/AddressExternal.js
var require_AddressExternal = __commonJS({
  "node_modules/ton/dist/address/AddressExternal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressExternal = void 0;
    var AddressExternal = class {
      constructor(bits) {
        this.bits = bits;
      }
    };
    exports.AddressExternal = AddressExternal;
  }
});

// node_modules/ton/dist/boc/BitStringReader.js
var require_BitStringReader = __commonJS({
  "node_modules/ton/dist/boc/BitStringReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitStringReader = void 0;
    var bn_js_1 = require_bn();
    var __1 = require_dist2();
    var AddressExternal_1 = require_AddressExternal();
    var BitStringReader = class {
      constructor(string2) {
        this.offset = 0;
        let r = Buffer.alloc(string2.buffer.length);
        string2.buffer.copy(r);
        this.buffer = r;
        this.length = string2.cursor;
      }
      get currentOffset() {
        return this.offset;
      }
      get remaining() {
        return this.length - this.offset;
      }
      skip(bits) {
        for (let i = 0; i < bits; i++) {
          this.readBit();
        }
      }
      readUint(bits) {
        if (bits == 0) {
          return new bn_js_1.BN(0);
        }
        let res = "";
        for (let i = 0; i < bits; i++) {
          res += this.readBit() ? "1" : "0";
        }
        return new bn_js_1.BN(res, 2);
      }
      readUintNumber(bits) {
        return this.readUint(bits).toNumber();
      }
      readInt(bits) {
        if (bits === 0) {
          return new bn_js_1.BN(0);
        }
        if (bits === 1) {
          if (this.readBit()) {
            return new bn_js_1.BN(-1);
          } else {
            return new bn_js_1.BN(0);
          }
        }
        if (this.readBit()) {
          let base = this.readUint(bits - 1);
          const b = new bn_js_1.BN(2);
          const nb = b.pow(new bn_js_1.BN(bits - 1));
          return base.sub(nb);
        } else {
          return this.readUint(bits - 1);
        }
      }
      readIntNumber(bits) {
        return this.readInt(bits).toNumber();
      }
      readBuffer(size4) {
        let res = [];
        for (let i = 0; i < size4; i++) {
          res.push(this.readUintNumber(8));
        }
        return Buffer.from(res);
      }
      readBit() {
        let r = this.getBit(this.offset);
        this.offset++;
        return r;
      }
      readCoins() {
        let bytes = this.readUintNumber(4);
        if (bytes === 0) {
          return new bn_js_1.BN(0);
        }
        return new bn_js_1.BN(this.readBuffer(bytes).toString("hex"), "hex");
      }
      readVarUInt(headerBits) {
        let bytes = this.readUintNumber(headerBits);
        if (bytes === 0) {
          return new bn_js_1.BN(0);
        }
        return new bn_js_1.BN(this.readBuffer(bytes).toString("hex"), "hex");
      }
      readVarUIntNumber(headerBits) {
        return this.readVarUInt(headerBits).toNumber();
      }
      readUnaryLength() {
        let res = 0;
        while (this.readBit()) {
          res++;
        }
        return res;
      }
      readRemaining() {
        let res = __1.BitString.alloc(1023);
        while (this.offset < this.length) {
          res.writeBit(this.readBit());
        }
        return res;
      }
      readAddress() {
        let type2 = this.readUintNumber(2);
        if (type2 === 0) {
          return null;
        }
        if (type2 !== 2) {
          throw Error("Only STD address supported");
        }
        return this.readAddressSTD();
      }
      readAddressInternal() {
        let type2 = this.readUintNumber(2);
        if (type2 === 2) {
          return this.readAddressSTD();
        } else {
          throw Error("Invalid data");
        }
      }
      readAddressExternal() {
        let type2 = this.readUintNumber(2);
        if (type2 === 0) {
          return null;
        } else if (type2 === 1) {
          return this.readAddressExternalInt();
        } else {
          throw Error("Invalid data");
        }
      }
      readAddressAny() {
        let type2 = this.readUintNumber(2);
        if (type2 === 0) {
          return null;
        } else if (type2 === 2) {
          return this.readAddressSTD();
        } else if (type2 === 1) {
          return this.readAddressExternal();
        } else if (type2 === 3) {
          throw Error("Unsupported");
        } else {
          throw Error("Unreachable");
        }
      }
      readAddressExternalInt() {
        let len = this.readUintNumber(9);
        let result = this.readBitString(len);
        return new AddressExternal_1.AddressExternal(result);
      }
      readAddressSTD() {
        if (this.readUintNumber(1) === 0) {
          const wc = this.readIntNumber(8);
          const hash = this.readBuffer(32);
          return new __1.Address(wc, hash);
        } else {
          throw Error("Var Length address not supported");
        }
      }
      readBitString(n) {
        let res = __1.BitString.alloc(1023);
        for (let i = 0; i < n; i++) {
          res.writeBit(this.readBit());
        }
        return res;
      }
      getBit(n) {
        if (n >= this.length || n < 0) {
          throw Error("Out of range");
        }
        return (this.buffer[n / 8 | 0] & 1 << 7 - n % 8) > 0;
      }
    };
    exports.BitStringReader = BitStringReader;
  }
});

// node_modules/jssha/dist/sha.js
var require_sha = __commonJS({
  "node_modules/jssha/dist/sha.js"(exports, module) {
    !function(n, r) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define(r) : (n = "undefined" != typeof globalThis ? globalThis : n || self).jsSHA = r();
    }(exports, function() {
      "use strict";
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      function r(n2, r2, t2, e2) {
        var i2, o2, u2, f2 = r2 || [0], w2 = (t2 = t2 || 0) >>> 3, s2 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1)
          o2 = (u2 = i2 + w2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (s2 + e2 * (u2 % 4));
        return { value: f2, binLen: 8 * n2.length + t2 };
      }
      function t(t2, e2, i2) {
        switch (e2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (t2) {
          case "HEX":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3) {
                var i3, o2, u2, f2;
                if (0 != n3.length % 2)
                  throw new Error("String of HEX type must be in byte increments");
                var w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o2 = parseInt(n3.substr(i3, 2), 16), isNaN(o2))
                    throw new Error("String of HEX type contains invalid characters");
                  for (u2 = (f2 = (i3 >>> 1) + s2) >>> 2; w2.length <= u2; )
                    w2.push(0);
                  w2[u2] |= o2 << 8 * (a2 + e3 * (f2 % 4));
                }
                return { value: w2, binLen: 4 * n3.length + t4 };
              }(n2, r2, t3, i2);
            };
          case "TEXT":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3, i3) {
                var o2, u2, f2, w2, s2, a2, h2, c2, v2 = 0, A2 = t4 || [0], E2 = (e3 = e3 || 0) >>> 3;
                if ("UTF8" === r3)
                  for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1)
                    for (u2 = [], 128 > (o2 = n3.charCodeAt(f2)) ? u2.push(o2) : 2048 > o2 ? (u2.push(192 | o2 >>> 6), u2.push(128 | 63 & o2)) : 55296 > o2 || 57344 <= o2 ? u2.push(224 | o2 >>> 12, 128 | o2 >>> 6 & 63, 128 | 63 & o2) : (f2 += 1, o2 = 65536 + ((1023 & o2) << 10 | 1023 & n3.charCodeAt(f2)), u2.push(240 | o2 >>> 18, 128 | o2 >>> 12 & 63, 128 | o2 >>> 6 & 63, 128 | 63 & o2)), w2 = 0; w2 < u2.length; w2 += 1) {
                      for (s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                        A2.push(0);
                      A2[s2] |= u2[w2] << 8 * (h2 + i3 * (a2 % 4)), v2 += 1;
                    }
                else
                  for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
                    for (o2 = n3.charCodeAt(f2), true === c2 && (o2 = (w2 = 255 & o2) << 8 | o2 >>> 8), s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                      A2.push(0);
                    A2[s2] |= o2 << 8 * (h2 + i3 * (a2 % 4)), v2 += 2;
                  }
                return { value: A2, binLen: 8 * v2 + e3 };
              }(n2, e2, r2, t3, i2);
            };
          case "B64":
            return function(r2, t3, e3) {
              return function(r3, t4, e4, i3) {
                var o2, u2, f2, w2, s2, a2, h2 = 0, c2 = t4 || [0], v2 = (e4 = e4 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/))
                  throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length)
                  throw new Error("Invalid '=' found in base-64 string");
                for (o2 = 0; o2 < r3.length; o2 += 4) {
                  for (w2 = r3.substr(o2, 4), f2 = 0, u2 = 0; u2 < w2.length; u2 += 1)
                    f2 |= n.indexOf(w2.charAt(u2)) << 18 - 6 * u2;
                  for (u2 = 0; u2 < w2.length - 1; u2 += 1) {
                    for (s2 = (a2 = h2 + v2) >>> 2; c2.length <= s2; )
                      c2.push(0);
                    c2[s2] |= (f2 >>> 16 - 8 * u2 & 255) << 8 * (A2 + i3 * (a2 % 4)), h2 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h2 + e4 };
              }(r2, t3, e3, i2);
            };
          case "BYTES":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3) {
                var i3, o2, u2, f2, w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                for (o2 = 0; o2 < n3.length; o2 += 1)
                  i3 = n3.charCodeAt(o2), u2 = (f2 = o2 + s2) >>> 2, w2.length <= u2 && w2.push(0), w2[u2] |= i3 << 8 * (a2 + e3 * (f2 % 4));
                return { value: w2, binLen: 8 * n3.length + t4 };
              }(n2, r2, t3, i2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2, t3, e3) {
              return function(n3, t4, e4, i3) {
                return r(new Uint8Array(n3), t4, e4, i3);
              }(n2, t3, e3, i2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2, t3, e3) {
              return r(n2, t3, e3, i2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function e(r2, t2, e2, i2) {
        switch (r2) {
          case "HEX":
            return function(n2) {
              return function(n3, r3, t3, e3) {
                var i3, o2, u2 = "", f2 = r3 / 8, w2 = -1 === t3 ? 3 : 0;
                for (i3 = 0; i3 < f2; i3 += 1)
                  o2 = n3[i3 >>> 2] >>> 8 * (w2 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o2);
                return e3.outputUpper ? u2.toUpperCase() : u2;
              }(n2, t2, e2, i2);
            };
          case "B64":
            return function(r3) {
              return function(r4, t3, e3, i3) {
                var o2, u2, f2, w2, s2, a2 = "", h2 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o2 = 0; o2 < h2; o2 += 3)
                  for (w2 = o2 + 1 < h2 ? r4[o2 + 1 >>> 2] : 0, s2 = o2 + 2 < h2 ? r4[o2 + 2 >>> 2] : 0, f2 = (r4[o2 >>> 2] >>> 8 * (c2 + e3 * (o2 % 4)) & 255) << 16 | (w2 >>> 8 * (c2 + e3 * ((o2 + 1) % 4)) & 255) << 8 | s2 >>> 8 * (c2 + e3 * ((o2 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1)
                    a2 += 8 * o2 + 6 * u2 <= t3 ? n.charAt(f2 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                return a2;
              }(r3, t2, e2, i2);
            };
          case "BYTES":
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3, o2 = "", u2 = r3 / 8, f2 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < u2; e3 += 1)
                  i3 = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255, o2 += String.fromCharCode(i3);
                return o2;
              }(n2, t2, e2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o2 = new ArrayBuffer(i3), u2 = new Uint8Array(o2), f2 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1)
                  u2[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255;
                return o2;
              }(n2, t2, e2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o2 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1)
                  u2[e3] = n3[e3 >>> 2] >>> 8 * (o2 + t3 * (e3 % 4)) & 255;
                return u2;
              }(n2, t2, e2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f = "Chosen SHA variant is not supported";
      function w(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o2; t2 += 4)
            e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
          return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function s(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0)
            throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0)
            throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper)
          throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad)
          throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function a(n2, r2, e2, i2) {
        var o2 = n2 + " must include a value and format";
        if (!r2) {
          if (!i2)
            throw new Error(o2);
          return i2;
        }
        if (void 0 === r2.value || !r2.format)
          throw new Error(o2);
        return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
      }
      var h = function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
            throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
          for (r2 = 0; r2 < f2; r2 += e2)
            t2 + this.S <= o2 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
          this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o2 % this.S, this.h = true;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, i2, o2 = this.U, u2 = s(r2);
          if (this.T) {
            if (-1 === u2.outputLen)
              throw new Error("Output length must be specified in options");
            o2 = u2.outputLen;
          }
          var f2 = e(n3, o2, this.C, u2);
          if (this.A && this.F)
            return f2(this.F(u2));
          for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o2), t2 = 1; t2 < this.numRounds; t2 += 1)
            this.T && o2 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o2 % 32), i2 = this.K(i2, o2, 0, this.L(this.o), o2);
          return f2(i2);
        }, n2.prototype.setHMACKey = function(n3, r2, e2) {
          if (!this.g)
            throw new Error("Variant does not support HMAC");
          if (this.h)
            throw new Error("Cannot set MAC key after calling update");
          var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
          this.k(i2(n3));
        }, n2.prototype.k = function(n3) {
          var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds)
            throw new Error("Cannot set numRounds with MAC");
          if (this.A)
            throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; )
            n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1)
            this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = s(r2);
          return e(n3, this.U, this.C, t2)(this.Y());
        }, n2.prototype.Y = function() {
          var n3;
          if (!this.A)
            throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
          return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
        }, n2;
      }(), c = function(n2, r2) {
        return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3)
            Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        })(n2, r2);
      };
      function v(n2, r2) {
        function t2() {
          this.constructor = n2;
        }
        c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function A(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function E(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function l(n2, r2) {
        return n2 >>> r2;
      }
      function b(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function H(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function d(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function S(n2) {
        return E(n2, 2) ^ E(n2, 13) ^ E(n2, 22);
      }
      function p(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function m(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function y(n2, r2, t2, e2, i2) {
        var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
      }
      function R(n2) {
        return E(n2, 7) ^ E(n2, 18) ^ l(n2, 3);
      }
      function U(n2) {
        return E(n2, 6) ^ E(n2, 11) ^ E(n2, 25);
      }
      function T(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function C(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], w2 = 0; w2 < 80; w2 += 1)
          s2[w2] = w2 < 16 ? n2[w2] : A(s2[w2 - 3] ^ s2[w2 - 8] ^ s2[w2 - 14] ^ s2[w2 - 16], 1), f2 = w2 < 20 ? y(A(t2, 5), H(e2, i2, o2), u2, 1518500249, s2[w2]) : w2 < 40 ? y(A(t2, 5), b(e2, i2, o2), u2, 1859775393, s2[w2]) : w2 < 60 ? y(A(t2, 5), d(e2, i2, o2), u2, 2400959708, s2[w2]) : y(A(t2, 5), b(e2, i2, o2), u2, 3395469782, s2[w2]), u2 = o2, o2 = i2, i2 = A(e2, 30), e2 = t2, t2 = f2;
        return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(i2, r2[2]), r2[3] = p(o2, r2[3]), r2[4] = p(u2, r2[4]), r2;
      }
      function F(n2, r2, t2, e2) {
        for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o2; )
          n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & u2, n2[o2 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16)
          e2 = C(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      var K = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-1" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).g = true, o2.F = o2.Y, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = C, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = T, o2.K = F, o2.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.S = 512, o2.U = 160, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h);
      function B(n2) {
        return "SHA-224" == n2 ? o.slice() : u.slice();
      }
      function L(n2, r2) {
        var t2, e2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, b2 = [];
        for (t2 = r2[0], e2 = r2[1], o2 = r2[2], u2 = r2[3], f2 = r2[4], w2 = r2[5], s2 = r2[6], a2 = r2[7], v2 = 0; v2 < 64; v2 += 1)
          b2[v2] = v2 < 16 ? n2[v2] : m(E(A2 = b2[v2 - 2], 17) ^ E(A2, 19) ^ l(A2, 10), b2[v2 - 7], R(b2[v2 - 15]), b2[v2 - 16]), h2 = y(a2, U(f2), H(f2, w2, s2), i[v2], b2[v2]), c2 = p(S(t2), d(t2, e2, o2)), a2 = s2, s2 = w2, w2 = f2, f2 = p(u2, h2), u2 = o2, o2 = e2, e2 = t2, t2 = p(h2, c2);
        return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(o2, r2[2]), r2[3] = p(u2, r2[3]), r2[4] = p(f2, r2[4]), r2[5] = p(w2, r2[5]), r2[6] = p(s2, r2[6]), r2[7] = p(a2, r2[7]), r2;
      }
      var g = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = L, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = B, o2.K = function(n3, t2, e3, i3) {
            return function(n4, r4, t3, e4, i4) {
              for (var o3, u3 = 15 + (r4 + 65 >>> 9 << 4), f2 = r4 + t3; n4.length <= u3; )
                n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 16)
                e4 = L(n4.slice(o3, o3 + 16), e4);
              return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            }(n3, t2, e3, i3, r3);
          }, o2.m = B(r3), o2.S = 512, o2.U = "SHA-224" === r3 ? 224 : 256, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h), k = function(n2, r2) {
        this.N = n2, this.I = r2;
      };
      function Y(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new k(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
      }
      function N(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new k(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
      }
      function I(n2, r2) {
        return new k(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
      }
      function M(n2, r2, t2) {
        return new k(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
      }
      function X(n2, r2, t2) {
        return new k(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
      }
      function z(n2) {
        var r2 = N(n2, 28), t2 = N(n2, 34), e2 = N(n2, 39);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function O(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.I) + (65535 & r2.I);
        var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function j(n2, r2, t2, e2) {
        var i2, o2;
        i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
        var u2 = (65535 & (o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o2 >>> 16), o2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k((65535 & o2) << 16 | 65535 & i2, u2);
      }
      function _(n2, r2, t2, e2, i2) {
        var o2, u2;
        o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
        var f2 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
        return o2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o2 >>> 16), new k((65535 & u2) << 16 | 65535 & o2, f2);
      }
      function P(n2, r2) {
        return new k(n2.N ^ r2.N, n2.I ^ r2.I);
      }
      function x(n2) {
        var r2 = N(n2, 1), t2 = N(n2, 8), e2 = I(n2, 7);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function V(n2) {
        var r2 = N(n2, 14), t2 = N(n2, 18), e2 = N(n2, 41);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      var Z = [new k(i[0], 3609767458), new k(i[1], 602891725), new k(i[2], 3964484399), new k(i[3], 2173295548), new k(i[4], 4081628472), new k(i[5], 3053834265), new k(i[6], 2937671579), new k(i[7], 3664609560), new k(i[8], 2734883394), new k(i[9], 1164996542), new k(i[10], 1323610764), new k(i[11], 3590304994), new k(i[12], 4068182383), new k(i[13], 991336113), new k(i[14], 633803317), new k(i[15], 3479774868), new k(i[16], 2666613458), new k(i[17], 944711139), new k(i[18], 2341262773), new k(i[19], 2007800933), new k(i[20], 1495990901), new k(i[21], 1856431235), new k(i[22], 3175218132), new k(i[23], 2198950837), new k(i[24], 3999719339), new k(i[25], 766784016), new k(i[26], 2566594879), new k(i[27], 3203337956), new k(i[28], 1034457026), new k(i[29], 2466948901), new k(i[30], 3758326383), new k(i[31], 168717936), new k(i[32], 1188179964), new k(i[33], 1546045734), new k(i[34], 1522805485), new k(i[35], 2643833823), new k(i[36], 2343527390), new k(i[37], 1014477480), new k(i[38], 1206759142), new k(i[39], 344077627), new k(i[40], 1290863460), new k(i[41], 3158454273), new k(i[42], 3505952657), new k(i[43], 106217008), new k(i[44], 3606008344), new k(i[45], 1432725776), new k(i[46], 1467031594), new k(i[47], 851169720), new k(i[48], 3100823752), new k(i[49], 1363258195), new k(i[50], 3750685593), new k(i[51], 3785050280), new k(i[52], 3318307427), new k(i[53], 3812723403), new k(i[54], 2003034995), new k(i[55], 3602036899), new k(i[56], 1575990012), new k(i[57], 1125592928), new k(i[58], 2716904306), new k(i[59], 442776044), new k(i[60], 593698344), new k(i[61], 3733110249), new k(i[62], 2999351573), new k(i[63], 3815920427), new k(3391569614, 3928383900), new k(3515267271, 566280711), new k(3940187606, 3454069534), new k(4118630271, 4000239992), new k(116418474, 1914138554), new k(174292421, 2731055270), new k(289380356, 3203993006), new k(460393269, 320620315), new k(685471733, 587496836), new k(852142971, 1086792851), new k(1017036298, 365543100), new k(1126000580, 2618297676), new k(1288033470, 3409855158), new k(1501505948, 4234509866), new k(1607167915, 987167468), new k(1816402316, 1246189591)];
      function q(n2) {
        return "SHA-384" === n2 ? [new k(3418070365, o[0]), new k(1654270250, o[1]), new k(2438529370, o[2]), new k(355462360, o[3]), new k(1731405415, o[4]), new k(41048885895, o[5]), new k(3675008525, o[6]), new k(1203062813, o[7])] : [new k(u[0], 4089235720), new k(u[1], 2227873595), new k(u[2], 4271175723), new k(u[3], 1595750129), new k(u[4], 2917565137), new k(u[5], 725511199), new k(u[6], 4215389547), new k(u[7], 327033209)];
      }
      function D(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, E2, l2, b2, H2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], w2 = r2[6], s2 = r2[7], c2 = 0; c2 < 80; c2 += 1)
          c2 < 16 ? (v2 = 2 * c2, H2[c2] = new k(n2[v2], n2[v2 + 1])) : H2[c2] = j((A2 = H2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = N(A2, 19), l2 = N(A2, 61), b2 = I(A2, 6), new k(E2.N ^ l2.N ^ b2.N, E2.I ^ l2.I ^ b2.I)), H2[c2 - 7], x(H2[c2 - 15]), H2[c2 - 16]), a2 = _(s2, V(u2), M(u2, f2, w2), Z[c2], H2[c2]), h2 = O(z(t2), X(t2, e2, i2)), s2 = w2, w2 = f2, f2 = u2, u2 = O(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = O(a2, h2);
        return r2[0] = O(t2, r2[0]), r2[1] = O(e2, r2[1]), r2[2] = O(i2, r2[2]), r2[3] = O(o2, r2[3]), r2[4] = O(u2, r2[4]), r2[5] = O(f2, r2[5]), r2[6] = O(w2, r2[6]), r2[7] = O(s2, r2[7]), r2;
      }
      var G = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = D, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = q, o2.K = function(n3, t2, e3, i3) {
            return function(n4, r4, t3, e4, i4) {
              for (var o3, u3 = 31 + (r4 + 129 >>> 10 << 5), f2 = r4 + t3; n4.length <= u3; )
                n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 32)
                e4 = D(n4.slice(o3, o3 + 32), e4);
              return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
            }(n3, t2, e3, i3, r3);
          }, o2.m = q(r3), o2.S = 1024, o2.U = "SHA-384" === r3 ? 384 : 512, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h), J = [new k(0, 1), new k(0, 32898), new k(2147483648, 32906), new k(2147483648, 2147516416), new k(0, 32907), new k(0, 2147483649), new k(2147483648, 2147516545), new k(2147483648, 32777), new k(0, 138), new k(0, 136), new k(0, 2147516425), new k(0, 2147483658), new k(0, 2147516555), new k(2147483648, 139), new k(2147483648, 32905), new k(2147483648, 32771), new k(2147483648, 32770), new k(2147483648, 128), new k(0, 32778), new k(2147483648, 2147483658), new k(2147483648, 2147516545), new k(2147483648, 32896), new k(0, 2147483649), new k(2147483648, 2147516424)], Q = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function W(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1)
          t2[r2] = [new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0)];
        return t2;
      }
      function $(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1)
          t2[r2] = n2[r2].slice();
        return t2;
      }
      function nn(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2 = [], c2 = [];
        if (null !== n2)
          for (e2 = 0; e2 < n2.length; e2 += 2)
            r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o2 = W(), e2 = 0; e2 < 5; e2 += 1)
            h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], w2 = r2[e2][2], s2 = r2[e2][3], a2 = r2[e2][4], new k(u2.N ^ f2.N ^ w2.N ^ s2.N ^ a2.N, u2.I ^ f2.I ^ w2.I ^ s2.I ^ a2.I));
          for (e2 = 0; e2 < 5; e2 += 1)
            c2[e2] = P(h2[(e2 + 4) % 5], Y(h2[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              r2[e2][i2] = P(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              o2[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              r2[e2][i2] = P(o2[e2][i2], new k(~o2[(e2 + 1) % 5][i2].N & o2[(e2 + 2) % 5][i2].N, ~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I));
          r2[0][0] = P(r2[0][0], J[t2]);
        }
        return r2;
      }
      function rn(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / 4294967296 & 2097151];
        for (r2 = 6; r2 >= 0; r2--)
          0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function tn(n2) {
        return w(rn(n2.binLen), n2);
      }
      function en(n2, r2) {
        var t2, e2 = rn(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = w(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o2; t2++)
          e2.value.push(0);
        return e2.value;
      }
      var on = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this, u2 = 6, w2 = 0, s2 = i2 || {};
          if (1 !== (o2 = n2.call(this, r3, e2, i2) || this).numRounds) {
            if (s2.kmacKey || s2.hmacKey)
              throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o)
              throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o2.C = 1, o2.p = t(o2.t, o2.i, o2.C), o2.R = nn, o2.B = $, o2.L = W, o2.m = W(), o2.T = false, r3) {
            case "SHA3-224":
              o2.S = w2 = 1152, o2.U = 224, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-256":
              o2.S = w2 = 1088, o2.U = 256, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-384":
              o2.S = w2 = 832, o2.U = 384, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-512":
              o2.S = w2 = 576, o2.U = 512, o2.g = true, o2.F = o2.Y;
              break;
            case "SHAKE128":
              u2 = 31, o2.S = w2 = 1344, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "SHAKE256":
              u2 = 31, o2.S = w2 = 1088, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "KMAC128":
              u2 = 4, o2.S = w2 = 1344, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
              break;
            case "KMAC256":
              u2 = 4, o2.S = w2 = 1088, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
              break;
            case "CSHAKE128":
              o2.S = w2 = 1344, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "CSHAKE256":
              o2.S = w2 = 1088, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            default:
              throw new Error(f);
          }
          return o2.K = function(n3, r4, t2, e3, i3) {
            return function(n4, r5, t3, e4, i4, o3, u3) {
              var f2, w3, s3 = 0, a2 = [], h2 = i4 >>> 5, c2 = r5 >>> 5;
              for (f2 = 0; f2 < c2 && r5 >= i4; f2 += h2)
                e4 = nn(n4.slice(f2, f2 + h2), e4), r5 -= i4;
              for (n4 = n4.slice(f2), r5 %= i4; n4.length < h2; )
                n4.push(0);
              for (n4[(f2 = r5 >>> 3) >> 2] ^= o3 << f2 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = nn(n4, e4); 32 * a2.length < u3 && (w3 = e4[s3 % 5][s3 / 5 | 0], a2.push(w3.I), !(32 * a2.length >= u3)); )
                a2.push(w3.N), 0 == 64 * (s3 += 1) % i4 && (nn(null, e4), s3 = 0);
              return a2;
            }(n3, r4, 0, e3, w2, u2, i3);
          }, s2.hmacKey && o2.k(a("hmacKey", s2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2.prototype.O = function(n3, r3) {
          var t2 = function(n4) {
            var r4 = n4 || {};
            return { funcName: a("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          }(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = w(tn(t2.funcName), tn(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = en(e2, this.S >>> 3), o2 = 0; o2 < i2.length; o2 += this.S >>> 5)
              this.m = this.R(i2.slice(o2, o2 + (this.S >>> 5)), this.m), this.v += this.S;
            return 4;
          }
          return 31;
        }, r2.prototype.M = function(n3) {
          var r3 = function(n4) {
            var r4 = n4 || {};
            return { kmacKey: a("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          }(n3 || {});
          this.O(n3, r3.funcName);
          for (var t2 = en(tn(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5)
            this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
          this.A = true;
        }, r2.prototype.X = function(n3) {
          var r3 = w({ value: this.u.slice(), binLen: this.s }, function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / 4294967296 & 2097151];
            for (r4 = 6; r4 >= 0; r4--)
              0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          }(n3.outputLen));
          return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
        }, r2;
      }(h);
      return function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3)
            this.j = new K(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3)
            this.j = new g(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3)
            this.j = new G(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3)
              throw new Error(f);
            this.j = new on(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          this.j.update(n3);
        }, n2.prototype.getHash = function(n3, r2) {
          return this.j.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this.j.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this.j.getHMAC(n3, r2);
        }, n2;
      }();
    });
  }
});

// node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js
var require_getSecureRandom = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    function getSecureRandomBytes(size4) {
      return Buffer.from(window.crypto.getRandomValues(new Uint8Array(size4)));
    }
    exports.getSecureRandomBytes = getSecureRandomBytes;
    function getSecureRandomWords(size4) {
      return window.crypto.getRandomValues(new Uint16Array(size4));
    }
    exports.getSecureRandomWords = getSecureRandomWords;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js
var require_hmac_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac_sha512 = void 0;
    async function hmac_sha512(key, data) {
      let keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
      let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
      const hmacAlgo = { name: "HMAC", hash: "SHA-512" };
      const hmacKey = await window.crypto.subtle.importKey("raw", keyBuffer, hmacAlgo, false, ["sign"]);
      return Buffer.from(await crypto.subtle.sign(hmacAlgo, hmacKey, dataBuffer));
    }
    exports.hmac_sha512 = hmac_sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js
var require_pbkdf2_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2_sha512 = void 0;
    async function pbkdf2_sha512(key, salt, iterations, keyLen) {
      const keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
      const saltBuffer = typeof salt === "string" ? Buffer.from(salt, "utf-8") : salt;
      const pbkdf2_key = await window.crypto.subtle.importKey("raw", keyBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
      const derivedBits = await window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: saltBuffer, iterations }, pbkdf2_key, keyLen * 8);
      return Buffer.from(derivedBits);
    }
    exports.pbkdf2_sha512 = pbkdf2_sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/sha256.js
var require_sha256 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    async function sha256(source) {
      if (typeof source === "string") {
        return Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(source, "utf-8")));
      }
      return Buffer.from(await crypto.subtle.digest("SHA-256", source));
    }
    exports.sha256 = sha256;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/sha512.js
var require_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = void 0;
    async function sha512(source) {
      if (typeof source === "string") {
        return Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(source, "utf-8")));
      }
      return Buffer.from(await crypto.subtle.digest("SHA-512", source));
    }
    exports.sha512 = sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser.js
var require_browser = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var getSecureRandom_1 = require_getSecureRandom();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    var hmac_sha512_1 = require_hmac_sha512();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var pbkdf2_sha512_1 = require_pbkdf2_sha512();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var sha256_1 = require_sha256();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    var sha512_1 = require_sha512();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
  }
});

// node_modules/ton-crypto/dist/primitives/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/sha256.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = exports.sha256_fallback = exports.sha256_sync = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    function sha256_sync(source) {
      let src;
      if (typeof source === "string") {
        src = Buffer.from(source, "utf-8").toString("hex");
      } else {
        src = source.toString("hex");
      }
      let hasher = new jssha_1.default("SHA-256", "HEX");
      hasher.update(src);
      let res = hasher.getHash("HEX");
      return Buffer.from(res, "hex");
    }
    exports.sha256_sync = sha256_sync;
    async function sha256_fallback(source) {
      return sha256_sync(source);
    }
    exports.sha256_fallback = sha256_fallback;
    function sha256(source) {
      return (0, ton_crypto_primitives_1.sha256)(source);
    }
    exports.sha256 = sha256;
  }
});

// node_modules/ton-crypto/dist/primitives/sha512.js
var require_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/sha512.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha512_fallback = exports.sha512_sync = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    function sha512_sync(source) {
      let src;
      if (typeof source === "string") {
        src = Buffer.from(source, "utf-8").toString("hex");
      } else {
        src = source.toString("hex");
      }
      let hasher = new jssha_1.default("SHA-512", "HEX");
      hasher.update(src);
      let res = hasher.getHash("HEX");
      return Buffer.from(res, "hex");
    }
    exports.sha512_sync = sha512_sync;
    async function sha512_fallback(source) {
      return sha512_sync(source);
    }
    exports.sha512_fallback = sha512_fallback;
    async function sha512(source) {
      return (0, ton_crypto_primitives_1.sha512)(source);
    }
    exports.sha512 = sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js
var require_pbkdf2_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2_sha512 = void 0;
    var ton_crypto_primitives_1 = require_browser();
    function pbkdf2_sha512(key, salt, iterations, keyLen) {
      return (0, ton_crypto_primitives_1.pbkdf2_sha512)(key, salt, iterations, keyLen);
    }
    exports.pbkdf2_sha512 = pbkdf2_sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/hmac_sha512.js
var require_hmac_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/hmac_sha512.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac_sha512 = exports.hmac_sha512_fallback = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    async function hmac_sha512_fallback(key, data) {
      let keyBuffer = typeof key === "string" ? Buffer.from(key, "utf-8") : key;
      let dataBuffer = typeof data === "string" ? Buffer.from(data, "utf-8") : data;
      const shaObj = new jssha_1.default("SHA-512", "HEX", {
        hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
      });
      shaObj.update(dataBuffer.toString("hex"));
      const hmac = shaObj.getHash("HEX");
      return Buffer.from(hmac, "hex");
    }
    exports.hmac_sha512_fallback = hmac_sha512_fallback;
    function hmac_sha512(key, data) {
      return (0, ton_crypto_primitives_1.hmac_sha512)(key, data);
    }
    exports.hmac_sha512 = hmac_sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/getSecureRandom.js
var require_getSecureRandom2 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/getSecureRandom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var ton_crypto_primitives_1 = require_browser();
    async function getSecureRandomBytes(size4) {
      return (0, ton_crypto_primitives_1.getSecureRandomBytes)(size4);
    }
    exports.getSecureRandomBytes = getSecureRandomBytes;
    async function getSecureRandomWords(size4) {
      return getSecureRandomWords(size4);
    }
    exports.getSecureRandomWords = getSecureRandomWords;
    async function getSecureRandomNumber(min5, max5) {
      let range4 = max5 - min5;
      var bitsNeeded = Math.ceil(Math.log2(range4));
      if (bitsNeeded > 53) {
        throw new Error("Range is too large");
      }
      var bytesNeeded = Math.ceil(bitsNeeded / 8);
      var mask = Math.pow(2, bitsNeeded) - 1;
      while (true) {
        let res = await getSecureRandomBytes(bitsNeeded);
        let power = (bytesNeeded - 1) * 8;
        let numberValue = 0;
        for (var i = 0; i < bytesNeeded; i++) {
          numberValue += res[i] * Math.pow(2, power);
          power -= 8;
        }
        numberValue = numberValue & mask;
        if (numberValue >= range4) {
          continue;
        }
        return min5 + numberValue;
      }
    }
    exports.getSecureRandomNumber = getSecureRandomNumber;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl) {
      "use strict";
      var gf = function(init4) {
        var i, r = new Float64Array(16);
        if (init4)
          for (i = 0; i < init4.length; i++)
            r[i] = init4[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce9(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce9(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce9(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce9(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto();
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/ton-crypto/dist/mnemonic/wordlist.js
var require_wordlist = __commonJS({
  "node_modules/ton-crypto/dist/mnemonic/wordlist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    var EN = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    exports.wordlist = EN;
  }
});

// node_modules/ton-crypto/dist/mnemonic/mnemonic.js
var require_mnemonic = __commonJS({
  "node_modules/ton-crypto/dist/mnemonic/mnemonic.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    var getSecureRandom_1 = require_getSecureRandom2();
    var hmac_sha512_1 = require_hmac_sha5122();
    var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
    var wordlist_1 = require_wordlist();
    var PBKDF_ITERATIONS = 1e5;
    async function isPasswordNeeded(mnemonicArray) {
      const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
      return await isPasswordSeed(passlessEntropy) && !await isBasicSeed(passlessEntropy);
    }
    function normalizeMnemonic(src) {
      return src.map((v) => v.toLowerCase().trim());
    }
    async function isBasicSeed(entropy) {
      const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
      return seed[0] == 0;
    }
    async function isPasswordSeed(entropy) {
      const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
      return seed[0] == 1;
    }
    async function mnemonicToEntropy(mnemonicArray, password) {
      return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    async function mnemonicToSeed(mnemonicArray, seed, password) {
      const entropy = await mnemonicToEntropy(mnemonicArray, password);
      const res = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
      return res.slice(0, 32);
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    async function mnemonicToPrivateKey(mnemonicArray, password) {
      mnemonicArray = normalizeMnemonic(mnemonicArray);
      const seed = await mnemonicToSeed(mnemonicArray, "TON default seed", password);
      let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed);
      return {
        publicKey: Buffer.from(keyPair.publicKey),
        secretKey: Buffer.from(keyPair.secretKey)
      };
    }
    exports.mnemonicToPrivateKey = mnemonicToPrivateKey;
    async function mnemonicToWalletKey(mnemonicArray, password) {
      let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
      let seedSecret = seedPk.secretKey.slice(0, 32);
      const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
      return {
        publicKey: Buffer.from(keyPair.publicKey),
        secretKey: Buffer.from(keyPair.secretKey)
      };
    }
    exports.mnemonicToWalletKey = mnemonicToWalletKey;
    async function mnemonicValidate(mnemonicArray, password) {
      mnemonicArray = normalizeMnemonic(mnemonicArray);
      for (let word of mnemonicArray) {
        if (wordlist_1.wordlist.indexOf(word) < 0) {
          return false;
        }
      }
      if (password && password.length > 0) {
        if (!await isPasswordNeeded(mnemonicArray)) {
          return false;
        }
      }
      return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
    }
    exports.mnemonicValidate = mnemonicValidate;
    async function mnemonicNew(wordsCount = 24, password) {
      let mnemonicArray = [];
      while (true) {
        mnemonicArray = [];
        for (let i = 0; i < wordsCount; i++) {
          let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
          mnemonicArray.push(wordlist_1.wordlist[ind]);
        }
        if (password && password.length > 0) {
          if (!await isPasswordNeeded(mnemonicArray)) {
            continue;
          }
        }
        if (!await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password))) {
          continue;
        }
        break;
      }
      return mnemonicArray;
    }
    exports.mnemonicNew = mnemonicNew;
  }
});

// node_modules/ton-crypto/dist/primitives/nacl.js
var require_nacl = __commonJS({
  "node_modules/ton-crypto/dist/primitives/nacl.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.openBox = exports.sealBox = exports.signVerify = exports.sign = exports.keyPairFromSeed = exports.keyPairFromSecretKey = void 0;
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    function keyPairFromSecretKey(secretKey) {
      let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
      return {
        publicKey: Buffer.from(res.publicKey),
        secretKey: Buffer.from(res.secretKey)
      };
    }
    exports.keyPairFromSecretKey = keyPairFromSecretKey;
    function keyPairFromSeed(secretKey) {
      let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
      return {
        publicKey: Buffer.from(res.publicKey),
        secretKey: Buffer.from(res.secretKey)
      };
    }
    exports.keyPairFromSeed = keyPairFromSeed;
    function sign(data, secretKey) {
      return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
    }
    exports.sign = sign;
    function signVerify(data, signature, publicKey) {
      return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
    }
    exports.signVerify = signVerify;
    function sealBox(data, nonce, key) {
      return Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key));
    }
    exports.sealBox = sealBox;
    function openBox(data, nonce, key) {
      let res = tweetnacl_1.default.secretbox.open(data, nonce, key);
      if (!res) {
        return null;
      }
      return Buffer.from(res);
    }
    exports.openBox = openBox;
  }
});

// node_modules/ton-crypto/dist/passwords/wordlist.js
var require_wordlist2 = __commonJS({
  "node_modules/ton-crypto/dist/passwords/wordlist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    exports.wordlist = [
      "abacus",
      "abdomen",
      "abdominal",
      "abide",
      "abiding",
      "ability",
      "ablaze",
      "able",
      "abnormal",
      "abrasion",
      "abrasive",
      "abreast",
      "abridge",
      "abroad",
      "abruptly",
      "absence",
      "absentee",
      "absently",
      "absinthe",
      "absolute",
      "absolve",
      "abstain",
      "abstract",
      "absurd",
      "accent",
      "acclaim",
      "acclimate",
      "accompany",
      "account",
      "accuracy",
      "accurate",
      "accustom",
      "acetone",
      "achiness",
      "aching",
      "acid",
      "acorn",
      "acquaint",
      "acquire",
      "acre",
      "acrobat",
      "acronym",
      "acting",
      "action",
      "activate",
      "activator",
      "active",
      "activism",
      "activist",
      "activity",
      "actress",
      "acts",
      "acutely",
      "acuteness",
      "aeration",
      "aerobics",
      "aerosol",
      "aerospace",
      "afar",
      "affair",
      "affected",
      "affecting",
      "affection",
      "affidavit",
      "affiliate",
      "affirm",
      "affix",
      "afflicted",
      "affluent",
      "afford",
      "affront",
      "aflame",
      "afloat",
      "aflutter",
      "afoot",
      "afraid",
      "afterglow",
      "afterlife",
      "aftermath",
      "aftermost",
      "afternoon",
      "aged",
      "ageless",
      "agency",
      "agenda",
      "agent",
      "aggregate",
      "aghast",
      "agile",
      "agility",
      "aging",
      "agnostic",
      "agonize",
      "agonizing",
      "agony",
      "agreeable",
      "agreeably",
      "agreed",
      "agreeing",
      "agreement",
      "aground",
      "ahead",
      "ahoy",
      "aide",
      "aids",
      "aim",
      "ajar",
      "alabaster",
      "alarm",
      "albatross",
      "album",
      "alfalfa",
      "algebra",
      "algorithm",
      "alias",
      "alibi",
      "alienable",
      "alienate",
      "aliens",
      "alike",
      "alive",
      "alkaline",
      "alkalize",
      "almanac",
      "almighty",
      "almost",
      "aloe",
      "aloft",
      "aloha",
      "alone",
      "alongside",
      "aloof",
      "alphabet",
      "alright",
      "although",
      "altitude",
      "alto",
      "aluminum",
      "alumni",
      "always",
      "amaretto",
      "amaze",
      "amazingly",
      "amber",
      "ambiance",
      "ambiguity",
      "ambiguous",
      "ambition",
      "ambitious",
      "ambulance",
      "ambush",
      "amendable",
      "amendment",
      "amends",
      "amenity",
      "amiable",
      "amicably",
      "amid",
      "amigo",
      "amino",
      "amiss",
      "ammonia",
      "ammonium",
      "amnesty",
      "amniotic",
      "among",
      "amount",
      "amperage",
      "ample",
      "amplifier",
      "amplify",
      "amply",
      "amuck",
      "amulet",
      "amusable",
      "amused",
      "amusement",
      "amuser",
      "amusing",
      "anaconda",
      "anaerobic",
      "anagram",
      "anatomist",
      "anatomy",
      "anchor",
      "anchovy",
      "ancient",
      "android",
      "anemia",
      "anemic",
      "aneurism",
      "anew",
      "angelfish",
      "angelic",
      "anger",
      "angled",
      "angler",
      "angles",
      "angling",
      "angrily",
      "angriness",
      "anguished",
      "angular",
      "animal",
      "animate",
      "animating",
      "animation",
      "animator",
      "anime",
      "animosity",
      "ankle",
      "annex",
      "annotate",
      "announcer",
      "annoying",
      "annually",
      "annuity",
      "anointer",
      "another",
      "answering",
      "antacid",
      "antarctic",
      "anteater",
      "antelope",
      "antennae",
      "anthem",
      "anthill",
      "anthology",
      "antibody",
      "antics",
      "antidote",
      "antihero",
      "antiquely",
      "antiques",
      "antiquity",
      "antirust",
      "antitoxic",
      "antitrust",
      "antiviral",
      "antivirus",
      "antler",
      "antonym",
      "antsy",
      "anvil",
      "anybody",
      "anyhow",
      "anymore",
      "anyone",
      "anyplace",
      "anything",
      "anytime",
      "anyway",
      "anywhere",
      "aorta",
      "apache",
      "apostle",
      "appealing",
      "appear",
      "appease",
      "appeasing",
      "appendage",
      "appendix",
      "appetite",
      "appetizer",
      "applaud",
      "applause",
      "apple",
      "appliance",
      "applicant",
      "applied",
      "apply",
      "appointee",
      "appraisal",
      "appraiser",
      "apprehend",
      "approach",
      "approval",
      "approve",
      "apricot",
      "april",
      "apron",
      "aptitude",
      "aptly",
      "aqua",
      "aqueduct",
      "arbitrary",
      "arbitrate",
      "ardently",
      "area",
      "arena",
      "arguable",
      "arguably",
      "argue",
      "arise",
      "armadillo",
      "armband",
      "armchair",
      "armed",
      "armful",
      "armhole",
      "arming",
      "armless",
      "armoire",
      "armored",
      "armory",
      "armrest",
      "army",
      "aroma",
      "arose",
      "around",
      "arousal",
      "arrange",
      "array",
      "arrest",
      "arrival",
      "arrive",
      "arrogance",
      "arrogant",
      "arson",
      "art",
      "ascend",
      "ascension",
      "ascent",
      "ascertain",
      "ashamed",
      "ashen",
      "ashes",
      "ashy",
      "aside",
      "askew",
      "asleep",
      "asparagus",
      "aspect",
      "aspirate",
      "aspire",
      "aspirin",
      "astonish",
      "astound",
      "astride",
      "astrology",
      "astronaut",
      "astronomy",
      "astute",
      "atlantic",
      "atlas",
      "atom",
      "atonable",
      "atop",
      "atrium",
      "atrocious",
      "atrophy",
      "attach",
      "attain",
      "attempt",
      "attendant",
      "attendee",
      "attention",
      "attentive",
      "attest",
      "attic",
      "attire",
      "attitude",
      "attractor",
      "attribute",
      "atypical",
      "auction",
      "audacious",
      "audacity",
      "audible",
      "audibly",
      "audience",
      "audio",
      "audition",
      "augmented",
      "august",
      "authentic",
      "author",
      "autism",
      "autistic",
      "autograph",
      "automaker",
      "automated",
      "automatic",
      "autopilot",
      "available",
      "avalanche",
      "avatar",
      "avenge",
      "avenging",
      "avenue",
      "average",
      "aversion",
      "avert",
      "aviation",
      "aviator",
      "avid",
      "avoid",
      "await",
      "awaken",
      "award",
      "aware",
      "awhile",
      "awkward",
      "awning",
      "awoke",
      "awry",
      "axis",
      "babble",
      "babbling",
      "babied",
      "baboon",
      "backache",
      "backboard",
      "backboned",
      "backdrop",
      "backed",
      "backer",
      "backfield",
      "backfire",
      "backhand",
      "backing",
      "backlands",
      "backlash",
      "backless",
      "backlight",
      "backlit",
      "backlog",
      "backpack",
      "backpedal",
      "backrest",
      "backroom",
      "backshift",
      "backside",
      "backslid",
      "backspace",
      "backspin",
      "backstab",
      "backstage",
      "backtalk",
      "backtrack",
      "backup",
      "backward",
      "backwash",
      "backwater",
      "backyard",
      "bacon",
      "bacteria",
      "bacterium",
      "badass",
      "badge",
      "badland",
      "badly",
      "badness",
      "baffle",
      "baffling",
      "bagel",
      "bagful",
      "baggage",
      "bagged",
      "baggie",
      "bagginess",
      "bagging",
      "baggy",
      "bagpipe",
      "baguette",
      "baked",
      "bakery",
      "bakeshop",
      "baking",
      "balance",
      "balancing",
      "balcony",
      "balmy",
      "balsamic",
      "bamboo",
      "banana",
      "banish",
      "banister",
      "banjo",
      "bankable",
      "bankbook",
      "banked",
      "banker",
      "banking",
      "banknote",
      "bankroll",
      "banner",
      "bannister",
      "banshee",
      "banter",
      "barbecue",
      "barbed",
      "barbell",
      "barber",
      "barcode",
      "barge",
      "bargraph",
      "barista",
      "baritone",
      "barley",
      "barmaid",
      "barman",
      "barn",
      "barometer",
      "barrack",
      "barracuda",
      "barrel",
      "barrette",
      "barricade",
      "barrier",
      "barstool",
      "bartender",
      "barterer",
      "bash",
      "basically",
      "basics",
      "basil",
      "basin",
      "basis",
      "basket",
      "batboy",
      "batch",
      "bath",
      "baton",
      "bats",
      "battalion",
      "battered",
      "battering",
      "battery",
      "batting",
      "battle",
      "bauble",
      "bazooka",
      "blabber",
      "bladder",
      "blade",
      "blah",
      "blame",
      "blaming",
      "blanching",
      "blandness",
      "blank",
      "blaspheme",
      "blasphemy",
      "blast",
      "blatancy",
      "blatantly",
      "blazer",
      "blazing",
      "bleach",
      "bleak",
      "bleep",
      "blemish",
      "blend",
      "bless",
      "blighted",
      "blimp",
      "bling",
      "blinked",
      "blinker",
      "blinking",
      "blinks",
      "blip",
      "blissful",
      "blitz",
      "blizzard",
      "bloated",
      "bloating",
      "blob",
      "blog",
      "bloomers",
      "blooming",
      "blooper",
      "blot",
      "blouse",
      "blubber",
      "bluff",
      "bluish",
      "blunderer",
      "blunt",
      "blurb",
      "blurred",
      "blurry",
      "blurt",
      "blush",
      "blustery",
      "boaster",
      "boastful",
      "boasting",
      "boat",
      "bobbed",
      "bobbing",
      "bobble",
      "bobcat",
      "bobsled",
      "bobtail",
      "bodacious",
      "body",
      "bogged",
      "boggle",
      "bogus",
      "boil",
      "bok",
      "bolster",
      "bolt",
      "bonanza",
      "bonded",
      "bonding",
      "bondless",
      "boned",
      "bonehead",
      "boneless",
      "bonelike",
      "boney",
      "bonfire",
      "bonnet",
      "bonsai",
      "bonus",
      "bony",
      "boogeyman",
      "boogieman",
      "book",
      "boondocks",
      "booted",
      "booth",
      "bootie",
      "booting",
      "bootlace",
      "bootleg",
      "boots",
      "boozy",
      "borax",
      "boring",
      "borough",
      "borrower",
      "borrowing",
      "boss",
      "botanical",
      "botanist",
      "botany",
      "botch",
      "both",
      "bottle",
      "bottling",
      "bottom",
      "bounce",
      "bouncing",
      "bouncy",
      "bounding",
      "boundless",
      "bountiful",
      "bovine",
      "boxcar",
      "boxer",
      "boxing",
      "boxlike",
      "boxy",
      "breach",
      "breath",
      "breeches",
      "breeching",
      "breeder",
      "breeding",
      "breeze",
      "breezy",
      "brethren",
      "brewery",
      "brewing",
      "briar",
      "bribe",
      "brick",
      "bride",
      "bridged",
      "brigade",
      "bright",
      "brilliant",
      "brim",
      "bring",
      "brink",
      "brisket",
      "briskly",
      "briskness",
      "bristle",
      "brittle",
      "broadband",
      "broadcast",
      "broaden",
      "broadly",
      "broadness",
      "broadside",
      "broadways",
      "broiler",
      "broiling",
      "broken",
      "broker",
      "bronchial",
      "bronco",
      "bronze",
      "bronzing",
      "brook",
      "broom",
      "brought",
      "browbeat",
      "brownnose",
      "browse",
      "browsing",
      "bruising",
      "brunch",
      "brunette",
      "brunt",
      "brush",
      "brussels",
      "brute",
      "brutishly",
      "bubble",
      "bubbling",
      "bubbly",
      "buccaneer",
      "bucked",
      "bucket",
      "buckle",
      "buckshot",
      "buckskin",
      "bucktooth",
      "buckwheat",
      "buddhism",
      "buddhist",
      "budding",
      "buddy",
      "budget",
      "buffalo",
      "buffed",
      "buffer",
      "buffing",
      "buffoon",
      "buggy",
      "bulb",
      "bulge",
      "bulginess",
      "bulgur",
      "bulk",
      "bulldog",
      "bulldozer",
      "bullfight",
      "bullfrog",
      "bullhorn",
      "bullion",
      "bullish",
      "bullpen",
      "bullring",
      "bullseye",
      "bullwhip",
      "bully",
      "bunch",
      "bundle",
      "bungee",
      "bunion",
      "bunkbed",
      "bunkhouse",
      "bunkmate",
      "bunny",
      "bunt",
      "busboy",
      "bush",
      "busily",
      "busload",
      "bust",
      "busybody",
      "buzz",
      "cabana",
      "cabbage",
      "cabbie",
      "cabdriver",
      "cable",
      "caboose",
      "cache",
      "cackle",
      "cacti",
      "cactus",
      "caddie",
      "caddy",
      "cadet",
      "cadillac",
      "cadmium",
      "cage",
      "cahoots",
      "cake",
      "calamari",
      "calamity",
      "calcium",
      "calculate",
      "calculus",
      "caliber",
      "calibrate",
      "calm",
      "caloric",
      "calorie",
      "calzone",
      "camcorder",
      "cameo",
      "camera",
      "camisole",
      "camper",
      "campfire",
      "camping",
      "campsite",
      "campus",
      "canal",
      "canary",
      "cancel",
      "candied",
      "candle",
      "candy",
      "cane",
      "canine",
      "canister",
      "cannabis",
      "canned",
      "canning",
      "cannon",
      "cannot",
      "canola",
      "canon",
      "canopener",
      "canopy",
      "canteen",
      "canyon",
      "capable",
      "capably",
      "capacity",
      "cape",
      "capillary",
      "capital",
      "capitol",
      "capped",
      "capricorn",
      "capsize",
      "capsule",
      "caption",
      "captivate",
      "captive",
      "captivity",
      "capture",
      "caramel",
      "carat",
      "caravan",
      "carbon",
      "cardboard",
      "carded",
      "cardiac",
      "cardigan",
      "cardinal",
      "cardstock",
      "carefully",
      "caregiver",
      "careless",
      "caress",
      "caretaker",
      "cargo",
      "caring",
      "carless",
      "carload",
      "carmaker",
      "carnage",
      "carnation",
      "carnival",
      "carnivore",
      "carol",
      "carpenter",
      "carpentry",
      "carpool",
      "carport",
      "carried",
      "carrot",
      "carrousel",
      "carry",
      "cartel",
      "cartload",
      "carton",
      "cartoon",
      "cartridge",
      "cartwheel",
      "carve",
      "carving",
      "carwash",
      "cascade",
      "case",
      "cash",
      "casing",
      "casino",
      "casket",
      "cassette",
      "casually",
      "casualty",
      "catacomb",
      "catalog",
      "catalyst",
      "catalyze",
      "catapult",
      "cataract",
      "catatonic",
      "catcall",
      "catchable",
      "catcher",
      "catching",
      "catchy",
      "caterer",
      "catering",
      "catfight",
      "catfish",
      "cathedral",
      "cathouse",
      "catlike",
      "catnap",
      "catnip",
      "catsup",
      "cattail",
      "cattishly",
      "cattle",
      "catty",
      "catwalk",
      "caucasian",
      "caucus",
      "causal",
      "causation",
      "cause",
      "causing",
      "cauterize",
      "caution",
      "cautious",
      "cavalier",
      "cavalry",
      "caviar",
      "cavity",
      "cedar",
      "celery",
      "celestial",
      "celibacy",
      "celibate",
      "celtic",
      "cement",
      "census",
      "ceramics",
      "ceremony",
      "certainly",
      "certainty",
      "certified",
      "certify",
      "cesarean",
      "cesspool",
      "chafe",
      "chaffing",
      "chain",
      "chair",
      "chalice",
      "challenge",
      "chamber",
      "chamomile",
      "champion",
      "chance",
      "change",
      "channel",
      "chant",
      "chaos",
      "chaperone",
      "chaplain",
      "chapped",
      "chaps",
      "chapter",
      "character",
      "charbroil",
      "charcoal",
      "charger",
      "charging",
      "chariot",
      "charity",
      "charm",
      "charred",
      "charter",
      "charting",
      "chase",
      "chasing",
      "chaste",
      "chastise",
      "chastity",
      "chatroom",
      "chatter",
      "chatting",
      "chatty",
      "cheating",
      "cheddar",
      "cheek",
      "cheer",
      "cheese",
      "cheesy",
      "chef",
      "chemicals",
      "chemist",
      "chemo",
      "cherisher",
      "cherub",
      "chess",
      "chest",
      "chevron",
      "chevy",
      "chewable",
      "chewer",
      "chewing",
      "chewy",
      "chief",
      "chihuahua",
      "childcare",
      "childhood",
      "childish",
      "childless",
      "childlike",
      "chili",
      "chill",
      "chimp",
      "chip",
      "chirping",
      "chirpy",
      "chitchat",
      "chivalry",
      "chive",
      "chloride",
      "chlorine",
      "choice",
      "chokehold",
      "choking",
      "chomp",
      "chooser",
      "choosing",
      "choosy",
      "chop",
      "chosen",
      "chowder",
      "chowtime",
      "chrome",
      "chubby",
      "chuck",
      "chug",
      "chummy",
      "chump",
      "chunk",
      "churn",
      "chute",
      "cider",
      "cilantro",
      "cinch",
      "cinema",
      "cinnamon",
      "circle",
      "circling",
      "circular",
      "circulate",
      "circus",
      "citable",
      "citadel",
      "citation",
      "citizen",
      "citric",
      "citrus",
      "city",
      "civic",
      "civil",
      "clad",
      "claim",
      "clambake",
      "clammy",
      "clamor",
      "clamp",
      "clamshell",
      "clang",
      "clanking",
      "clapped",
      "clapper",
      "clapping",
      "clarify",
      "clarinet",
      "clarity",
      "clash",
      "clasp",
      "class",
      "clatter",
      "clause",
      "clavicle",
      "claw",
      "clay",
      "clean",
      "clear",
      "cleat",
      "cleaver",
      "cleft",
      "clench",
      "clergyman",
      "clerical",
      "clerk",
      "clever",
      "clicker",
      "client",
      "climate",
      "climatic",
      "cling",
      "clinic",
      "clinking",
      "clip",
      "clique",
      "cloak",
      "clobber",
      "clock",
      "clone",
      "cloning",
      "closable",
      "closure",
      "clothes",
      "clothing",
      "cloud",
      "clover",
      "clubbed",
      "clubbing",
      "clubhouse",
      "clump",
      "clumsily",
      "clumsy",
      "clunky",
      "clustered",
      "clutch",
      "clutter",
      "coach",
      "coagulant",
      "coastal",
      "coaster",
      "coasting",
      "coastland",
      "coastline",
      "coat",
      "coauthor",
      "cobalt",
      "cobbler",
      "cobweb",
      "cocoa",
      "coconut",
      "cod",
      "coeditor",
      "coerce",
      "coexist",
      "coffee",
      "cofounder",
      "cognition",
      "cognitive",
      "cogwheel",
      "coherence",
      "coherent",
      "cohesive",
      "coil",
      "coke",
      "cola",
      "cold",
      "coleslaw",
      "coliseum",
      "collage",
      "collapse",
      "collar",
      "collected",
      "collector",
      "collide",
      "collie",
      "collision",
      "colonial",
      "colonist",
      "colonize",
      "colony",
      "colossal",
      "colt",
      "coma",
      "come",
      "comfort",
      "comfy",
      "comic",
      "coming",
      "comma",
      "commence",
      "commend",
      "comment",
      "commerce",
      "commode",
      "commodity",
      "commodore",
      "common",
      "commotion",
      "commute",
      "commuting",
      "compacted",
      "compacter",
      "compactly",
      "compactor",
      "companion",
      "company",
      "compare",
      "compel",
      "compile",
      "comply",
      "component",
      "composed",
      "composer",
      "composite",
      "compost",
      "composure",
      "compound",
      "compress",
      "comprised",
      "computer",
      "computing",
      "comrade",
      "concave",
      "conceal",
      "conceded",
      "concept",
      "concerned",
      "concert",
      "conch",
      "concierge",
      "concise",
      "conclude",
      "concrete",
      "concur",
      "condense",
      "condiment",
      "condition",
      "condone",
      "conducive",
      "conductor",
      "conduit",
      "cone",
      "confess",
      "confetti",
      "confidant",
      "confident",
      "confider",
      "confiding",
      "configure",
      "confined",
      "confining",
      "confirm",
      "conflict",
      "conform",
      "confound",
      "confront",
      "confused",
      "confusing",
      "confusion",
      "congenial",
      "congested",
      "congrats",
      "congress",
      "conical",
      "conjoined",
      "conjure",
      "conjuror",
      "connected",
      "connector",
      "consensus",
      "consent",
      "console",
      "consoling",
      "consonant",
      "constable",
      "constant",
      "constrain",
      "constrict",
      "construct",
      "consult",
      "consumer",
      "consuming",
      "contact",
      "container",
      "contempt",
      "contend",
      "contented",
      "contently",
      "contents",
      "contest",
      "context",
      "contort",
      "contour",
      "contrite",
      "control",
      "contusion",
      "convene",
      "convent",
      "copartner",
      "cope",
      "copied",
      "copier",
      "copilot",
      "coping",
      "copious",
      "copper",
      "copy",
      "coral",
      "cork",
      "cornball",
      "cornbread",
      "corncob",
      "cornea",
      "corned",
      "corner",
      "cornfield",
      "cornflake",
      "cornhusk",
      "cornmeal",
      "cornstalk",
      "corny",
      "coronary",
      "coroner",
      "corporal",
      "corporate",
      "corral",
      "correct",
      "corridor",
      "corrode",
      "corroding",
      "corrosive",
      "corsage",
      "corset",
      "cortex",
      "cosigner",
      "cosmetics",
      "cosmic",
      "cosmos",
      "cosponsor",
      "cost",
      "cottage",
      "cotton",
      "couch",
      "cough",
      "could",
      "countable",
      "countdown",
      "counting",
      "countless",
      "country",
      "county",
      "courier",
      "covenant",
      "cover",
      "coveted",
      "coveting",
      "coyness",
      "cozily",
      "coziness",
      "cozy",
      "crabbing",
      "crabgrass",
      "crablike",
      "crabmeat",
      "cradle",
      "cradling",
      "crafter",
      "craftily",
      "craftsman",
      "craftwork",
      "crafty",
      "cramp",
      "cranberry",
      "crane",
      "cranial",
      "cranium",
      "crank",
      "crate",
      "crave",
      "craving",
      "crawfish",
      "crawlers",
      "crawling",
      "crayfish",
      "crayon",
      "crazed",
      "crazily",
      "craziness",
      "crazy",
      "creamed",
      "creamer",
      "creamlike",
      "crease",
      "creasing",
      "creatable",
      "create",
      "creation",
      "creative",
      "creature",
      "credible",
      "credibly",
      "credit",
      "creed",
      "creme",
      "creole",
      "crepe",
      "crept",
      "crescent",
      "crested",
      "cresting",
      "crestless",
      "crevice",
      "crewless",
      "crewman",
      "crewmate",
      "crib",
      "cricket",
      "cried",
      "crier",
      "crimp",
      "crimson",
      "cringe",
      "cringing",
      "crinkle",
      "crinkly",
      "crisped",
      "crisping",
      "crisply",
      "crispness",
      "crispy",
      "criteria",
      "critter",
      "croak",
      "crock",
      "crook",
      "croon",
      "crop",
      "cross",
      "crouch",
      "crouton",
      "crowbar",
      "crowd",
      "crown",
      "crucial",
      "crudely",
      "crudeness",
      "cruelly",
      "cruelness",
      "cruelty",
      "crumb",
      "crummiest",
      "crummy",
      "crumpet",
      "crumpled",
      "cruncher",
      "crunching",
      "crunchy",
      "crusader",
      "crushable",
      "crushed",
      "crusher",
      "crushing",
      "crust",
      "crux",
      "crying",
      "cryptic",
      "crystal",
      "cubbyhole",
      "cube",
      "cubical",
      "cubicle",
      "cucumber",
      "cuddle",
      "cuddly",
      "cufflink",
      "culinary",
      "culminate",
      "culpable",
      "culprit",
      "cultivate",
      "cultural",
      "culture",
      "cupbearer",
      "cupcake",
      "cupid",
      "cupped",
      "cupping",
      "curable",
      "curator",
      "curdle",
      "cure",
      "curfew",
      "curing",
      "curled",
      "curler",
      "curliness",
      "curling",
      "curly",
      "curry",
      "curse",
      "cursive",
      "cursor",
      "curtain",
      "curtly",
      "curtsy",
      "curvature",
      "curve",
      "curvy",
      "cushy",
      "cusp",
      "cussed",
      "custard",
      "custodian",
      "custody",
      "customary",
      "customer",
      "customize",
      "customs",
      "cut",
      "cycle",
      "cyclic",
      "cycling",
      "cyclist",
      "cylinder",
      "cymbal",
      "cytoplasm",
      "cytoplast",
      "dab",
      "dad",
      "daffodil",
      "dagger",
      "daily",
      "daintily",
      "dainty",
      "dairy",
      "daisy",
      "dallying",
      "dance",
      "dancing",
      "dandelion",
      "dander",
      "dandruff",
      "dandy",
      "danger",
      "dangle",
      "dangling",
      "daredevil",
      "dares",
      "daringly",
      "darkened",
      "darkening",
      "darkish",
      "darkness",
      "darkroom",
      "darling",
      "darn",
      "dart",
      "darwinism",
      "dash",
      "dastardly",
      "data",
      "datebook",
      "dating",
      "daughter",
      "daunting",
      "dawdler",
      "dawn",
      "daybed",
      "daybreak",
      "daycare",
      "daydream",
      "daylight",
      "daylong",
      "dayroom",
      "daytime",
      "dazzler",
      "dazzling",
      "deacon",
      "deafening",
      "deafness",
      "dealer",
      "dealing",
      "dealmaker",
      "dealt",
      "dean",
      "debatable",
      "debate",
      "debating",
      "debit",
      "debrief",
      "debtless",
      "debtor",
      "debug",
      "debunk",
      "decade",
      "decaf",
      "decal",
      "decathlon",
      "decay",
      "deceased",
      "deceit",
      "deceiver",
      "deceiving",
      "december",
      "decency",
      "decent",
      "deception",
      "deceptive",
      "decibel",
      "decidable",
      "decimal",
      "decimeter",
      "decipher",
      "deck",
      "declared",
      "decline",
      "decode",
      "decompose",
      "decorated",
      "decorator",
      "decoy",
      "decrease",
      "decree",
      "dedicate",
      "dedicator",
      "deduce",
      "deduct",
      "deed",
      "deem",
      "deepen",
      "deeply",
      "deepness",
      "deface",
      "defacing",
      "defame",
      "default",
      "defeat",
      "defection",
      "defective",
      "defendant",
      "defender",
      "defense",
      "defensive",
      "deferral",
      "deferred",
      "defiance",
      "defiant",
      "defile",
      "defiling",
      "define",
      "definite",
      "deflate",
      "deflation",
      "deflator",
      "deflected",
      "deflector",
      "defog",
      "deforest",
      "defraud",
      "defrost",
      "deftly",
      "defuse",
      "defy",
      "degraded",
      "degrading",
      "degrease",
      "degree",
      "dehydrate",
      "deity",
      "dejected",
      "delay",
      "delegate",
      "delegator",
      "delete",
      "deletion",
      "delicacy",
      "delicate",
      "delicious",
      "delighted",
      "delirious",
      "delirium",
      "deliverer",
      "delivery",
      "delouse",
      "delta",
      "deluge",
      "delusion",
      "deluxe",
      "demanding",
      "demeaning",
      "demeanor",
      "demise",
      "democracy",
      "democrat",
      "demote",
      "demotion",
      "demystify",
      "denatured",
      "deniable",
      "denial",
      "denim",
      "denote",
      "dense",
      "density",
      "dental",
      "dentist",
      "denture",
      "deny",
      "deodorant",
      "deodorize",
      "departed",
      "departure",
      "depict",
      "deplete",
      "depletion",
      "deplored",
      "deploy",
      "deport",
      "depose",
      "depraved",
      "depravity",
      "deprecate",
      "depress",
      "deprive",
      "depth",
      "deputize",
      "deputy",
      "derail",
      "deranged",
      "derby",
      "derived",
      "desecrate",
      "deserve",
      "deserving",
      "designate",
      "designed",
      "designer",
      "designing",
      "deskbound",
      "desktop",
      "deskwork",
      "desolate",
      "despair",
      "despise",
      "despite",
      "destiny",
      "destitute",
      "destruct",
      "detached",
      "detail",
      "detection",
      "detective",
      "detector",
      "detention",
      "detergent",
      "detest",
      "detonate",
      "detonator",
      "detoxify",
      "detract",
      "deuce",
      "devalue",
      "deviancy",
      "deviant",
      "deviate",
      "deviation",
      "deviator",
      "device",
      "devious",
      "devotedly",
      "devotee",
      "devotion",
      "devourer",
      "devouring",
      "devoutly",
      "dexterity",
      "dexterous",
      "diabetes",
      "diabetic",
      "diabolic",
      "diagnoses",
      "diagnosis",
      "diagram",
      "dial",
      "diameter",
      "diaper",
      "diaphragm",
      "diary",
      "dice",
      "dicing",
      "dictate",
      "dictation",
      "dictator",
      "difficult",
      "diffused",
      "diffuser",
      "diffusion",
      "diffusive",
      "dig",
      "dilation",
      "diligence",
      "diligent",
      "dill",
      "dilute",
      "dime",
      "diminish",
      "dimly",
      "dimmed",
      "dimmer",
      "dimness",
      "dimple",
      "diner",
      "dingbat",
      "dinghy",
      "dinginess",
      "dingo",
      "dingy",
      "dining",
      "dinner",
      "diocese",
      "dioxide",
      "diploma",
      "dipped",
      "dipper",
      "dipping",
      "directed",
      "direction",
      "directive",
      "directly",
      "directory",
      "direness",
      "dirtiness",
      "disabled",
      "disagree",
      "disallow",
      "disarm",
      "disarray",
      "disaster",
      "disband",
      "disbelief",
      "disburse",
      "discard",
      "discern",
      "discharge",
      "disclose",
      "discolor",
      "discount",
      "discourse",
      "discover",
      "discuss",
      "disdain",
      "disengage",
      "disfigure",
      "disgrace",
      "dish",
      "disinfect",
      "disjoin",
      "disk",
      "dislike",
      "disliking",
      "dislocate",
      "dislodge",
      "disloyal",
      "dismantle",
      "dismay",
      "dismiss",
      "dismount",
      "disobey",
      "disorder",
      "disown",
      "disparate",
      "disparity",
      "dispatch",
      "dispense",
      "dispersal",
      "dispersed",
      "disperser",
      "displace",
      "display",
      "displease",
      "disposal",
      "dispose",
      "disprove",
      "dispute",
      "disregard",
      "disrupt",
      "dissuade",
      "distance",
      "distant",
      "distaste",
      "distill",
      "distinct",
      "distort",
      "distract",
      "distress",
      "district",
      "distrust",
      "ditch",
      "ditto",
      "ditzy",
      "dividable",
      "divided",
      "dividend",
      "dividers",
      "dividing",
      "divinely",
      "diving",
      "divinity",
      "divisible",
      "divisibly",
      "division",
      "divisive",
      "divorcee",
      "dizziness",
      "dizzy",
      "doable",
      "docile",
      "dock",
      "doctrine",
      "document",
      "dodge",
      "dodgy",
      "doily",
      "doing",
      "dole",
      "dollar",
      "dollhouse",
      "dollop",
      "dolly",
      "dolphin",
      "domain",
      "domelike",
      "domestic",
      "dominion",
      "dominoes",
      "donated",
      "donation",
      "donator",
      "donor",
      "donut",
      "doodle",
      "doorbell",
      "doorframe",
      "doorknob",
      "doorman",
      "doormat",
      "doornail",
      "doorpost",
      "doorstep",
      "doorstop",
      "doorway",
      "doozy",
      "dork",
      "dormitory",
      "dorsal",
      "dosage",
      "dose",
      "dotted",
      "doubling",
      "douche",
      "dove",
      "down",
      "dowry",
      "doze",
      "drab",
      "dragging",
      "dragonfly",
      "dragonish",
      "dragster",
      "drainable",
      "drainage",
      "drained",
      "drainer",
      "drainpipe",
      "dramatic",
      "dramatize",
      "drank",
      "drapery",
      "drastic",
      "draw",
      "dreaded",
      "dreadful",
      "dreadlock",
      "dreamboat",
      "dreamily",
      "dreamland",
      "dreamless",
      "dreamlike",
      "dreamt",
      "dreamy",
      "drearily",
      "dreary",
      "drench",
      "dress",
      "drew",
      "dribble",
      "dried",
      "drier",
      "drift",
      "driller",
      "drilling",
      "drinkable",
      "drinking",
      "dripping",
      "drippy",
      "drivable",
      "driven",
      "driver",
      "driveway",
      "driving",
      "drizzle",
      "drizzly",
      "drone",
      "drool",
      "droop",
      "drop-down",
      "dropbox",
      "dropkick",
      "droplet",
      "dropout",
      "dropper",
      "drove",
      "drown",
      "drowsily",
      "drudge",
      "drum",
      "dry",
      "dubbed",
      "dubiously",
      "duchess",
      "duckbill",
      "ducking",
      "duckling",
      "ducktail",
      "ducky",
      "duct",
      "dude",
      "duffel",
      "dugout",
      "duh",
      "duke",
      "duller",
      "dullness",
      "duly",
      "dumping",
      "dumpling",
      "dumpster",
      "duo",
      "dupe",
      "duplex",
      "duplicate",
      "duplicity",
      "durable",
      "durably",
      "duration",
      "duress",
      "during",
      "dusk",
      "dust",
      "dutiful",
      "duty",
      "duvet",
      "dwarf",
      "dweeb",
      "dwelled",
      "dweller",
      "dwelling",
      "dwindle",
      "dwindling",
      "dynamic",
      "dynamite",
      "dynasty",
      "dyslexia",
      "dyslexic",
      "each",
      "eagle",
      "earache",
      "eardrum",
      "earflap",
      "earful",
      "earlobe",
      "early",
      "earmark",
      "earmuff",
      "earphone",
      "earpiece",
      "earplugs",
      "earring",
      "earshot",
      "earthen",
      "earthlike",
      "earthling",
      "earthly",
      "earthworm",
      "earthy",
      "earwig",
      "easeful",
      "easel",
      "easiest",
      "easily",
      "easiness",
      "easing",
      "eastbound",
      "eastcoast",
      "easter",
      "eastward",
      "eatable",
      "eaten",
      "eatery",
      "eating",
      "eats",
      "ebay",
      "ebony",
      "ebook",
      "ecard",
      "eccentric",
      "echo",
      "eclair",
      "eclipse",
      "ecologist",
      "ecology",
      "economic",
      "economist",
      "economy",
      "ecosphere",
      "ecosystem",
      "edge",
      "edginess",
      "edging",
      "edgy",
      "edition",
      "editor",
      "educated",
      "education",
      "educator",
      "eel",
      "effective",
      "effects",
      "efficient",
      "effort",
      "eggbeater",
      "egging",
      "eggnog",
      "eggplant",
      "eggshell",
      "egomaniac",
      "egotism",
      "egotistic",
      "either",
      "eject",
      "elaborate",
      "elastic",
      "elated",
      "elbow",
      "eldercare",
      "elderly",
      "eldest",
      "electable",
      "election",
      "elective",
      "elephant",
      "elevate",
      "elevating",
      "elevation",
      "elevator",
      "eleven",
      "elf",
      "eligible",
      "eligibly",
      "eliminate",
      "elite",
      "elitism",
      "elixir",
      "elk",
      "ellipse",
      "elliptic",
      "elm",
      "elongated",
      "elope",
      "eloquence",
      "eloquent",
      "elsewhere",
      "elude",
      "elusive",
      "elves",
      "email",
      "embargo",
      "embark",
      "embassy",
      "embattled",
      "embellish",
      "ember",
      "embezzle",
      "emblaze",
      "emblem",
      "embody",
      "embolism",
      "emboss",
      "embroider",
      "emcee",
      "emerald",
      "emergency",
      "emission",
      "emit",
      "emote",
      "emoticon",
      "emotion",
      "empathic",
      "empathy",
      "emperor",
      "emphases",
      "emphasis",
      "emphasize",
      "emphatic",
      "empirical",
      "employed",
      "employee",
      "employer",
      "emporium",
      "empower",
      "emptier",
      "emptiness",
      "empty",
      "emu",
      "enable",
      "enactment",
      "enamel",
      "enchanted",
      "enchilada",
      "encircle",
      "enclose",
      "enclosure",
      "encode",
      "encore",
      "encounter",
      "encourage",
      "encroach",
      "encrust",
      "encrypt",
      "endanger",
      "endeared",
      "endearing",
      "ended",
      "ending",
      "endless",
      "endnote",
      "endocrine",
      "endorphin",
      "endorse",
      "endowment",
      "endpoint",
      "endurable",
      "endurance",
      "enduring",
      "energetic",
      "energize",
      "energy",
      "enforced",
      "enforcer",
      "engaged",
      "engaging",
      "engine",
      "engorge",
      "engraved",
      "engraver",
      "engraving",
      "engross",
      "engulf",
      "enhance",
      "enigmatic",
      "enjoyable",
      "enjoyably",
      "enjoyer",
      "enjoying",
      "enjoyment",
      "enlarged",
      "enlarging",
      "enlighten",
      "enlisted",
      "enquirer",
      "enrage",
      "enrich",
      "enroll",
      "enslave",
      "ensnare",
      "ensure",
      "entail",
      "entangled",
      "entering",
      "entertain",
      "enticing",
      "entire",
      "entitle",
      "entity",
      "entomb",
      "entourage",
      "entrap",
      "entree",
      "entrench",
      "entrust",
      "entryway",
      "entwine",
      "enunciate",
      "envelope",
      "enviable",
      "enviably",
      "envious",
      "envision",
      "envoy",
      "envy",
      "enzyme",
      "epic",
      "epidemic",
      "epidermal",
      "epidermis",
      "epidural",
      "epilepsy",
      "epileptic",
      "epilogue",
      "epiphany",
      "episode",
      "equal",
      "equate",
      "equation",
      "equator",
      "equinox",
      "equipment",
      "equity",
      "equivocal",
      "eradicate",
      "erasable",
      "erased",
      "eraser",
      "erasure",
      "ergonomic",
      "errand",
      "errant",
      "erratic",
      "error",
      "erupt",
      "escalate",
      "escalator",
      "escapable",
      "escapade",
      "escapist",
      "escargot",
      "eskimo",
      "esophagus",
      "espionage",
      "espresso",
      "esquire",
      "essay",
      "essence",
      "essential",
      "establish",
      "estate",
      "esteemed",
      "estimate",
      "estimator",
      "estranged",
      "estrogen",
      "etching",
      "eternal",
      "eternity",
      "ethanol",
      "ether",
      "ethically",
      "ethics",
      "euphemism",
      "evacuate",
      "evacuee",
      "evade",
      "evaluate",
      "evaluator",
      "evaporate",
      "evasion",
      "evasive",
      "even",
      "everglade",
      "evergreen",
      "everybody",
      "everyday",
      "everyone",
      "evict",
      "evidence",
      "evident",
      "evil",
      "evoke",
      "evolution",
      "evolve",
      "exact",
      "exalted",
      "example",
      "excavate",
      "excavator",
      "exceeding",
      "exception",
      "excess",
      "exchange",
      "excitable",
      "exciting",
      "exclaim",
      "exclude",
      "excluding",
      "exclusion",
      "exclusive",
      "excretion",
      "excretory",
      "excursion",
      "excusable",
      "excusably",
      "excuse",
      "exemplary",
      "exemplify",
      "exemption",
      "exerciser",
      "exert",
      "exes",
      "exfoliate",
      "exhale",
      "exhaust",
      "exhume",
      "exile",
      "existing",
      "exit",
      "exodus",
      "exonerate",
      "exorcism",
      "exorcist",
      "expand",
      "expanse",
      "expansion",
      "expansive",
      "expectant",
      "expedited",
      "expediter",
      "expel",
      "expend",
      "expenses",
      "expensive",
      "expert",
      "expire",
      "expiring",
      "explain",
      "expletive",
      "explicit",
      "explode",
      "exploit",
      "explore",
      "exploring",
      "exponent",
      "exporter",
      "exposable",
      "expose",
      "exposure",
      "express",
      "expulsion",
      "exquisite",
      "extended",
      "extending",
      "extent",
      "extenuate",
      "exterior",
      "external",
      "extinct",
      "extortion",
      "extradite",
      "extras",
      "extrovert",
      "extrude",
      "extruding",
      "exuberant",
      "fable",
      "fabric",
      "fabulous",
      "facebook",
      "facecloth",
      "facedown",
      "faceless",
      "facelift",
      "faceplate",
      "faceted",
      "facial",
      "facility",
      "facing",
      "facsimile",
      "faction",
      "factoid",
      "factor",
      "factsheet",
      "factual",
      "faculty",
      "fade",
      "fading",
      "failing",
      "falcon",
      "fall",
      "false",
      "falsify",
      "fame",
      "familiar",
      "family",
      "famine",
      "famished",
      "fanatic",
      "fancied",
      "fanciness",
      "fancy",
      "fanfare",
      "fang",
      "fanning",
      "fantasize",
      "fantastic",
      "fantasy",
      "fascism",
      "fastball",
      "faster",
      "fasting",
      "fastness",
      "faucet",
      "favorable",
      "favorably",
      "favored",
      "favoring",
      "favorite",
      "fax",
      "feast",
      "federal",
      "fedora",
      "feeble",
      "feed",
      "feel",
      "feisty",
      "feline",
      "felt-tip",
      "feminine",
      "feminism",
      "feminist",
      "feminize",
      "femur",
      "fence",
      "fencing",
      "fender",
      "ferment",
      "fernlike",
      "ferocious",
      "ferocity",
      "ferret",
      "ferris",
      "ferry",
      "fervor",
      "fester",
      "festival",
      "festive",
      "festivity",
      "fetal",
      "fetch",
      "fever",
      "fiber",
      "fiction",
      "fiddle",
      "fiddling",
      "fidelity",
      "fidgeting",
      "fidgety",
      "fifteen",
      "fifth",
      "fiftieth",
      "fifty",
      "figment",
      "figure",
      "figurine",
      "filing",
      "filled",
      "filler",
      "filling",
      "film",
      "filter",
      "filth",
      "filtrate",
      "finale",
      "finalist",
      "finalize",
      "finally",
      "finance",
      "financial",
      "finch",
      "fineness",
      "finer",
      "finicky",
      "finished",
      "finisher",
      "finishing",
      "finite",
      "finless",
      "finlike",
      "fiscally",
      "fit",
      "five",
      "flaccid",
      "flagman",
      "flagpole",
      "flagship",
      "flagstick",
      "flagstone",
      "flail",
      "flakily",
      "flaky",
      "flame",
      "flammable",
      "flanked",
      "flanking",
      "flannels",
      "flap",
      "flaring",
      "flashback",
      "flashbulb",
      "flashcard",
      "flashily",
      "flashing",
      "flashy",
      "flask",
      "flatbed",
      "flatfoot",
      "flatly",
      "flatness",
      "flatten",
      "flattered",
      "flatterer",
      "flattery",
      "flattop",
      "flatware",
      "flatworm",
      "flavored",
      "flavorful",
      "flavoring",
      "flaxseed",
      "fled",
      "fleshed",
      "fleshy",
      "flick",
      "flier",
      "flight",
      "flinch",
      "fling",
      "flint",
      "flip",
      "flirt",
      "float",
      "flock",
      "flogging",
      "flop",
      "floral",
      "florist",
      "floss",
      "flounder",
      "flyable",
      "flyaway",
      "flyer",
      "flying",
      "flyover",
      "flypaper",
      "foam",
      "foe",
      "fog",
      "foil",
      "folic",
      "folk",
      "follicle",
      "follow",
      "fondling",
      "fondly",
      "fondness",
      "fondue",
      "font",
      "food",
      "fool",
      "footage",
      "football",
      "footbath",
      "footboard",
      "footer",
      "footgear",
      "foothill",
      "foothold",
      "footing",
      "footless",
      "footman",
      "footnote",
      "footpad",
      "footpath",
      "footprint",
      "footrest",
      "footsie",
      "footsore",
      "footwear",
      "footwork",
      "fossil",
      "foster",
      "founder",
      "founding",
      "fountain",
      "fox",
      "foyer",
      "fraction",
      "fracture",
      "fragile",
      "fragility",
      "fragment",
      "fragrance",
      "fragrant",
      "frail",
      "frame",
      "framing",
      "frantic",
      "fraternal",
      "frayed",
      "fraying",
      "frays",
      "freckled",
      "freckles",
      "freebase",
      "freebee",
      "freebie",
      "freedom",
      "freefall",
      "freehand",
      "freeing",
      "freeload",
      "freely",
      "freemason",
      "freeness",
      "freestyle",
      "freeware",
      "freeway",
      "freewill",
      "freezable",
      "freezing",
      "freight",
      "french",
      "frenzied",
      "frenzy",
      "frequency",
      "frequent",
      "fresh",
      "fretful",
      "fretted",
      "friction",
      "friday",
      "fridge",
      "fried",
      "friend",
      "frighten",
      "frightful",
      "frigidity",
      "frigidly",
      "frill",
      "fringe",
      "frisbee",
      "frisk",
      "fritter",
      "frivolous",
      "frolic",
      "from",
      "front",
      "frostbite",
      "frosted",
      "frostily",
      "frosting",
      "frostlike",
      "frosty",
      "froth",
      "frown",
      "frozen",
      "fructose",
      "frugality",
      "frugally",
      "fruit",
      "frustrate",
      "frying",
      "gab",
      "gaffe",
      "gag",
      "gainfully",
      "gaining",
      "gains",
      "gala",
      "gallantly",
      "galleria",
      "gallery",
      "galley",
      "gallon",
      "gallows",
      "gallstone",
      "galore",
      "galvanize",
      "gambling",
      "game",
      "gaming",
      "gamma",
      "gander",
      "gangly",
      "gangrene",
      "gangway",
      "gap",
      "garage",
      "garbage",
      "garden",
      "gargle",
      "garland",
      "garlic",
      "garment",
      "garnet",
      "garnish",
      "garter",
      "gas",
      "gatherer",
      "gathering",
      "gating",
      "gauging",
      "gauntlet",
      "gauze",
      "gave",
      "gawk",
      "gazing",
      "gear",
      "gecko",
      "geek",
      "geiger",
      "gem",
      "gender",
      "generic",
      "generous",
      "genetics",
      "genre",
      "gentile",
      "gentleman",
      "gently",
      "gents",
      "geography",
      "geologic",
      "geologist",
      "geology",
      "geometric",
      "geometry",
      "geranium",
      "gerbil",
      "geriatric",
      "germicide",
      "germinate",
      "germless",
      "germproof",
      "gestate",
      "gestation",
      "gesture",
      "getaway",
      "getting",
      "getup",
      "giant",
      "gibberish",
      "giblet",
      "giddily",
      "giddiness",
      "giddy",
      "gift",
      "gigabyte",
      "gigahertz",
      "gigantic",
      "giggle",
      "giggling",
      "giggly",
      "gigolo",
      "gilled",
      "gills",
      "gimmick",
      "girdle",
      "giveaway",
      "given",
      "giver",
      "giving",
      "gizmo",
      "gizzard",
      "glacial",
      "glacier",
      "glade",
      "gladiator",
      "gladly",
      "glamorous",
      "glamour",
      "glance",
      "glancing",
      "glandular",
      "glare",
      "glaring",
      "glass",
      "glaucoma",
      "glazing",
      "gleaming",
      "gleeful",
      "glider",
      "gliding",
      "glimmer",
      "glimpse",
      "glisten",
      "glitch",
      "glitter",
      "glitzy",
      "gloater",
      "gloating",
      "gloomily",
      "gloomy",
      "glorified",
      "glorifier",
      "glorify",
      "glorious",
      "glory",
      "gloss",
      "glove",
      "glowing",
      "glowworm",
      "glucose",
      "glue",
      "gluten",
      "glutinous",
      "glutton",
      "gnarly",
      "gnat",
      "goal",
      "goatskin",
      "goes",
      "goggles",
      "going",
      "goldfish",
      "goldmine",
      "goldsmith",
      "golf",
      "goliath",
      "gonad",
      "gondola",
      "gone",
      "gong",
      "good",
      "gooey",
      "goofball",
      "goofiness",
      "goofy",
      "google",
      "goon",
      "gopher",
      "gore",
      "gorged",
      "gorgeous",
      "gory",
      "gosling",
      "gossip",
      "gothic",
      "gotten",
      "gout",
      "gown",
      "grab",
      "graceful",
      "graceless",
      "gracious",
      "gradation",
      "graded",
      "grader",
      "gradient",
      "grading",
      "gradually",
      "graduate",
      "graffiti",
      "grafted",
      "grafting",
      "grain",
      "granddad",
      "grandkid",
      "grandly",
      "grandma",
      "grandpa",
      "grandson",
      "granite",
      "granny",
      "granola",
      "grant",
      "granular",
      "grape",
      "graph",
      "grapple",
      "grappling",
      "grasp",
      "grass",
      "gratified",
      "gratify",
      "grating",
      "gratitude",
      "gratuity",
      "gravel",
      "graveness",
      "graves",
      "graveyard",
      "gravitate",
      "gravity",
      "gravy",
      "gray",
      "grazing",
      "greasily",
      "greedily",
      "greedless",
      "greedy",
      "green",
      "greeter",
      "greeting",
      "grew",
      "greyhound",
      "grid",
      "grief",
      "grievance",
      "grieving",
      "grievous",
      "grill",
      "grimace",
      "grimacing",
      "grime",
      "griminess",
      "grimy",
      "grinch",
      "grinning",
      "grip",
      "gristle",
      "grit",
      "groggily",
      "groggy",
      "groin",
      "groom",
      "groove",
      "grooving",
      "groovy",
      "grope",
      "ground",
      "grouped",
      "grout",
      "grove",
      "grower",
      "growing",
      "growl",
      "grub",
      "grudge",
      "grudging",
      "grueling",
      "gruffly",
      "grumble",
      "grumbling",
      "grumbly",
      "grumpily",
      "grunge",
      "grunt",
      "guacamole",
      "guidable",
      "guidance",
      "guide",
      "guiding",
      "guileless",
      "guise",
      "gulf",
      "gullible",
      "gully",
      "gulp",
      "gumball",
      "gumdrop",
      "gumminess",
      "gumming",
      "gummy",
      "gurgle",
      "gurgling",
      "guru",
      "gush",
      "gusto",
      "gusty",
      "gutless",
      "guts",
      "gutter",
      "guy",
      "guzzler",
      "gyration",
      "habitable",
      "habitant",
      "habitat",
      "habitual",
      "hacked",
      "hacker",
      "hacking",
      "hacksaw",
      "had",
      "haggler",
      "haiku",
      "half",
      "halogen",
      "halt",
      "halved",
      "halves",
      "hamburger",
      "hamlet",
      "hammock",
      "hamper",
      "hamster",
      "hamstring",
      "handbag",
      "handball",
      "handbook",
      "handbrake",
      "handcart",
      "handclap",
      "handclasp",
      "handcraft",
      "handcuff",
      "handed",
      "handful",
      "handgrip",
      "handgun",
      "handheld",
      "handiness",
      "handiwork",
      "handlebar",
      "handled",
      "handler",
      "handling",
      "handmade",
      "handoff",
      "handpick",
      "handprint",
      "handrail",
      "handsaw",
      "handset",
      "handsfree",
      "handshake",
      "handstand",
      "handwash",
      "handwork",
      "handwoven",
      "handwrite",
      "handyman",
      "hangnail",
      "hangout",
      "hangover",
      "hangup",
      "hankering",
      "hankie",
      "hanky",
      "haphazard",
      "happening",
      "happier",
      "happiest",
      "happily",
      "happiness",
      "happy",
      "harbor",
      "hardcopy",
      "hardcore",
      "hardcover",
      "harddisk",
      "hardened",
      "hardener",
      "hardening",
      "hardhat",
      "hardhead",
      "hardiness",
      "hardly",
      "hardness",
      "hardship",
      "hardware",
      "hardwired",
      "hardwood",
      "hardy",
      "harmful",
      "harmless",
      "harmonica",
      "harmonics",
      "harmonize",
      "harmony",
      "harness",
      "harpist",
      "harsh",
      "harvest",
      "hash",
      "hassle",
      "haste",
      "hastily",
      "hastiness",
      "hasty",
      "hatbox",
      "hatchback",
      "hatchery",
      "hatchet",
      "hatching",
      "hatchling",
      "hate",
      "hatless",
      "hatred",
      "haunt",
      "haven",
      "hazard",
      "hazelnut",
      "hazily",
      "haziness",
      "hazing",
      "hazy",
      "headache",
      "headband",
      "headboard",
      "headcount",
      "headdress",
      "headed",
      "header",
      "headfirst",
      "headgear",
      "heading",
      "headlamp",
      "headless",
      "headlock",
      "headphone",
      "headpiece",
      "headrest",
      "headroom",
      "headscarf",
      "headset",
      "headsman",
      "headstand",
      "headstone",
      "headway",
      "headwear",
      "heap",
      "heat",
      "heave",
      "heavily",
      "heaviness",
      "heaving",
      "hedge",
      "hedging",
      "heftiness",
      "hefty",
      "helium",
      "helmet",
      "helper",
      "helpful",
      "helping",
      "helpless",
      "helpline",
      "hemlock",
      "hemstitch",
      "hence",
      "henchman",
      "henna",
      "herald",
      "herbal",
      "herbicide",
      "herbs",
      "heritage",
      "hermit",
      "heroics",
      "heroism",
      "herring",
      "herself",
      "hertz",
      "hesitancy",
      "hesitant",
      "hesitate",
      "hexagon",
      "hexagram",
      "hubcap",
      "huddle",
      "huddling",
      "huff",
      "hug",
      "hula",
      "hulk",
      "hull",
      "human",
      "humble",
      "humbling",
      "humbly",
      "humid",
      "humiliate",
      "humility",
      "humming",
      "hummus",
      "humongous",
      "humorist",
      "humorless",
      "humorous",
      "humpback",
      "humped",
      "humvee",
      "hunchback",
      "hundredth",
      "hunger",
      "hungrily",
      "hungry",
      "hunk",
      "hunter",
      "hunting",
      "huntress",
      "huntsman",
      "hurdle",
      "hurled",
      "hurler",
      "hurling",
      "hurray",
      "hurricane",
      "hurried",
      "hurry",
      "hurt",
      "husband",
      "hush",
      "husked",
      "huskiness",
      "hut",
      "hybrid",
      "hydrant",
      "hydrated",
      "hydration",
      "hydrogen",
      "hydroxide",
      "hyperlink",
      "hypertext",
      "hyphen",
      "hypnoses",
      "hypnosis",
      "hypnotic",
      "hypnotism",
      "hypnotist",
      "hypnotize",
      "hypocrisy",
      "hypocrite",
      "ibuprofen",
      "ice",
      "iciness",
      "icing",
      "icky",
      "icon",
      "icy",
      "idealism",
      "idealist",
      "idealize",
      "ideally",
      "idealness",
      "identical",
      "identify",
      "identity",
      "ideology",
      "idiocy",
      "idiom",
      "idly",
      "igloo",
      "ignition",
      "ignore",
      "iguana",
      "illicitly",
      "illusion",
      "illusive",
      "image",
      "imaginary",
      "imagines",
      "imaging",
      "imbecile",
      "imitate",
      "imitation",
      "immature",
      "immerse",
      "immersion",
      "imminent",
      "immobile",
      "immodest",
      "immorally",
      "immortal",
      "immovable",
      "immovably",
      "immunity",
      "immunize",
      "impaired",
      "impale",
      "impart",
      "impatient",
      "impeach",
      "impeding",
      "impending",
      "imperfect",
      "imperial",
      "impish",
      "implant",
      "implement",
      "implicate",
      "implicit",
      "implode",
      "implosion",
      "implosive",
      "imply",
      "impolite",
      "important",
      "importer",
      "impose",
      "imposing",
      "impotence",
      "impotency",
      "impotent",
      "impound",
      "imprecise",
      "imprint",
      "imprison",
      "impromptu",
      "improper",
      "improve",
      "improving",
      "improvise",
      "imprudent",
      "impulse",
      "impulsive",
      "impure",
      "impurity",
      "iodine",
      "iodize",
      "ion",
      "ipad",
      "iphone",
      "ipod",
      "irate",
      "irk",
      "iron",
      "irregular",
      "irrigate",
      "irritable",
      "irritably",
      "irritant",
      "irritate",
      "islamic",
      "islamist",
      "isolated",
      "isolating",
      "isolation",
      "isotope",
      "issue",
      "issuing",
      "italicize",
      "italics",
      "item",
      "itinerary",
      "itunes",
      "ivory",
      "ivy",
      "jab",
      "jackal",
      "jacket",
      "jackknife",
      "jackpot",
      "jailbird",
      "jailbreak",
      "jailer",
      "jailhouse",
      "jalapeno",
      "jam",
      "janitor",
      "january",
      "jargon",
      "jarring",
      "jasmine",
      "jaundice",
      "jaunt",
      "java",
      "jawed",
      "jawless",
      "jawline",
      "jaws",
      "jaybird",
      "jaywalker",
      "jazz",
      "jeep",
      "jeeringly",
      "jellied",
      "jelly",
      "jersey",
      "jester",
      "jet",
      "jiffy",
      "jigsaw",
      "jimmy",
      "jingle",
      "jingling",
      "jinx",
      "jitters",
      "jittery",
      "job",
      "jockey",
      "jockstrap",
      "jogger",
      "jogging",
      "john",
      "joining",
      "jokester",
      "jokingly",
      "jolliness",
      "jolly",
      "jolt",
      "jot",
      "jovial",
      "joyfully",
      "joylessly",
      "joyous",
      "joyride",
      "joystick",
      "jubilance",
      "jubilant",
      "judge",
      "judgingly",
      "judicial",
      "judiciary",
      "judo",
      "juggle",
      "juggling",
      "jugular",
      "juice",
      "juiciness",
      "juicy",
      "jujitsu",
      "jukebox",
      "july",
      "jumble",
      "jumbo",
      "jump",
      "junction",
      "juncture",
      "june",
      "junior",
      "juniper",
      "junkie",
      "junkman",
      "junkyard",
      "jurist",
      "juror",
      "jury",
      "justice",
      "justifier",
      "justify",
      "justly",
      "justness",
      "juvenile",
      "kabob",
      "kangaroo",
      "karaoke",
      "karate",
      "karma",
      "kebab",
      "keenly",
      "keenness",
      "keep",
      "keg",
      "kelp",
      "kennel",
      "kept",
      "kerchief",
      "kerosene",
      "kettle",
      "kick",
      "kiln",
      "kilobyte",
      "kilogram",
      "kilometer",
      "kilowatt",
      "kilt",
      "kimono",
      "kindle",
      "kindling",
      "kindly",
      "kindness",
      "kindred",
      "kinetic",
      "kinfolk",
      "king",
      "kinship",
      "kinsman",
      "kinswoman",
      "kissable",
      "kisser",
      "kissing",
      "kitchen",
      "kite",
      "kitten",
      "kitty",
      "kiwi",
      "kleenex",
      "knapsack",
      "knee",
      "knelt",
      "knickers",
      "knoll",
      "koala",
      "kooky",
      "kosher",
      "krypton",
      "kudos",
      "kung",
      "labored",
      "laborer",
      "laboring",
      "laborious",
      "labrador",
      "ladder",
      "ladies",
      "ladle",
      "ladybug",
      "ladylike",
      "lagged",
      "lagging",
      "lagoon",
      "lair",
      "lake",
      "lance",
      "landed",
      "landfall",
      "landfill",
      "landing",
      "landlady",
      "landless",
      "landline",
      "landlord",
      "landmark",
      "landmass",
      "landmine",
      "landowner",
      "landscape",
      "landside",
      "landslide",
      "language",
      "lankiness",
      "lanky",
      "lantern",
      "lapdog",
      "lapel",
      "lapped",
      "lapping",
      "laptop",
      "lard",
      "large",
      "lark",
      "lash",
      "lasso",
      "last",
      "latch",
      "late",
      "lather",
      "latitude",
      "latrine",
      "latter",
      "latticed",
      "launch",
      "launder",
      "laundry",
      "laurel",
      "lavender",
      "lavish",
      "laxative",
      "lazily",
      "laziness",
      "lazy",
      "lecturer",
      "left",
      "legacy",
      "legal",
      "legend",
      "legged",
      "leggings",
      "legible",
      "legibly",
      "legislate",
      "lego",
      "legroom",
      "legume",
      "legwarmer",
      "legwork",
      "lemon",
      "lend",
      "length",
      "lens",
      "lent",
      "leotard",
      "lesser",
      "letdown",
      "lethargic",
      "lethargy",
      "letter",
      "lettuce",
      "level",
      "leverage",
      "levers",
      "levitate",
      "levitator",
      "liability",
      "liable",
      "liberty",
      "librarian",
      "library",
      "licking",
      "licorice",
      "lid",
      "life",
      "lifter",
      "lifting",
      "liftoff",
      "ligament",
      "likely",
      "likeness",
      "likewise",
      "liking",
      "lilac",
      "lilly",
      "lily",
      "limb",
      "limeade",
      "limelight",
      "limes",
      "limit",
      "limping",
      "limpness",
      "line",
      "lingo",
      "linguini",
      "linguist",
      "lining",
      "linked",
      "linoleum",
      "linseed",
      "lint",
      "lion",
      "lip",
      "liquefy",
      "liqueur",
      "liquid",
      "lisp",
      "list",
      "litigate",
      "litigator",
      "litmus",
      "litter",
      "little",
      "livable",
      "lived",
      "lively",
      "liver",
      "livestock",
      "lividly",
      "living",
      "lizard",
      "lubricant",
      "lubricate",
      "lucid",
      "luckily",
      "luckiness",
      "luckless",
      "lucrative",
      "ludicrous",
      "lugged",
      "lukewarm",
      "lullaby",
      "lumber",
      "luminance",
      "luminous",
      "lumpiness",
      "lumping",
      "lumpish",
      "lunacy",
      "lunar",
      "lunchbox",
      "luncheon",
      "lunchroom",
      "lunchtime",
      "lung",
      "lurch",
      "lure",
      "luridness",
      "lurk",
      "lushly",
      "lushness",
      "luster",
      "lustfully",
      "lustily",
      "lustiness",
      "lustrous",
      "lusty",
      "luxurious",
      "luxury",
      "lying",
      "lyrically",
      "lyricism",
      "lyricist",
      "lyrics",
      "macarena",
      "macaroni",
      "macaw",
      "mace",
      "machine",
      "machinist",
      "magazine",
      "magenta",
      "maggot",
      "magical",
      "magician",
      "magma",
      "magnesium",
      "magnetic",
      "magnetism",
      "magnetize",
      "magnifier",
      "magnify",
      "magnitude",
      "magnolia",
      "mahogany",
      "maimed",
      "majestic",
      "majesty",
      "majorette",
      "majority",
      "makeover",
      "maker",
      "makeshift",
      "making",
      "malformed",
      "malt",
      "mama",
      "mammal",
      "mammary",
      "mammogram",
      "manager",
      "managing",
      "manatee",
      "mandarin",
      "mandate",
      "mandatory",
      "mandolin",
      "manger",
      "mangle",
      "mango",
      "mangy",
      "manhandle",
      "manhole",
      "manhood",
      "manhunt",
      "manicotti",
      "manicure",
      "manifesto",
      "manila",
      "mankind",
      "manlike",
      "manliness",
      "manly",
      "manmade",
      "manned",
      "mannish",
      "manor",
      "manpower",
      "mantis",
      "mantra",
      "manual",
      "many",
      "map",
      "marathon",
      "marauding",
      "marbled",
      "marbles",
      "marbling",
      "march",
      "mardi",
      "margarine",
      "margarita",
      "margin",
      "marigold",
      "marina",
      "marine",
      "marital",
      "maritime",
      "marlin",
      "marmalade",
      "maroon",
      "married",
      "marrow",
      "marry",
      "marshland",
      "marshy",
      "marsupial",
      "marvelous",
      "marxism",
      "mascot",
      "masculine",
      "mashed",
      "mashing",
      "massager",
      "masses",
      "massive",
      "mastiff",
      "matador",
      "matchbook",
      "matchbox",
      "matcher",
      "matching",
      "matchless",
      "material",
      "maternal",
      "maternity",
      "math",
      "mating",
      "matriarch",
      "matrimony",
      "matrix",
      "matron",
      "matted",
      "matter",
      "maturely",
      "maturing",
      "maturity",
      "mauve",
      "maverick",
      "maximize",
      "maximum",
      "maybe",
      "mayday",
      "mayflower",
      "moaner",
      "moaning",
      "mobile",
      "mobility",
      "mobilize",
      "mobster",
      "mocha",
      "mocker",
      "mockup",
      "modified",
      "modify",
      "modular",
      "modulator",
      "module",
      "moisten",
      "moistness",
      "moisture",
      "molar",
      "molasses",
      "mold",
      "molecular",
      "molecule",
      "molehill",
      "mollusk",
      "mom",
      "monastery",
      "monday",
      "monetary",
      "monetize",
      "moneybags",
      "moneyless",
      "moneywise",
      "mongoose",
      "mongrel",
      "monitor",
      "monkhood",
      "monogamy",
      "monogram",
      "monologue",
      "monopoly",
      "monorail",
      "monotone",
      "monotype",
      "monoxide",
      "monsieur",
      "monsoon",
      "monstrous",
      "monthly",
      "monument",
      "moocher",
      "moodiness",
      "moody",
      "mooing",
      "moonbeam",
      "mooned",
      "moonlight",
      "moonlike",
      "moonlit",
      "moonrise",
      "moonscape",
      "moonshine",
      "moonstone",
      "moonwalk",
      "mop",
      "morale",
      "morality",
      "morally",
      "morbidity",
      "morbidly",
      "morphine",
      "morphing",
      "morse",
      "mortality",
      "mortally",
      "mortician",
      "mortified",
      "mortify",
      "mortuary",
      "mosaic",
      "mossy",
      "most",
      "mothball",
      "mothproof",
      "motion",
      "motivate",
      "motivator",
      "motive",
      "motocross",
      "motor",
      "motto",
      "mountable",
      "mountain",
      "mounted",
      "mounting",
      "mourner",
      "mournful",
      "mouse",
      "mousiness",
      "moustache",
      "mousy",
      "mouth",
      "movable",
      "move",
      "movie",
      "moving",
      "mower",
      "mowing",
      "much",
      "muck",
      "mud",
      "mug",
      "mulberry",
      "mulch",
      "mule",
      "mulled",
      "mullets",
      "multiple",
      "multiply",
      "multitask",
      "multitude",
      "mumble",
      "mumbling",
      "mumbo",
      "mummified",
      "mummify",
      "mummy",
      "mumps",
      "munchkin",
      "mundane",
      "municipal",
      "muppet",
      "mural",
      "murkiness",
      "murky",
      "murmuring",
      "muscular",
      "museum",
      "mushily",
      "mushiness",
      "mushroom",
      "mushy",
      "music",
      "musket",
      "muskiness",
      "musky",
      "mustang",
      "mustard",
      "muster",
      "mustiness",
      "musty",
      "mutable",
      "mutate",
      "mutation",
      "mute",
      "mutilated",
      "mutilator",
      "mutiny",
      "mutt",
      "mutual",
      "muzzle",
      "myself",
      "myspace",
      "mystified",
      "mystify",
      "myth",
      "nacho",
      "nag",
      "nail",
      "name",
      "naming",
      "nanny",
      "nanometer",
      "nape",
      "napkin",
      "napped",
      "napping",
      "nappy",
      "narrow",
      "nastily",
      "nastiness",
      "national",
      "native",
      "nativity",
      "natural",
      "nature",
      "naturist",
      "nautical",
      "navigate",
      "navigator",
      "navy",
      "nearby",
      "nearest",
      "nearly",
      "nearness",
      "neatly",
      "neatness",
      "nebula",
      "nebulizer",
      "nectar",
      "negate",
      "negation",
      "negative",
      "neglector",
      "negligee",
      "negligent",
      "negotiate",
      "nemeses",
      "nemesis",
      "neon",
      "nephew",
      "nerd",
      "nervous",
      "nervy",
      "nest",
      "net",
      "neurology",
      "neuron",
      "neurosis",
      "neurotic",
      "neuter",
      "neutron",
      "never",
      "next",
      "nibble",
      "nickname",
      "nicotine",
      "niece",
      "nifty",
      "nimble",
      "nimbly",
      "nineteen",
      "ninetieth",
      "ninja",
      "nintendo",
      "ninth",
      "nuclear",
      "nuclei",
      "nucleus",
      "nugget",
      "nullify",
      "number",
      "numbing",
      "numbly",
      "numbness",
      "numeral",
      "numerate",
      "numerator",
      "numeric",
      "numerous",
      "nuptials",
      "nursery",
      "nursing",
      "nurture",
      "nutcase",
      "nutlike",
      "nutmeg",
      "nutrient",
      "nutshell",
      "nuttiness",
      "nutty",
      "nuzzle",
      "nylon",
      "oaf",
      "oak",
      "oasis",
      "oat",
      "obedience",
      "obedient",
      "obituary",
      "object",
      "obligate",
      "obliged",
      "oblivion",
      "oblivious",
      "oblong",
      "obnoxious",
      "oboe",
      "obscure",
      "obscurity",
      "observant",
      "observer",
      "observing",
      "obsessed",
      "obsession",
      "obsessive",
      "obsolete",
      "obstacle",
      "obstinate",
      "obstruct",
      "obtain",
      "obtrusive",
      "obtuse",
      "obvious",
      "occultist",
      "occupancy",
      "occupant",
      "occupier",
      "occupy",
      "ocean",
      "ocelot",
      "octagon",
      "octane",
      "october",
      "octopus",
      "ogle",
      "oil",
      "oink",
      "ointment",
      "okay",
      "old",
      "olive",
      "olympics",
      "omega",
      "omen",
      "ominous",
      "omission",
      "omit",
      "omnivore",
      "onboard",
      "oncoming",
      "ongoing",
      "onion",
      "online",
      "onlooker",
      "only",
      "onscreen",
      "onset",
      "onshore",
      "onslaught",
      "onstage",
      "onto",
      "onward",
      "onyx",
      "oops",
      "ooze",
      "oozy",
      "opacity",
      "opal",
      "open",
      "operable",
      "operate",
      "operating",
      "operation",
      "operative",
      "operator",
      "opium",
      "opossum",
      "opponent",
      "oppose",
      "opposing",
      "opposite",
      "oppressed",
      "oppressor",
      "opt",
      "opulently",
      "osmosis",
      "other",
      "otter",
      "ouch",
      "ought",
      "ounce",
      "outage",
      "outback",
      "outbid",
      "outboard",
      "outbound",
      "outbreak",
      "outburst",
      "outcast",
      "outclass",
      "outcome",
      "outdated",
      "outdoors",
      "outer",
      "outfield",
      "outfit",
      "outflank",
      "outgoing",
      "outgrow",
      "outhouse",
      "outing",
      "outlast",
      "outlet",
      "outline",
      "outlook",
      "outlying",
      "outmatch",
      "outmost",
      "outnumber",
      "outplayed",
      "outpost",
      "outpour",
      "output",
      "outrage",
      "outrank",
      "outreach",
      "outright",
      "outscore",
      "outsell",
      "outshine",
      "outshoot",
      "outsider",
      "outskirts",
      "outsmart",
      "outsource",
      "outspoken",
      "outtakes",
      "outthink",
      "outward",
      "outweigh",
      "outwit",
      "oval",
      "ovary",
      "oven",
      "overact",
      "overall",
      "overarch",
      "overbid",
      "overbill",
      "overbite",
      "overblown",
      "overboard",
      "overbook",
      "overbuilt",
      "overcast",
      "overcoat",
      "overcome",
      "overcook",
      "overcrowd",
      "overdraft",
      "overdrawn",
      "overdress",
      "overdrive",
      "overdue",
      "overeager",
      "overeater",
      "overexert",
      "overfed",
      "overfeed",
      "overfill",
      "overflow",
      "overfull",
      "overgrown",
      "overhand",
      "overhang",
      "overhaul",
      "overhead",
      "overhear",
      "overheat",
      "overhung",
      "overjoyed",
      "overkill",
      "overlabor",
      "overlaid",
      "overlap",
      "overlay",
      "overload",
      "overlook",
      "overlord",
      "overlying",
      "overnight",
      "overpass",
      "overpay",
      "overplant",
      "overplay",
      "overpower",
      "overprice",
      "overrate",
      "overreach",
      "overreact",
      "override",
      "overripe",
      "overrule",
      "overrun",
      "overshoot",
      "overshot",
      "oversight",
      "oversized",
      "oversleep",
      "oversold",
      "overspend",
      "overstate",
      "overstay",
      "overstep",
      "overstock",
      "overstuff",
      "oversweet",
      "overtake",
      "overthrow",
      "overtime",
      "overtly",
      "overtone",
      "overture",
      "overturn",
      "overuse",
      "overvalue",
      "overview",
      "overwrite",
      "owl",
      "oxford",
      "oxidant",
      "oxidation",
      "oxidize",
      "oxidizing",
      "oxygen",
      "oxymoron",
      "oyster",
      "ozone",
      "paced",
      "pacemaker",
      "pacific",
      "pacifier",
      "pacifism",
      "pacifist",
      "pacify",
      "padded",
      "padding",
      "paddle",
      "paddling",
      "padlock",
      "pagan",
      "pager",
      "paging",
      "pajamas",
      "palace",
      "palatable",
      "palm",
      "palpable",
      "palpitate",
      "paltry",
      "pampered",
      "pamperer",
      "pampers",
      "pamphlet",
      "panama",
      "pancake",
      "pancreas",
      "panda",
      "pandemic",
      "pang",
      "panhandle",
      "panic",
      "panning",
      "panorama",
      "panoramic",
      "panther",
      "pantomime",
      "pantry",
      "pants",
      "pantyhose",
      "paparazzi",
      "papaya",
      "paper",
      "paprika",
      "papyrus",
      "parabola",
      "parachute",
      "parade",
      "paradox",
      "paragraph",
      "parakeet",
      "paralegal",
      "paralyses",
      "paralysis",
      "paralyze",
      "paramedic",
      "parameter",
      "paramount",
      "parasail",
      "parasite",
      "parasitic",
      "parcel",
      "parched",
      "parchment",
      "pardon",
      "parish",
      "parka",
      "parking",
      "parkway",
      "parlor",
      "parmesan",
      "parole",
      "parrot",
      "parsley",
      "parsnip",
      "partake",
      "parted",
      "parting",
      "partition",
      "partly",
      "partner",
      "partridge",
      "party",
      "passable",
      "passably",
      "passage",
      "passcode",
      "passenger",
      "passerby",
      "passing",
      "passion",
      "passive",
      "passivism",
      "passover",
      "passport",
      "password",
      "pasta",
      "pasted",
      "pastel",
      "pastime",
      "pastor",
      "pastrami",
      "pasture",
      "pasty",
      "patchwork",
      "patchy",
      "paternal",
      "paternity",
      "path",
      "patience",
      "patient",
      "patio",
      "patriarch",
      "patriot",
      "patrol",
      "patronage",
      "patronize",
      "pauper",
      "pavement",
      "paver",
      "pavestone",
      "pavilion",
      "paving",
      "pawing",
      "payable",
      "payback",
      "paycheck",
      "payday",
      "payee",
      "payer",
      "paying",
      "payment",
      "payphone",
      "payroll",
      "pebble",
      "pebbly",
      "pecan",
      "pectin",
      "peculiar",
      "peddling",
      "pediatric",
      "pedicure",
      "pedigree",
      "pedometer",
      "pegboard",
      "pelican",
      "pellet",
      "pelt",
      "pelvis",
      "penalize",
      "penalty",
      "pencil",
      "pendant",
      "pending",
      "penholder",
      "penknife",
      "pennant",
      "penniless",
      "penny",
      "penpal",
      "pension",
      "pentagon",
      "pentagram",
      "pep",
      "perceive",
      "percent",
      "perch",
      "percolate",
      "perennial",
      "perfected",
      "perfectly",
      "perfume",
      "periscope",
      "perish",
      "perjurer",
      "perjury",
      "perkiness",
      "perky",
      "perm",
      "peroxide",
      "perpetual",
      "perplexed",
      "persecute",
      "persevere",
      "persuaded",
      "persuader",
      "pesky",
      "peso",
      "pessimism",
      "pessimist",
      "pester",
      "pesticide",
      "petal",
      "petite",
      "petition",
      "petri",
      "petroleum",
      "petted",
      "petticoat",
      "pettiness",
      "petty",
      "petunia",
      "phantom",
      "phobia",
      "phoenix",
      "phonebook",
      "phoney",
      "phonics",
      "phoniness",
      "phony",
      "phosphate",
      "photo",
      "phrase",
      "phrasing",
      "placard",
      "placate",
      "placidly",
      "plank",
      "planner",
      "plant",
      "plasma",
      "plaster",
      "plastic",
      "plated",
      "platform",
      "plating",
      "platinum",
      "platonic",
      "platter",
      "platypus",
      "plausible",
      "plausibly",
      "playable",
      "playback",
      "player",
      "playful",
      "playgroup",
      "playhouse",
      "playing",
      "playlist",
      "playmaker",
      "playmate",
      "playoff",
      "playpen",
      "playroom",
      "playset",
      "plaything",
      "playtime",
      "plaza",
      "pleading",
      "pleat",
      "pledge",
      "plentiful",
      "plenty",
      "plethora",
      "plexiglas",
      "pliable",
      "plod",
      "plop",
      "plot",
      "plow",
      "ploy",
      "pluck",
      "plug",
      "plunder",
      "plunging",
      "plural",
      "plus",
      "plutonium",
      "plywood",
      "poach",
      "pod",
      "poem",
      "poet",
      "pogo",
      "pointed",
      "pointer",
      "pointing",
      "pointless",
      "pointy",
      "poise",
      "poison",
      "poker",
      "poking",
      "polar",
      "police",
      "policy",
      "polio",
      "polish",
      "politely",
      "polka",
      "polo",
      "polyester",
      "polygon",
      "polygraph",
      "polymer",
      "poncho",
      "pond",
      "pony",
      "popcorn",
      "pope",
      "poplar",
      "popper",
      "poppy",
      "popsicle",
      "populace",
      "popular",
      "populate",
      "porcupine",
      "pork",
      "porous",
      "porridge",
      "portable",
      "portal",
      "portfolio",
      "porthole",
      "portion",
      "portly",
      "portside",
      "poser",
      "posh",
      "posing",
      "possible",
      "possibly",
      "possum",
      "postage",
      "postal",
      "postbox",
      "postcard",
      "posted",
      "poster",
      "posting",
      "postnasal",
      "posture",
      "postwar",
      "pouch",
      "pounce",
      "pouncing",
      "pound",
      "pouring",
      "pout",
      "powdered",
      "powdering",
      "powdery",
      "power",
      "powwow",
      "pox",
      "praising",
      "prance",
      "prancing",
      "pranker",
      "prankish",
      "prankster",
      "prayer",
      "praying",
      "preacher",
      "preaching",
      "preachy",
      "preamble",
      "precinct",
      "precise",
      "precision",
      "precook",
      "precut",
      "predator",
      "predefine",
      "predict",
      "preface",
      "prefix",
      "preflight",
      "preformed",
      "pregame",
      "pregnancy",
      "pregnant",
      "preheated",
      "prelaunch",
      "prelaw",
      "prelude",
      "premiere",
      "premises",
      "premium",
      "prenatal",
      "preoccupy",
      "preorder",
      "prepaid",
      "prepay",
      "preplan",
      "preppy",
      "preschool",
      "prescribe",
      "preseason",
      "preset",
      "preshow",
      "president",
      "presoak",
      "press",
      "presume",
      "presuming",
      "preteen",
      "pretended",
      "pretender",
      "pretense",
      "pretext",
      "pretty",
      "pretzel",
      "prevail",
      "prevalent",
      "prevent",
      "preview",
      "previous",
      "prewar",
      "prewashed",
      "prideful",
      "pried",
      "primal",
      "primarily",
      "primary",
      "primate",
      "primer",
      "primp",
      "princess",
      "print",
      "prior",
      "prism",
      "prison",
      "prissy",
      "pristine",
      "privacy",
      "private",
      "privatize",
      "prize",
      "proactive",
      "probable",
      "probably",
      "probation",
      "probe",
      "probing",
      "probiotic",
      "problem",
      "procedure",
      "process",
      "proclaim",
      "procreate",
      "procurer",
      "prodigal",
      "prodigy",
      "produce",
      "product",
      "profane",
      "profanity",
      "professed",
      "professor",
      "profile",
      "profound",
      "profusely",
      "progeny",
      "prognosis",
      "program",
      "progress",
      "projector",
      "prologue",
      "prolonged",
      "promenade",
      "prominent",
      "promoter",
      "promotion",
      "prompter",
      "promptly",
      "prone",
      "prong",
      "pronounce",
      "pronto",
      "proofing",
      "proofread",
      "proofs",
      "propeller",
      "properly",
      "property",
      "proponent",
      "proposal",
      "propose",
      "props",
      "prorate",
      "protector",
      "protegee",
      "proton",
      "prototype",
      "protozoan",
      "protract",
      "protrude",
      "proud",
      "provable",
      "proved",
      "proven",
      "provided",
      "provider",
      "providing",
      "province",
      "proving",
      "provoke",
      "provoking",
      "provolone",
      "prowess",
      "prowler",
      "prowling",
      "proximity",
      "proxy",
      "prozac",
      "prude",
      "prudishly",
      "prune",
      "pruning",
      "pry",
      "psychic",
      "public",
      "publisher",
      "pucker",
      "pueblo",
      "pug",
      "pull",
      "pulmonary",
      "pulp",
      "pulsate",
      "pulse",
      "pulverize",
      "puma",
      "pumice",
      "pummel",
      "punch",
      "punctual",
      "punctuate",
      "punctured",
      "pungent",
      "punisher",
      "punk",
      "pupil",
      "puppet",
      "puppy",
      "purchase",
      "pureblood",
      "purebred",
      "purely",
      "pureness",
      "purgatory",
      "purge",
      "purging",
      "purifier",
      "purify",
      "purist",
      "puritan",
      "purity",
      "purple",
      "purplish",
      "purposely",
      "purr",
      "purse",
      "pursuable",
      "pursuant",
      "pursuit",
      "purveyor",
      "pushcart",
      "pushchair",
      "pusher",
      "pushiness",
      "pushing",
      "pushover",
      "pushpin",
      "pushup",
      "pushy",
      "putdown",
      "putt",
      "puzzle",
      "puzzling",
      "pyramid",
      "pyromania",
      "python",
      "quack",
      "quadrant",
      "quail",
      "quaintly",
      "quake",
      "quaking",
      "qualified",
      "qualifier",
      "qualify",
      "quality",
      "qualm",
      "quantum",
      "quarrel",
      "quarry",
      "quartered",
      "quarterly",
      "quarters",
      "quartet",
      "quench",
      "query",
      "quicken",
      "quickly",
      "quickness",
      "quicksand",
      "quickstep",
      "quiet",
      "quill",
      "quilt",
      "quintet",
      "quintuple",
      "quirk",
      "quit",
      "quiver",
      "quizzical",
      "quotable",
      "quotation",
      "quote",
      "rabid",
      "race",
      "racing",
      "racism",
      "rack",
      "racoon",
      "radar",
      "radial",
      "radiance",
      "radiantly",
      "radiated",
      "radiation",
      "radiator",
      "radio",
      "radish",
      "raffle",
      "raft",
      "rage",
      "ragged",
      "raging",
      "ragweed",
      "raider",
      "railcar",
      "railing",
      "railroad",
      "railway",
      "raisin",
      "rake",
      "raking",
      "rally",
      "ramble",
      "rambling",
      "ramp",
      "ramrod",
      "ranch",
      "rancidity",
      "random",
      "ranged",
      "ranger",
      "ranging",
      "ranked",
      "ranking",
      "ransack",
      "ranting",
      "rants",
      "rare",
      "rarity",
      "rascal",
      "rash",
      "rasping",
      "ravage",
      "raven",
      "ravine",
      "raving",
      "ravioli",
      "ravishing",
      "reabsorb",
      "reach",
      "reacquire",
      "reaction",
      "reactive",
      "reactor",
      "reaffirm",
      "ream",
      "reanalyze",
      "reappear",
      "reapply",
      "reappoint",
      "reapprove",
      "rearrange",
      "rearview",
      "reason",
      "reassign",
      "reassure",
      "reattach",
      "reawake",
      "rebalance",
      "rebate",
      "rebel",
      "rebirth",
      "reboot",
      "reborn",
      "rebound",
      "rebuff",
      "rebuild",
      "rebuilt",
      "reburial",
      "rebuttal",
      "recall",
      "recant",
      "recapture",
      "recast",
      "recede",
      "recent",
      "recess",
      "recharger",
      "recipient",
      "recital",
      "recite",
      "reckless",
      "reclaim",
      "recliner",
      "reclining",
      "recluse",
      "reclusive",
      "recognize",
      "recoil",
      "recollect",
      "recolor",
      "reconcile",
      "reconfirm",
      "reconvene",
      "recopy",
      "record",
      "recount",
      "recoup",
      "recovery",
      "recreate",
      "rectal",
      "rectangle",
      "rectified",
      "rectify",
      "recycled",
      "recycler",
      "recycling",
      "reemerge",
      "reenact",
      "reenter",
      "reentry",
      "reexamine",
      "referable",
      "referee",
      "reference",
      "refill",
      "refinance",
      "refined",
      "refinery",
      "refining",
      "refinish",
      "reflected",
      "reflector",
      "reflex",
      "reflux",
      "refocus",
      "refold",
      "reforest",
      "reformat",
      "reformed",
      "reformer",
      "reformist",
      "refract",
      "refrain",
      "refreeze",
      "refresh",
      "refried",
      "refueling",
      "refund",
      "refurbish",
      "refurnish",
      "refusal",
      "refuse",
      "refusing",
      "refutable",
      "refute",
      "regain",
      "regalia",
      "regally",
      "reggae",
      "regime",
      "region",
      "register",
      "registrar",
      "registry",
      "regress",
      "regretful",
      "regroup",
      "regular",
      "regulate",
      "regulator",
      "rehab",
      "reheat",
      "rehire",
      "rehydrate",
      "reimburse",
      "reissue",
      "reiterate",
      "rejoice",
      "rejoicing",
      "rejoin",
      "rekindle",
      "relapse",
      "relapsing",
      "relatable",
      "related",
      "relation",
      "relative",
      "relax",
      "relay",
      "relearn",
      "release",
      "relenting",
      "reliable",
      "reliably",
      "reliance",
      "reliant",
      "relic",
      "relieve",
      "relieving",
      "relight",
      "relish",
      "relive",
      "reload",
      "relocate",
      "relock",
      "reluctant",
      "rely",
      "remake",
      "remark",
      "remarry",
      "rematch",
      "remedial",
      "remedy",
      "remember",
      "reminder",
      "remindful",
      "remission",
      "remix",
      "remnant",
      "remodeler",
      "remold",
      "remorse",
      "remote",
      "removable",
      "removal",
      "removed",
      "remover",
      "removing",
      "rename",
      "renderer",
      "rendering",
      "rendition",
      "renegade",
      "renewable",
      "renewably",
      "renewal",
      "renewed",
      "renounce",
      "renovate",
      "renovator",
      "rentable",
      "rental",
      "rented",
      "renter",
      "reoccupy",
      "reoccur",
      "reopen",
      "reorder",
      "repackage",
      "repacking",
      "repaint",
      "repair",
      "repave",
      "repaying",
      "repayment",
      "repeal",
      "repeated",
      "repeater",
      "repent",
      "rephrase",
      "replace",
      "replay",
      "replica",
      "reply",
      "reporter",
      "repose",
      "repossess",
      "repost",
      "repressed",
      "reprimand",
      "reprint",
      "reprise",
      "reproach",
      "reprocess",
      "reproduce",
      "reprogram",
      "reps",
      "reptile",
      "reptilian",
      "repugnant",
      "repulsion",
      "repulsive",
      "repurpose",
      "reputable",
      "reputably",
      "request",
      "require",
      "requisite",
      "reroute",
      "rerun",
      "resale",
      "resample",
      "rescuer",
      "reseal",
      "research",
      "reselect",
      "reseller",
      "resemble",
      "resend",
      "resent",
      "reset",
      "reshape",
      "reshoot",
      "reshuffle",
      "residence",
      "residency",
      "resident",
      "residual",
      "residue",
      "resigned",
      "resilient",
      "resistant",
      "resisting",
      "resize",
      "resolute",
      "resolved",
      "resonant",
      "resonate",
      "resort",
      "resource",
      "respect",
      "resubmit",
      "result",
      "resume",
      "resupply",
      "resurface",
      "resurrect",
      "retail",
      "retainer",
      "retaining",
      "retake",
      "retaliate",
      "retention",
      "rethink",
      "retinal",
      "retired",
      "retiree",
      "retiring",
      "retold",
      "retool",
      "retorted",
      "retouch",
      "retrace",
      "retract",
      "retrain",
      "retread",
      "retreat",
      "retrial",
      "retrieval",
      "retriever",
      "retry",
      "return",
      "retying",
      "retype",
      "reunion",
      "reunite",
      "reusable",
      "reuse",
      "reveal",
      "reveler",
      "revenge",
      "revenue",
      "reverb",
      "revered",
      "reverence",
      "reverend",
      "reversal",
      "reverse",
      "reversing",
      "reversion",
      "revert",
      "revisable",
      "revise",
      "revision",
      "revisit",
      "revivable",
      "revival",
      "reviver",
      "reviving",
      "revocable",
      "revoke",
      "revolt",
      "revolver",
      "revolving",
      "reward",
      "rewash",
      "rewind",
      "rewire",
      "reword",
      "rework",
      "rewrap",
      "rewrite",
      "rhyme",
      "ribbon",
      "ribcage",
      "rice",
      "riches",
      "richly",
      "richness",
      "rickety",
      "ricotta",
      "riddance",
      "ridden",
      "ride",
      "riding",
      "rifling",
      "rift",
      "rigging",
      "rigid",
      "rigor",
      "rimless",
      "rimmed",
      "rind",
      "rink",
      "rinse",
      "rinsing",
      "riot",
      "ripcord",
      "ripeness",
      "ripening",
      "ripping",
      "ripple",
      "rippling",
      "riptide",
      "rise",
      "rising",
      "risk",
      "risotto",
      "ritalin",
      "ritzy",
      "rival",
      "riverbank",
      "riverbed",
      "riverboat",
      "riverside",
      "riveter",
      "riveting",
      "roamer",
      "roaming",
      "roast",
      "robbing",
      "robe",
      "robin",
      "robotics",
      "robust",
      "rockband",
      "rocker",
      "rocket",
      "rockfish",
      "rockiness",
      "rocking",
      "rocklike",
      "rockslide",
      "rockstar",
      "rocky",
      "rogue",
      "roman",
      "romp",
      "rope",
      "roping",
      "roster",
      "rosy",
      "rotten",
      "rotting",
      "rotunda",
      "roulette",
      "rounding",
      "roundish",
      "roundness",
      "roundup",
      "roundworm",
      "routine",
      "routing",
      "rover",
      "roving",
      "royal",
      "rubbed",
      "rubber",
      "rubbing",
      "rubble",
      "rubdown",
      "ruby",
      "ruckus",
      "rudder",
      "rug",
      "ruined",
      "rule",
      "rumble",
      "rumbling",
      "rummage",
      "rumor",
      "runaround",
      "rundown",
      "runner",
      "running",
      "runny",
      "runt",
      "runway",
      "rupture",
      "rural",
      "ruse",
      "rush",
      "rust",
      "rut",
      "sabbath",
      "sabotage",
      "sacrament",
      "sacred",
      "sacrifice",
      "sadden",
      "saddlebag",
      "saddled",
      "saddling",
      "sadly",
      "sadness",
      "safari",
      "safeguard",
      "safehouse",
      "safely",
      "safeness",
      "saffron",
      "saga",
      "sage",
      "sagging",
      "saggy",
      "said",
      "saint",
      "sake",
      "salad",
      "salami",
      "salaried",
      "salary",
      "saline",
      "salon",
      "saloon",
      "salsa",
      "salt",
      "salutary",
      "salute",
      "salvage",
      "salvaging",
      "salvation",
      "same",
      "sample",
      "sampling",
      "sanction",
      "sanctity",
      "sanctuary",
      "sandal",
      "sandbag",
      "sandbank",
      "sandbar",
      "sandblast",
      "sandbox",
      "sanded",
      "sandfish",
      "sanding",
      "sandlot",
      "sandpaper",
      "sandpit",
      "sandstone",
      "sandstorm",
      "sandworm",
      "sandy",
      "sanitary",
      "sanitizer",
      "sank",
      "santa",
      "sapling",
      "sappiness",
      "sappy",
      "sarcasm",
      "sarcastic",
      "sardine",
      "sash",
      "sasquatch",
      "sassy",
      "satchel",
      "satiable",
      "satin",
      "satirical",
      "satisfied",
      "satisfy",
      "saturate",
      "saturday",
      "sauciness",
      "saucy",
      "sauna",
      "savage",
      "savanna",
      "saved",
      "savings",
      "savior",
      "savor",
      "saxophone",
      "say",
      "scabbed",
      "scabby",
      "scalded",
      "scalding",
      "scale",
      "scaling",
      "scallion",
      "scallop",
      "scalping",
      "scam",
      "scandal",
      "scanner",
      "scanning",
      "scant",
      "scapegoat",
      "scarce",
      "scarcity",
      "scarecrow",
      "scared",
      "scarf",
      "scarily",
      "scariness",
      "scarring",
      "scary",
      "scavenger",
      "scenic",
      "schedule",
      "schematic",
      "scheme",
      "scheming",
      "schilling",
      "schnapps",
      "scholar",
      "science",
      "scientist",
      "scion",
      "scoff",
      "scolding",
      "scone",
      "scoop",
      "scooter",
      "scope",
      "scorch",
      "scorebook",
      "scorecard",
      "scored",
      "scoreless",
      "scorer",
      "scoring",
      "scorn",
      "scorpion",
      "scotch",
      "scoundrel",
      "scoured",
      "scouring",
      "scouting",
      "scouts",
      "scowling",
      "scrabble",
      "scraggly",
      "scrambled",
      "scrambler",
      "scrap",
      "scratch",
      "scrawny",
      "screen",
      "scribble",
      "scribe",
      "scribing",
      "scrimmage",
      "script",
      "scroll",
      "scrooge",
      "scrounger",
      "scrubbed",
      "scrubber",
      "scruffy",
      "scrunch",
      "scrutiny",
      "scuba",
      "scuff",
      "sculptor",
      "sculpture",
      "scurvy",
      "scuttle",
      "secluded",
      "secluding",
      "seclusion",
      "second",
      "secrecy",
      "secret",
      "sectional",
      "sector",
      "secular",
      "securely",
      "security",
      "sedan",
      "sedate",
      "sedation",
      "sedative",
      "sediment",
      "seduce",
      "seducing",
      "segment",
      "seismic",
      "seizing",
      "seldom",
      "selected",
      "selection",
      "selective",
      "selector",
      "self",
      "seltzer",
      "semantic",
      "semester",
      "semicolon",
      "semifinal",
      "seminar",
      "semisoft",
      "semisweet",
      "senate",
      "senator",
      "send",
      "senior",
      "senorita",
      "sensation",
      "sensitive",
      "sensitize",
      "sensually",
      "sensuous",
      "sepia",
      "september",
      "septic",
      "septum",
      "sequel",
      "sequence",
      "sequester",
      "series",
      "sermon",
      "serotonin",
      "serpent",
      "serrated",
      "serve",
      "service",
      "serving",
      "sesame",
      "sessions",
      "setback",
      "setting",
      "settle",
      "settling",
      "setup",
      "sevenfold",
      "seventeen",
      "seventh",
      "seventy",
      "severity",
      "shabby",
      "shack",
      "shaded",
      "shadily",
      "shadiness",
      "shading",
      "shadow",
      "shady",
      "shaft",
      "shakable",
      "shakily",
      "shakiness",
      "shaking",
      "shaky",
      "shale",
      "shallot",
      "shallow",
      "shame",
      "shampoo",
      "shamrock",
      "shank",
      "shanty",
      "shape",
      "shaping",
      "share",
      "sharpener",
      "sharper",
      "sharpie",
      "sharply",
      "sharpness",
      "shawl",
      "sheath",
      "shed",
      "sheep",
      "sheet",
      "shelf",
      "shell",
      "shelter",
      "shelve",
      "shelving",
      "sherry",
      "shield",
      "shifter",
      "shifting",
      "shiftless",
      "shifty",
      "shimmer",
      "shimmy",
      "shindig",
      "shine",
      "shingle",
      "shininess",
      "shining",
      "shiny",
      "ship",
      "shirt",
      "shivering",
      "shock",
      "shone",
      "shoplift",
      "shopper",
      "shopping",
      "shoptalk",
      "shore",
      "shortage",
      "shortcake",
      "shortcut",
      "shorten",
      "shorter",
      "shorthand",
      "shortlist",
      "shortly",
      "shortness",
      "shorts",
      "shortwave",
      "shorty",
      "shout",
      "shove",
      "showbiz",
      "showcase",
      "showdown",
      "shower",
      "showgirl",
      "showing",
      "showman",
      "shown",
      "showoff",
      "showpiece",
      "showplace",
      "showroom",
      "showy",
      "shrank",
      "shrapnel",
      "shredder",
      "shredding",
      "shrewdly",
      "shriek",
      "shrill",
      "shrimp",
      "shrine",
      "shrink",
      "shrivel",
      "shrouded",
      "shrubbery",
      "shrubs",
      "shrug",
      "shrunk",
      "shucking",
      "shudder",
      "shuffle",
      "shuffling",
      "shun",
      "shush",
      "shut",
      "shy",
      "siamese",
      "siberian",
      "sibling",
      "siding",
      "sierra",
      "siesta",
      "sift",
      "sighing",
      "silenced",
      "silencer",
      "silent",
      "silica",
      "silicon",
      "silk",
      "silliness",
      "silly",
      "silo",
      "silt",
      "silver",
      "similarly",
      "simile",
      "simmering",
      "simple",
      "simplify",
      "simply",
      "sincere",
      "sincerity",
      "singer",
      "singing",
      "single",
      "singular",
      "sinister",
      "sinless",
      "sinner",
      "sinuous",
      "sip",
      "siren",
      "sister",
      "sitcom",
      "sitter",
      "sitting",
      "situated",
      "situation",
      "sixfold",
      "sixteen",
      "sixth",
      "sixties",
      "sixtieth",
      "sixtyfold",
      "sizable",
      "sizably",
      "size",
      "sizing",
      "sizzle",
      "sizzling",
      "skater",
      "skating",
      "skedaddle",
      "skeletal",
      "skeleton",
      "skeptic",
      "sketch",
      "skewed",
      "skewer",
      "skid",
      "skied",
      "skier",
      "skies",
      "skiing",
      "skilled",
      "skillet",
      "skillful",
      "skimmed",
      "skimmer",
      "skimming",
      "skimpily",
      "skincare",
      "skinhead",
      "skinless",
      "skinning",
      "skinny",
      "skintight",
      "skipper",
      "skipping",
      "skirmish",
      "skirt",
      "skittle",
      "skydiver",
      "skylight",
      "skyline",
      "skype",
      "skyrocket",
      "skyward",
      "slab",
      "slacked",
      "slacker",
      "slacking",
      "slackness",
      "slacks",
      "slain",
      "slam",
      "slander",
      "slang",
      "slapping",
      "slapstick",
      "slashed",
      "slashing",
      "slate",
      "slather",
      "slaw",
      "sled",
      "sleek",
      "sleep",
      "sleet",
      "sleeve",
      "slept",
      "sliceable",
      "sliced",
      "slicer",
      "slicing",
      "slick",
      "slider",
      "slideshow",
      "sliding",
      "slighted",
      "slighting",
      "slightly",
      "slimness",
      "slimy",
      "slinging",
      "slingshot",
      "slinky",
      "slip",
      "slit",
      "sliver",
      "slobbery",
      "slogan",
      "sloped",
      "sloping",
      "sloppily",
      "sloppy",
      "slot",
      "slouching",
      "slouchy",
      "sludge",
      "slug",
      "slum",
      "slurp",
      "slush",
      "sly",
      "small",
      "smartly",
      "smartness",
      "smasher",
      "smashing",
      "smashup",
      "smell",
      "smelting",
      "smile",
      "smilingly",
      "smirk",
      "smite",
      "smith",
      "smitten",
      "smock",
      "smog",
      "smoked",
      "smokeless",
      "smokiness",
      "smoking",
      "smoky",
      "smolder",
      "smooth",
      "smother",
      "smudge",
      "smudgy",
      "smuggler",
      "smuggling",
      "smugly",
      "smugness",
      "snack",
      "snagged",
      "snaking",
      "snap",
      "snare",
      "snarl",
      "snazzy",
      "sneak",
      "sneer",
      "sneeze",
      "sneezing",
      "snide",
      "sniff",
      "snippet",
      "snipping",
      "snitch",
      "snooper",
      "snooze",
      "snore",
      "snoring",
      "snorkel",
      "snort",
      "snout",
      "snowbird",
      "snowboard",
      "snowbound",
      "snowcap",
      "snowdrift",
      "snowdrop",
      "snowfall",
      "snowfield",
      "snowflake",
      "snowiness",
      "snowless",
      "snowman",
      "snowplow",
      "snowshoe",
      "snowstorm",
      "snowsuit",
      "snowy",
      "snub",
      "snuff",
      "snuggle",
      "snugly",
      "snugness",
      "speak",
      "spearfish",
      "spearhead",
      "spearman",
      "spearmint",
      "species",
      "specimen",
      "specked",
      "speckled",
      "specks",
      "spectacle",
      "spectator",
      "spectrum",
      "speculate",
      "speech",
      "speed",
      "spellbind",
      "speller",
      "spelling",
      "spendable",
      "spender",
      "spending",
      "spent",
      "spew",
      "sphere",
      "spherical",
      "sphinx",
      "spider",
      "spied",
      "spiffy",
      "spill",
      "spilt",
      "spinach",
      "spinal",
      "spindle",
      "spinner",
      "spinning",
      "spinout",
      "spinster",
      "spiny",
      "spiral",
      "spirited",
      "spiritism",
      "spirits",
      "spiritual",
      "splashed",
      "splashing",
      "splashy",
      "splatter",
      "spleen",
      "splendid",
      "splendor",
      "splice",
      "splicing",
      "splinter",
      "splotchy",
      "splurge",
      "spoilage",
      "spoiled",
      "spoiler",
      "spoiling",
      "spoils",
      "spoken",
      "spokesman",
      "sponge",
      "spongy",
      "sponsor",
      "spoof",
      "spookily",
      "spooky",
      "spool",
      "spoon",
      "spore",
      "sporting",
      "sports",
      "sporty",
      "spotless",
      "spotlight",
      "spotted",
      "spotter",
      "spotting",
      "spotty",
      "spousal",
      "spouse",
      "spout",
      "sprain",
      "sprang",
      "sprawl",
      "spray",
      "spree",
      "sprig",
      "spring",
      "sprinkled",
      "sprinkler",
      "sprint",
      "sprite",
      "sprout",
      "spruce",
      "sprung",
      "spry",
      "spud",
      "spur",
      "sputter",
      "spyglass",
      "squabble",
      "squad",
      "squall",
      "squander",
      "squash",
      "squatted",
      "squatter",
      "squatting",
      "squeak",
      "squealer",
      "squealing",
      "squeamish",
      "squeegee",
      "squeeze",
      "squeezing",
      "squid",
      "squiggle",
      "squiggly",
      "squint",
      "squire",
      "squirt",
      "squishier",
      "squishy",
      "stability",
      "stabilize",
      "stable",
      "stack",
      "stadium",
      "staff",
      "stage",
      "staging",
      "stagnant",
      "stagnate",
      "stainable",
      "stained",
      "staining",
      "stainless",
      "stalemate",
      "staleness",
      "stalling",
      "stallion",
      "stamina",
      "stammer",
      "stamp",
      "stand",
      "stank",
      "staple",
      "stapling",
      "starboard",
      "starch",
      "stardom",
      "stardust",
      "starfish",
      "stargazer",
      "staring",
      "stark",
      "starless",
      "starlet",
      "starlight",
      "starlit",
      "starring",
      "starry",
      "starship",
      "starter",
      "starting",
      "startle",
      "startling",
      "startup",
      "starved",
      "starving",
      "stash",
      "state",
      "static",
      "statistic",
      "statue",
      "stature",
      "status",
      "statute",
      "statutory",
      "staunch",
      "stays",
      "steadfast",
      "steadier",
      "steadily",
      "steadying",
      "steam",
      "steed",
      "steep",
      "steerable",
      "steering",
      "steersman",
      "stegosaur",
      "stellar",
      "stem",
      "stench",
      "stencil",
      "step",
      "stereo",
      "sterile",
      "sterility",
      "sterilize",
      "sterling",
      "sternness",
      "sternum",
      "stew",
      "stick",
      "stiffen",
      "stiffly",
      "stiffness",
      "stifle",
      "stifling",
      "stillness",
      "stilt",
      "stimulant",
      "stimulate",
      "stimuli",
      "stimulus",
      "stinger",
      "stingily",
      "stinging",
      "stingray",
      "stingy",
      "stinking",
      "stinky",
      "stipend",
      "stipulate",
      "stir",
      "stitch",
      "stock",
      "stoic",
      "stoke",
      "stole",
      "stomp",
      "stonewall",
      "stoneware",
      "stonework",
      "stoning",
      "stony",
      "stood",
      "stooge",
      "stool",
      "stoop",
      "stoplight",
      "stoppable",
      "stoppage",
      "stopped",
      "stopper",
      "stopping",
      "stopwatch",
      "storable",
      "storage",
      "storeroom",
      "storewide",
      "storm",
      "stout",
      "stove",
      "stowaway",
      "stowing",
      "straddle",
      "straggler",
      "strained",
      "strainer",
      "straining",
      "strangely",
      "stranger",
      "strangle",
      "strategic",
      "strategy",
      "stratus",
      "straw",
      "stray",
      "streak",
      "stream",
      "street",
      "strength",
      "strenuous",
      "strep",
      "stress",
      "stretch",
      "strewn",
      "stricken",
      "strict",
      "stride",
      "strife",
      "strike",
      "striking",
      "strive",
      "striving",
      "strobe",
      "strode",
      "stroller",
      "strongbox",
      "strongly",
      "strongman",
      "struck",
      "structure",
      "strudel",
      "struggle",
      "strum",
      "strung",
      "strut",
      "stubbed",
      "stubble",
      "stubbly",
      "stubborn",
      "stucco",
      "stuck",
      "student",
      "studied",
      "studio",
      "study",
      "stuffed",
      "stuffing",
      "stuffy",
      "stumble",
      "stumbling",
      "stump",
      "stung",
      "stunned",
      "stunner",
      "stunning",
      "stunt",
      "stupor",
      "sturdily",
      "sturdy",
      "styling",
      "stylishly",
      "stylist",
      "stylized",
      "stylus",
      "suave",
      "subarctic",
      "subatomic",
      "subdivide",
      "subdued",
      "subduing",
      "subfloor",
      "subgroup",
      "subheader",
      "subject",
      "sublease",
      "sublet",
      "sublevel",
      "sublime",
      "submarine",
      "submerge",
      "submersed",
      "submitter",
      "subpanel",
      "subpar",
      "subplot",
      "subprime",
      "subscribe",
      "subscript",
      "subsector",
      "subside",
      "subsiding",
      "subsidize",
      "subsidy",
      "subsoil",
      "subsonic",
      "substance",
      "subsystem",
      "subtext",
      "subtitle",
      "subtly",
      "subtotal",
      "subtract",
      "subtype",
      "suburb",
      "subway",
      "subwoofer",
      "subzero",
      "succulent",
      "such",
      "suction",
      "sudden",
      "sudoku",
      "suds",
      "sufferer",
      "suffering",
      "suffice",
      "suffix",
      "suffocate",
      "suffrage",
      "sugar",
      "suggest",
      "suing",
      "suitable",
      "suitably",
      "suitcase",
      "suitor",
      "sulfate",
      "sulfide",
      "sulfite",
      "sulfur",
      "sulk",
      "sullen",
      "sulphate",
      "sulphuric",
      "sultry",
      "superbowl",
      "superglue",
      "superhero",
      "superior",
      "superjet",
      "superman",
      "supermom",
      "supernova",
      "supervise",
      "supper",
      "supplier",
      "supply",
      "support",
      "supremacy",
      "supreme",
      "surcharge",
      "surely",
      "sureness",
      "surface",
      "surfacing",
      "surfboard",
      "surfer",
      "surgery",
      "surgical",
      "surging",
      "surname",
      "surpass",
      "surplus",
      "surprise",
      "surreal",
      "surrender",
      "surrogate",
      "surround",
      "survey",
      "survival",
      "survive",
      "surviving",
      "survivor",
      "sushi",
      "suspect",
      "suspend",
      "suspense",
      "sustained",
      "sustainer",
      "swab",
      "swaddling",
      "swagger",
      "swampland",
      "swan",
      "swapping",
      "swarm",
      "sway",
      "swear",
      "sweat",
      "sweep",
      "swell",
      "swept",
      "swerve",
      "swifter",
      "swiftly",
      "swiftness",
      "swimmable",
      "swimmer",
      "swimming",
      "swimsuit",
      "swimwear",
      "swinger",
      "swinging",
      "swipe",
      "swirl",
      "switch",
      "swivel",
      "swizzle",
      "swooned",
      "swoop",
      "swoosh",
      "swore",
      "sworn",
      "swung",
      "sycamore",
      "sympathy",
      "symphonic",
      "symphony",
      "symptom",
      "synapse",
      "syndrome",
      "synergy",
      "synopses",
      "synopsis",
      "synthesis",
      "synthetic",
      "syrup",
      "system",
      "t-shirt",
      "tabasco",
      "tabby",
      "tableful",
      "tables",
      "tablet",
      "tableware",
      "tabloid",
      "tackiness",
      "tacking",
      "tackle",
      "tackling",
      "tacky",
      "taco",
      "tactful",
      "tactical",
      "tactics",
      "tactile",
      "tactless",
      "tadpole",
      "taekwondo",
      "tag",
      "tainted",
      "take",
      "taking",
      "talcum",
      "talisman",
      "tall",
      "talon",
      "tamale",
      "tameness",
      "tamer",
      "tamper",
      "tank",
      "tanned",
      "tannery",
      "tanning",
      "tantrum",
      "tapeless",
      "tapered",
      "tapering",
      "tapestry",
      "tapioca",
      "tapping",
      "taps",
      "tarantula",
      "target",
      "tarmac",
      "tarnish",
      "tarot",
      "tartar",
      "tartly",
      "tartness",
      "task",
      "tassel",
      "taste",
      "tastiness",
      "tasting",
      "tasty",
      "tattered",
      "tattle",
      "tattling",
      "tattoo",
      "taunt",
      "tavern",
      "thank",
      "that",
      "thaw",
      "theater",
      "theatrics",
      "thee",
      "theft",
      "theme",
      "theology",
      "theorize",
      "thermal",
      "thermos",
      "thesaurus",
      "these",
      "thesis",
      "thespian",
      "thicken",
      "thicket",
      "thickness",
      "thieving",
      "thievish",
      "thigh",
      "thimble",
      "thing",
      "think",
      "thinly",
      "thinner",
      "thinness",
      "thinning",
      "thirstily",
      "thirsting",
      "thirsty",
      "thirteen",
      "thirty",
      "thong",
      "thorn",
      "those",
      "thousand",
      "thrash",
      "thread",
      "threaten",
      "threefold",
      "thrift",
      "thrill",
      "thrive",
      "thriving",
      "throat",
      "throbbing",
      "throng",
      "throttle",
      "throwaway",
      "throwback",
      "thrower",
      "throwing",
      "thud",
      "thumb",
      "thumping",
      "thursday",
      "thus",
      "thwarting",
      "thyself",
      "tiara",
      "tibia",
      "tidal",
      "tidbit",
      "tidiness",
      "tidings",
      "tidy",
      "tiger",
      "tighten",
      "tightly",
      "tightness",
      "tightrope",
      "tightwad",
      "tigress",
      "tile",
      "tiling",
      "till",
      "tilt",
      "timid",
      "timing",
      "timothy",
      "tinderbox",
      "tinfoil",
      "tingle",
      "tingling",
      "tingly",
      "tinker",
      "tinkling",
      "tinsel",
      "tinsmith",
      "tint",
      "tinwork",
      "tiny",
      "tipoff",
      "tipped",
      "tipper",
      "tipping",
      "tiptoeing",
      "tiptop",
      "tiring",
      "tissue",
      "trace",
      "tracing",
      "track",
      "traction",
      "tractor",
      "trade",
      "trading",
      "tradition",
      "traffic",
      "tragedy",
      "trailing",
      "trailside",
      "train",
      "traitor",
      "trance",
      "tranquil",
      "transfer",
      "transform",
      "translate",
      "transpire",
      "transport",
      "transpose",
      "trapdoor",
      "trapeze",
      "trapezoid",
      "trapped",
      "trapper",
      "trapping",
      "traps",
      "trash",
      "travel",
      "traverse",
      "travesty",
      "tray",
      "treachery",
      "treading",
      "treadmill",
      "treason",
      "treat",
      "treble",
      "tree",
      "trekker",
      "tremble",
      "trembling",
      "tremor",
      "trench",
      "trend",
      "trespass",
      "triage",
      "trial",
      "triangle",
      "tribesman",
      "tribunal",
      "tribune",
      "tributary",
      "tribute",
      "triceps",
      "trickery",
      "trickily",
      "tricking",
      "trickle",
      "trickster",
      "tricky",
      "tricolor",
      "tricycle",
      "trident",
      "tried",
      "trifle",
      "trifocals",
      "trillion",
      "trilogy",
      "trimester",
      "trimmer",
      "trimming",
      "trimness",
      "trinity",
      "trio",
      "tripod",
      "tripping",
      "triumph",
      "trivial",
      "trodden",
      "trolling",
      "trombone",
      "trophy",
      "tropical",
      "tropics",
      "trouble",
      "troubling",
      "trough",
      "trousers",
      "trout",
      "trowel",
      "truce",
      "truck",
      "truffle",
      "trump",
      "trunks",
      "trustable",
      "trustee",
      "trustful",
      "trusting",
      "trustless",
      "truth",
      "try",
      "tubby",
      "tubeless",
      "tubular",
      "tucking",
      "tuesday",
      "tug",
      "tuition",
      "tulip",
      "tumble",
      "tumbling",
      "tummy",
      "turban",
      "turbine",
      "turbofan",
      "turbojet",
      "turbulent",
      "turf",
      "turkey",
      "turmoil",
      "turret",
      "turtle",
      "tusk",
      "tutor",
      "tutu",
      "tux",
      "tweak",
      "tweed",
      "tweet",
      "tweezers",
      "twelve",
      "twentieth",
      "twenty",
      "twerp",
      "twice",
      "twiddle",
      "twiddling",
      "twig",
      "twilight",
      "twine",
      "twins",
      "twirl",
      "twistable",
      "twisted",
      "twister",
      "twisting",
      "twisty",
      "twitch",
      "twitter",
      "tycoon",
      "tying",
      "tyke",
      "udder",
      "ultimate",
      "ultimatum",
      "ultra",
      "umbilical",
      "umbrella",
      "umpire",
      "unabashed",
      "unable",
      "unadorned",
      "unadvised",
      "unafraid",
      "unaired",
      "unaligned",
      "unaltered",
      "unarmored",
      "unashamed",
      "unaudited",
      "unawake",
      "unaware",
      "unbaked",
      "unbalance",
      "unbeaten",
      "unbend",
      "unbent",
      "unbiased",
      "unbitten",
      "unblended",
      "unblessed",
      "unblock",
      "unbolted",
      "unbounded",
      "unboxed",
      "unbraided",
      "unbridle",
      "unbroken",
      "unbuckled",
      "unbundle",
      "unburned",
      "unbutton",
      "uncanny",
      "uncapped",
      "uncaring",
      "uncertain",
      "unchain",
      "unchanged",
      "uncharted",
      "uncheck",
      "uncivil",
      "unclad",
      "unclaimed",
      "unclamped",
      "unclasp",
      "uncle",
      "unclip",
      "uncloak",
      "unclog",
      "unclothed",
      "uncoated",
      "uncoiled",
      "uncolored",
      "uncombed",
      "uncommon",
      "uncooked",
      "uncork",
      "uncorrupt",
      "uncounted",
      "uncouple",
      "uncouth",
      "uncover",
      "uncross",
      "uncrown",
      "uncrushed",
      "uncured",
      "uncurious",
      "uncurled",
      "uncut",
      "undamaged",
      "undated",
      "undaunted",
      "undead",
      "undecided",
      "undefined",
      "underage",
      "underarm",
      "undercoat",
      "undercook",
      "undercut",
      "underdog",
      "underdone",
      "underfed",
      "underfeed",
      "underfoot",
      "undergo",
      "undergrad",
      "underhand",
      "underline",
      "underling",
      "undermine",
      "undermost",
      "underpaid",
      "underpass",
      "underpay",
      "underrate",
      "undertake",
      "undertone",
      "undertook",
      "undertow",
      "underuse",
      "underwear",
      "underwent",
      "underwire",
      "undesired",
      "undiluted",
      "undivided",
      "undocked",
      "undoing",
      "undone",
      "undrafted",
      "undress",
      "undrilled",
      "undusted",
      "undying",
      "unearned",
      "unearth",
      "unease",
      "uneasily",
      "uneasy",
      "uneatable",
      "uneaten",
      "unedited",
      "unelected",
      "unending",
      "unengaged",
      "unenvied",
      "unequal",
      "unethical",
      "uneven",
      "unexpired",
      "unexposed",
      "unfailing",
      "unfair",
      "unfasten",
      "unfazed",
      "unfeeling",
      "unfiled",
      "unfilled",
      "unfitted",
      "unfitting",
      "unfixable",
      "unfixed",
      "unflawed",
      "unfocused",
      "unfold",
      "unfounded",
      "unframed",
      "unfreeze",
      "unfrosted",
      "unfrozen",
      "unfunded",
      "unglazed",
      "ungloved",
      "unglue",
      "ungodly",
      "ungraded",
      "ungreased",
      "unguarded",
      "unguided",
      "unhappily",
      "unhappy",
      "unharmed",
      "unhealthy",
      "unheard",
      "unhearing",
      "unheated",
      "unhelpful",
      "unhidden",
      "unhinge",
      "unhitched",
      "unholy",
      "unhook",
      "unicorn",
      "unicycle",
      "unified",
      "unifier",
      "uniformed",
      "uniformly",
      "unify",
      "unimpeded",
      "uninjured",
      "uninstall",
      "uninsured",
      "uninvited",
      "union",
      "uniquely",
      "unisexual",
      "unison",
      "unissued",
      "unit",
      "universal",
      "universe",
      "unjustly",
      "unkempt",
      "unkind",
      "unknotted",
      "unknowing",
      "unknown",
      "unlaced",
      "unlatch",
      "unlawful",
      "unleaded",
      "unlearned",
      "unleash",
      "unless",
      "unleveled",
      "unlighted",
      "unlikable",
      "unlimited",
      "unlined",
      "unlinked",
      "unlisted",
      "unlit",
      "unlivable",
      "unloaded",
      "unloader",
      "unlocked",
      "unlocking",
      "unlovable",
      "unloved",
      "unlovely",
      "unloving",
      "unluckily",
      "unlucky",
      "unmade",
      "unmanaged",
      "unmanned",
      "unmapped",
      "unmarked",
      "unmasked",
      "unmasking",
      "unmatched",
      "unmindful",
      "unmixable",
      "unmixed",
      "unmolded",
      "unmoral",
      "unmovable",
      "unmoved",
      "unmoving",
      "unnamable",
      "unnamed",
      "unnatural",
      "unneeded",
      "unnerve",
      "unnerving",
      "unnoticed",
      "unopened",
      "unopposed",
      "unpack",
      "unpadded",
      "unpaid",
      "unpainted",
      "unpaired",
      "unpaved",
      "unpeeled",
      "unpicked",
      "unpiloted",
      "unpinned",
      "unplanned",
      "unplanted",
      "unpleased",
      "unpledged",
      "unplowed",
      "unplug",
      "unpopular",
      "unproven",
      "unquote",
      "unranked",
      "unrated",
      "unraveled",
      "unreached",
      "unread",
      "unreal",
      "unreeling",
      "unrefined",
      "unrelated",
      "unrented",
      "unrest",
      "unretired",
      "unrevised",
      "unrigged",
      "unripe",
      "unrivaled",
      "unroasted",
      "unrobed",
      "unroll",
      "unruffled",
      "unruly",
      "unrushed",
      "unsaddle",
      "unsafe",
      "unsaid",
      "unsalted",
      "unsaved",
      "unsavory",
      "unscathed",
      "unscented",
      "unscrew",
      "unsealed",
      "unseated",
      "unsecured",
      "unseeing",
      "unseemly",
      "unseen",
      "unselect",
      "unselfish",
      "unsent",
      "unsettled",
      "unshackle",
      "unshaken",
      "unshaved",
      "unshaven",
      "unsheathe",
      "unshipped",
      "unsightly",
      "unsigned",
      "unskilled",
      "unsliced",
      "unsmooth",
      "unsnap",
      "unsocial",
      "unsoiled",
      "unsold",
      "unsolved",
      "unsorted",
      "unspoiled",
      "unspoken",
      "unstable",
      "unstaffed",
      "unstamped",
      "unsteady",
      "unsterile",
      "unstirred",
      "unstitch",
      "unstopped",
      "unstuck",
      "unstuffed",
      "unstylish",
      "unsubtle",
      "unsubtly",
      "unsuited",
      "unsure",
      "unsworn",
      "untagged",
      "untainted",
      "untaken",
      "untamed",
      "untangled",
      "untapped",
      "untaxed",
      "unthawed",
      "unthread",
      "untidy",
      "untie",
      "until",
      "untimed",
      "untimely",
      "untitled",
      "untoasted",
      "untold",
      "untouched",
      "untracked",
      "untrained",
      "untreated",
      "untried",
      "untrimmed",
      "untrue",
      "untruth",
      "unturned",
      "untwist",
      "untying",
      "unusable",
      "unused",
      "unusual",
      "unvalued",
      "unvaried",
      "unvarying",
      "unveiled",
      "unveiling",
      "unvented",
      "unviable",
      "unvisited",
      "unvocal",
      "unwanted",
      "unwarlike",
      "unwary",
      "unwashed",
      "unwatched",
      "unweave",
      "unwed",
      "unwelcome",
      "unwell",
      "unwieldy",
      "unwilling",
      "unwind",
      "unwired",
      "unwitting",
      "unwomanly",
      "unworldly",
      "unworn",
      "unworried",
      "unworthy",
      "unwound",
      "unwoven",
      "unwrapped",
      "unwritten",
      "unzip",
      "upbeat",
      "upchuck",
      "upcoming",
      "upcountry",
      "update",
      "upfront",
      "upgrade",
      "upheaval",
      "upheld",
      "uphill",
      "uphold",
      "uplifted",
      "uplifting",
      "upload",
      "upon",
      "upper",
      "upright",
      "uprising",
      "upriver",
      "uproar",
      "uproot",
      "upscale",
      "upside",
      "upstage",
      "upstairs",
      "upstart",
      "upstate",
      "upstream",
      "upstroke",
      "upswing",
      "uptake",
      "uptight",
      "uptown",
      "upturned",
      "upward",
      "upwind",
      "uranium",
      "urban",
      "urchin",
      "urethane",
      "urgency",
      "urgent",
      "urging",
      "urologist",
      "urology",
      "usable",
      "usage",
      "useable",
      "used",
      "uselessly",
      "user",
      "usher",
      "usual",
      "utensil",
      "utility",
      "utilize",
      "utmost",
      "utopia",
      "utter",
      "vacancy",
      "vacant",
      "vacate",
      "vacation",
      "vagabond",
      "vagrancy",
      "vagrantly",
      "vaguely",
      "vagueness",
      "valiant",
      "valid",
      "valium",
      "valley",
      "valuables",
      "value",
      "vanilla",
      "vanish",
      "vanity",
      "vanquish",
      "vantage",
      "vaporizer",
      "variable",
      "variably",
      "varied",
      "variety",
      "various",
      "varmint",
      "varnish",
      "varsity",
      "varying",
      "vascular",
      "vaseline",
      "vastly",
      "vastness",
      "veal",
      "vegan",
      "veggie",
      "vehicular",
      "velcro",
      "velocity",
      "velvet",
      "vendetta",
      "vending",
      "vendor",
      "veneering",
      "vengeful",
      "venomous",
      "ventricle",
      "venture",
      "venue",
      "venus",
      "verbalize",
      "verbally",
      "verbose",
      "verdict",
      "verify",
      "verse",
      "version",
      "versus",
      "vertebrae",
      "vertical",
      "vertigo",
      "very",
      "vessel",
      "vest",
      "veteran",
      "veto",
      "vexingly",
      "viability",
      "viable",
      "vibes",
      "vice",
      "vicinity",
      "victory",
      "video",
      "viewable",
      "viewer",
      "viewing",
      "viewless",
      "viewpoint",
      "vigorous",
      "village",
      "villain",
      "vindicate",
      "vineyard",
      "vintage",
      "violate",
      "violation",
      "violator",
      "violet",
      "violin",
      "viper",
      "viral",
      "virtual",
      "virtuous",
      "virus",
      "visa",
      "viscosity",
      "viscous",
      "viselike",
      "visible",
      "visibly",
      "vision",
      "visiting",
      "visitor",
      "visor",
      "vista",
      "vitality",
      "vitalize",
      "vitally",
      "vitamins",
      "vivacious",
      "vividly",
      "vividness",
      "vixen",
      "vocalist",
      "vocalize",
      "vocally",
      "vocation",
      "voice",
      "voicing",
      "void",
      "volatile",
      "volley",
      "voltage",
      "volumes",
      "voter",
      "voting",
      "voucher",
      "vowed",
      "vowel",
      "voyage",
      "wackiness",
      "wad",
      "wafer",
      "waffle",
      "waged",
      "wager",
      "wages",
      "waggle",
      "wagon",
      "wake",
      "waking",
      "walk",
      "walmart",
      "walnut",
      "walrus",
      "waltz",
      "wand",
      "wannabe",
      "wanted",
      "wanting",
      "wasabi",
      "washable",
      "washbasin",
      "washboard",
      "washbowl",
      "washcloth",
      "washday",
      "washed",
      "washer",
      "washhouse",
      "washing",
      "washout",
      "washroom",
      "washstand",
      "washtub",
      "wasp",
      "wasting",
      "watch",
      "water",
      "waviness",
      "waving",
      "wavy",
      "whacking",
      "whacky",
      "wham",
      "wharf",
      "wheat",
      "whenever",
      "whiff",
      "whimsical",
      "whinny",
      "whiny",
      "whisking",
      "whoever",
      "whole",
      "whomever",
      "whoopee",
      "whooping",
      "whoops",
      "why",
      "wick",
      "widely",
      "widen",
      "widget",
      "widow",
      "width",
      "wieldable",
      "wielder",
      "wife",
      "wifi",
      "wikipedia",
      "wildcard",
      "wildcat",
      "wilder",
      "wildfire",
      "wildfowl",
      "wildland",
      "wildlife",
      "wildly",
      "wildness",
      "willed",
      "willfully",
      "willing",
      "willow",
      "willpower",
      "wilt",
      "wimp",
      "wince",
      "wincing",
      "wind",
      "wing",
      "winking",
      "winner",
      "winnings",
      "winter",
      "wipe",
      "wired",
      "wireless",
      "wiring",
      "wiry",
      "wisdom",
      "wise",
      "wish",
      "wisplike",
      "wispy",
      "wistful",
      "wizard",
      "wobble",
      "wobbling",
      "wobbly",
      "wok",
      "wolf",
      "wolverine",
      "womanhood",
      "womankind",
      "womanless",
      "womanlike",
      "womanly",
      "womb",
      "woof",
      "wooing",
      "wool",
      "woozy",
      "word",
      "work",
      "worried",
      "worrier",
      "worrisome",
      "worry",
      "worsening",
      "worshiper",
      "worst",
      "wound",
      "woven",
      "wow",
      "wrangle",
      "wrath",
      "wreath",
      "wreckage",
      "wrecker",
      "wrecking",
      "wrench",
      "wriggle",
      "wriggly",
      "wrinkle",
      "wrinkly",
      "wrist",
      "writing",
      "written",
      "wrongdoer",
      "wronged",
      "wrongful",
      "wrongly",
      "wrongness",
      "wrought",
      "xbox",
      "xerox",
      "yahoo",
      "yam",
      "yanking",
      "yapping",
      "yard",
      "yarn",
      "yeah",
      "yearbook",
      "yearling",
      "yearly",
      "yearning",
      "yeast",
      "yelling",
      "yelp",
      "yen",
      "yesterday",
      "yiddish",
      "yield",
      "yin",
      "yippee",
      "yo-yo",
      "yodel",
      "yoga",
      "yogurt",
      "yonder",
      "yoyo",
      "yummy",
      "zap",
      "zealous",
      "zebra",
      "zen",
      "zeppelin",
      "zero",
      "zestfully",
      "zesty",
      "zigzagged",
      "zipfile",
      "zipping",
      "zippy",
      "zips",
      "zit",
      "zodiac",
      "zombie",
      "zone",
      "zoning",
      "zookeeper",
      "zoologist",
      "zoology",
      "zoom"
    ];
  }
});

// node_modules/ton-crypto/dist/passwords/newSecureWords.js
var require_newSecureWords = __commonJS({
  "node_modules/ton-crypto/dist/passwords/newSecureWords.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newSecureWords = void 0;
    var getSecureRandom_1 = require_getSecureRandom2();
    var wordlist_1 = require_wordlist2();
    async function newSecureWords(size4 = 6) {
      let words = [];
      for (let i = 0; i < size4; i++) {
        words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
      }
      return words;
    }
    exports.newSecureWords = newSecureWords;
  }
});

// node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js
var require_newSecurePassphrase = __commonJS({
  "node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newSecurePassphrase = void 0;
    var __1 = require_dist();
    async function newSecurePassphrase(size4 = 6) {
      return (await (0, __1.newSecureWords)(size4)).join("-");
    }
    exports.newSecurePassphrase = newSecurePassphrase;
  }
});

// node_modules/ton-crypto/dist/index.js
var require_dist = __commonJS({
  "node_modules/ton-crypto/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newSecurePassphrase = exports.newSecureWords = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
    var sha256_1 = require_sha2562();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
      return sha256_1.sha256_sync;
    } });
    var sha512_1 = require_sha5122();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
    Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
      return sha512_1.sha512_sync;
    } });
    var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var hmac_sha512_1 = require_hmac_sha5122();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var getSecureRandom_1 = require_getSecureRandom2();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomNumber;
    } });
    var mnemonic_1 = require_mnemonic();
    Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicNew;
    } });
    Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicValidate;
    } });
    Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToPrivateKey;
    } });
    Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToWalletKey;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToSeed;
    } });
    var wordlist_1 = require_wordlist();
    Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
      return wordlist_1.wordlist;
    } });
    var nacl_1 = require_nacl();
    Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
      return nacl_1.sealBox;
    } });
    Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
      return nacl_1.openBox;
    } });
    Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
      return nacl_1.keyPairFromSeed;
    } });
    var nacl_2 = require_nacl();
    Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSecretKey;
    } });
    Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
      return nacl_2.sign;
    } });
    Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
      return nacl_2.signVerify;
    } });
    var newSecureWords_1 = require_newSecureWords();
    Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
      return newSecureWords_1.newSecureWords;
    } });
    var newSecurePassphrase_1 = require_newSecurePassphrase();
    Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
      return newSecurePassphrase_1.newSecurePassphrase;
    } });
  }
});

// node_modules/ton/dist/boc/utils/crc32c.js
var require_crc32c = __commonJS({
  "node_modules/ton/dist/boc/utils/crc32c.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc32c = void 0;
    var POLY = 2197175160;
    function crc32c(source) {
      let crc = 0 ^ 4294967295;
      for (let n = 0; n < source.length; n++) {
        crc ^= source[n];
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      }
      crc = crc ^ 4294967295;
      let res = Buffer.alloc(4);
      res.writeInt32LE(crc);
      return res;
    }
    exports.crc32c = crc32c;
  }
});

// node_modules/ton/dist/boc/utils/topologicalSort.js
var require_topologicalSort = __commonJS({
  "node_modules/ton/dist/boc/utils/topologicalSort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.topologicalSort = void 0;
    function topologicalSort(src) {
      let pending = [src];
      let allCells = /* @__PURE__ */ new Map();
      let notPermCells = /* @__PURE__ */ new Set();
      let sorted = [];
      while (pending.length > 0) {
        const cells = [...pending];
        pending = [];
        for (let cell of cells) {
          const hash = cell.hash().toString("hex");
          if (allCells.has(hash)) {
            continue;
          }
          notPermCells.add(hash);
          allCells.set(hash, { cell, refs: cell.refs.map((v) => v.hash().toString("hex")) });
          for (let r of cell.refs) {
            pending.push(r);
          }
        }
      }
      let tempMark = /* @__PURE__ */ new Set();
      function visit(hash) {
        if (!notPermCells.has(hash)) {
          return;
        }
        if (tempMark.has(hash)) {
          throw Error("Not a DAG");
        }
        tempMark.add(hash);
        for (let c of allCells.get(hash).refs) {
          visit(c);
        }
        sorted.unshift(hash);
        tempMark.delete(hash);
        notPermCells.delete(hash);
      }
      while (notPermCells.size > 0) {
        const id = Array.from(notPermCells)[0];
        visit(id);
      }
      let indexes = /* @__PURE__ */ new Map();
      for (let i = 0; i < sorted.length; i++) {
        indexes.set(sorted[i], i);
      }
      let result = [];
      for (let ent of sorted) {
        const rrr = allCells.get(ent);
        result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });
      }
      return result;
    }
    exports.topologicalSort = topologicalSort;
  }
});

// node_modules/ton/dist/boc/boc.js
var require_boc = __commonJS({
  "node_modules/ton/dist/boc/boc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeToBoc = exports.deserializeBoc = exports.deserializeCellData = exports.parseBocHeader = exports.hashCell = exports.getMaxLevel = exports.getMaxDepth = void 0;
    var ton_crypto_1 = require_dist();
    var __1 = require_dist2();
    var crc32c_1 = require_crc32c();
    var topologicalSort_1 = require_topologicalSort();
    var reachBocMagicPrefix = Buffer.from("B5EE9C72", "hex");
    var leanBocMagicPrefix = Buffer.from("68ff65f3", "hex");
    var leanBocMagicPrefixCRC = Buffer.from("acc3a728", "hex");
    var cacheContext = null;
    function getCellCache(src) {
      if (!cacheContext) {
        throw Error("No cache context");
      }
      let ex = src[cacheContext];
      if (!ex) {
        ex = { hash: null, maxDepth: null };
        src[cacheContext] = ex;
      }
      return ex;
    }
    function inCache(cell, handler) {
      let wasCreated = false;
      if (!cacheContext) {
        wasCreated = true;
        cacheContext = Symbol();
      }
      let cache = getCellCache(cell);
      try {
        return handler(cache);
      } finally {
        if (wasCreated) {
          cacheContext = null;
        }
      }
    }
    function getMaxDepth(cell) {
      return inCache(cell, (cache) => {
        if (cache.maxDepth !== null) {
          return cache.maxDepth;
        }
        let maxDepth = 0;
        if (cell.refs.length > 0) {
          for (let k in cell.refs) {
            const i = cell.refs[k];
            if (getMaxDepth(i) > maxDepth) {
              maxDepth = getMaxDepth(i);
            }
          }
          maxDepth = maxDepth + 1;
        }
        cache.maxDepth = maxDepth;
        return maxDepth;
      });
    }
    exports.getMaxDepth = getMaxDepth;
    function getMaxDepthAsArray(cell) {
      const maxDepth = getMaxDepth(cell);
      const d = Uint8Array.from({ length: 2 }, () => 0);
      d[1] = maxDepth % 256;
      d[0] = Math.floor(maxDepth / 256);
      return Buffer.from(d);
    }
    function getMaxLevel(cell) {
      return 0;
    }
    exports.getMaxLevel = getMaxLevel;
    function getRefsDescriptor(cell) {
      const d1 = Uint8Array.from({ length: 1 }, () => 0);
      d1[0] = cell.refs.length + (cell.isExotic ? 1 : 0) * 8 + getMaxLevel(cell) * 32;
      return Buffer.from(d1);
    }
    function getBitsDescriptor(cell) {
      const d2 = Uint8Array.from({ length: 1 }, () => 0);
      let len = cell.bits.cursor;
      if (cell.isExotic) {
        len += 8;
      }
      d2[0] = Math.ceil(len / 8) + Math.floor(len / 8);
      return Buffer.from(d2);
    }
    function getDataWithDescriptors(cell) {
      const d1 = getRefsDescriptor(cell);
      const d2 = getBitsDescriptor(cell);
      const tuBits = cell.bits.getTopUppedArray();
      return Buffer.concat([d1, d2, tuBits]);
    }
    function getRepr(cell) {
      const reprArray = [];
      reprArray.push(getDataWithDescriptors(cell));
      for (let k in cell.refs) {
        const i = cell.refs[k];
        reprArray.push(getMaxDepthAsArray(i));
      }
      for (let k in cell.refs) {
        const i = cell.refs[k];
        reprArray.push(i.hash());
      }
      let x = Buffer.alloc(0);
      for (let k in reprArray) {
        const i = reprArray[k];
        x = Buffer.concat([x, i]);
      }
      return x;
    }
    function hashCell(cell) {
      return inCache(cell, (cache) => {
        if (cache.hash) {
          return cache.hash;
        }
        let r = (0, ton_crypto_1.sha256_sync)(getRepr(cell));
        cache.hash = r;
        return r;
      });
    }
    exports.hashCell = hashCell;
    function readNBytesUIntFromArray(n, ui8array) {
      let res = 0;
      for (let c = 0; c < n; c++) {
        res *= 256;
        res += ui8array[c];
      }
      return res;
    }
    function parseBocHeader(serializedBoc) {
      if (serializedBoc.length < 4 + 1) {
        throw new Error("Not enough bytes for magic prefix");
      }
      const inputData = serializedBoc;
      const prefix = serializedBoc.slice(0, 4);
      serializedBoc = serializedBoc.slice(4);
      let has_idx = false;
      let hash_crc32 = false;
      let has_cache_bits = false;
      let flags = 0;
      let size_bytes = 0;
      if (prefix.equals(reachBocMagicPrefix)) {
        const flags_byte = serializedBoc[0];
        has_idx = !!(flags_byte & 128);
        hash_crc32 = !!(flags_byte & 64);
        has_cache_bits = !!(flags_byte & 32);
        flags = (flags_byte & 16) * 2 + (flags_byte & 8);
        size_bytes = flags_byte % 8;
      } else if (prefix.equals(leanBocMagicPrefix)) {
        has_idx = true;
        hash_crc32 = false;
        has_cache_bits = false;
        flags = 0;
        size_bytes = serializedBoc[0];
      } else if (prefix.equals(leanBocMagicPrefixCRC)) {
        has_idx = true;
        hash_crc32 = true;
        has_cache_bits = false;
        flags = 0;
        size_bytes = serializedBoc[0];
      } else {
        throw Error("Unknown magic prefix");
      }
      serializedBoc = serializedBoc.slice(1);
      if (serializedBoc.length < 1 + 5 * size_bytes) {
        throw new Error("Not enough bytes for encoding cells counters");
      }
      const offset_bytes = serializedBoc[0];
      serializedBoc = serializedBoc.slice(1);
      const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
      serializedBoc = serializedBoc.slice(size_bytes);
      const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
      serializedBoc = serializedBoc.slice(size_bytes);
      const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
      serializedBoc = serializedBoc.slice(size_bytes);
      const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);
      serializedBoc = serializedBoc.slice(offset_bytes);
      if (serializedBoc.length < roots_num * size_bytes) {
        throw new Error("Not enough bytes for encoding root cells hashes");
      }
      let root_list = [];
      for (let c = 0; c < roots_num; c++) {
        root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));
        serializedBoc = serializedBoc.slice(size_bytes);
      }
      let index = null;
      if (has_idx) {
        index = [];
        if (serializedBoc.length < offset_bytes * cells_num)
          throw new Error("Not enough bytes for index encoding");
        for (let c = 0; c < cells_num; c++) {
          index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));
          serializedBoc = serializedBoc.slice(offset_bytes);
        }
      }
      if (serializedBoc.length < tot_cells_size) {
        throw new Error("Not enough bytes for cells data");
      }
      const cells_data = serializedBoc.slice(0, tot_cells_size);
      serializedBoc = serializedBoc.slice(tot_cells_size);
      if (hash_crc32) {
        if (serializedBoc.length < 4) {
          throw new Error("Not enough bytes for crc32c hashsum");
        }
        const length = inputData.length;
        if (!(0, crc32c_1.crc32c)(inputData.slice(0, length - 4)).equals(serializedBoc.slice(0, 4))) {
          throw new Error("Crc32c hashsum mismatch");
        }
        serializedBoc = serializedBoc.slice(4);
      }
      if (serializedBoc.length) {
        throw new Error("Too much bytes in BoC serialization");
      }
      return {
        has_idx,
        hash_crc32,
        has_cache_bits,
        flags,
        size_bytes,
        off_bytes: offset_bytes,
        cells_num,
        roots_num,
        absent_num,
        tot_cells_size,
        root_list,
        index,
        cells_data
      };
    }
    exports.parseBocHeader = parseBocHeader;
    function deserializeCellData(cellData, referenceIndexSize) {
      if (cellData.length < 2) {
        throw new Error("Not enough bytes to encode cell descriptors");
      }
      const d1 = cellData[0], d2 = cellData[1];
      cellData = cellData.slice(2);
      const isExotic = !!(d1 & 8);
      const refNum = d1 % 8;
      let dataBytesize = Math.ceil(d2 / 2);
      const fullfilledBytes = !(d2 % 2);
      let bits = __1.BitString.alloc(1023);
      let refs = [];
      if (cellData.length < dataBytesize + referenceIndexSize * refNum) {
        throw new Error("Not enough bytes to encode cell data");
      }
      let kind = "ordinary";
      if (isExotic) {
        let k = cellData.readUInt8();
        if (k === 1) {
          kind = "pruned";
        } else if (k === 2) {
          kind = "library_reference";
        } else if (k === 3) {
          kind = "merkle_proof";
        } else if (k === 4) {
          kind = "merkle_update";
        } else {
          throw Error("Invalid cell type: " + k);
        }
        cellData = cellData.slice(1);
        dataBytesize--;
      }
      bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);
      cellData = cellData.slice(dataBytesize);
      for (let r = 0; r < refNum; r++) {
        refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));
        cellData = cellData.slice(referenceIndexSize);
      }
      let cell = new __1.Cell(kind, bits);
      return { cell, refs, residue: cellData };
    }
    exports.deserializeCellData = deserializeCellData;
    function deserializeBoc(serializedBoc) {
      const header = parseBocHeader(serializedBoc);
      let cells_data = header.cells_data;
      let cells_array = [];
      let refs_array = [];
      for (let ci = 0; ci < header.cells_num; ci++) {
        let dd = deserializeCellData(cells_data, header.size_bytes);
        cells_data = dd.residue;
        cells_array.push(dd.cell);
        refs_array.push(dd.refs);
      }
      for (let ci = header.cells_num - 1; ci >= 0; ci--) {
        let c = refs_array[ci];
        for (let ri = 0; ri < c.length; ri++) {
          const r = c[ri];
          if (r < ci) {
            throw new Error("Topological order is broken");
          }
          cells_array[ci].refs[ri] = cells_array[r];
        }
      }
      let root_cells = [];
      for (let ri of header.root_list) {
        root_cells.push(cells_array[ri]);
      }
      return root_cells;
    }
    exports.deserializeBoc = deserializeBoc;
    function serializeForBoc(cell, refs, sSize) {
      const reprArray = [];
      reprArray.push(getRefsDescriptor(cell));
      reprArray.push(getBitsDescriptor(cell));
      if (cell.isExotic) {
        if (cell.kind === "pruned") {
          reprArray.push(Buffer.from([1]));
        } else if (cell.kind === "library_reference") {
          reprArray.push(Buffer.from([2]));
        } else if (cell.kind === "merkle_proof") {
          reprArray.push(Buffer.from([3]));
        } else if (cell.kind === "merkle_update") {
          reprArray.push(Buffer.from([4]));
        } else {
          throw Error("Invalid cell type");
        }
      }
      reprArray.push(cell.bits.getTopUppedArray());
      for (let refIndexInt of refs) {
        let refIndexHex = refIndexInt.toString(16);
        while (refIndexHex.length < sSize * 2) {
          refIndexHex = "0" + refIndexHex;
        }
        const reference = Buffer.from(refIndexHex, "hex");
        reprArray.push(reference);
      }
      let x = Buffer.alloc(0);
      for (let k in reprArray) {
        const i = reprArray[k];
        x = Buffer.concat([x, i]);
      }
      return x;
    }
    function serializeToBoc(cell, has_idx = true, hash_crc32 = true, has_cache_bits = false, flags = 0) {
      return inCache(cell, () => {
        const root_cell = cell;
        const allCells = (0, topologicalSort_1.topologicalSort)(root_cell);
        const cells_num = allCells.length;
        const s = cells_num.toString(2).length;
        const s_bytes = Math.max(Math.ceil(s / 8), 1);
        let full_size = 0;
        let sizeIndex = [];
        for (let cell_info of allCells) {
          full_size = full_size + serializeForBoc(cell_info.cell, cell_info.refs, s_bytes).length;
          sizeIndex.push(full_size);
        }
        const offset_bits = full_size.toString(2).length;
        const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);
        const serialization = __1.BitString.alloc((1023 + 32 * 4 + 32 * 3) * allCells.length);
        serialization.writeBuffer(reachBocMagicPrefix);
        serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);
        serialization.writeUint(flags, 2);
        serialization.writeUint(s_bytes, 3);
        serialization.writeUint8(offset_bytes);
        serialization.writeUint(cells_num, s_bytes * 8);
        serialization.writeUint(1, s_bytes * 8);
        serialization.writeUint(0, s_bytes * 8);
        serialization.writeUint(full_size, offset_bytes * 8);
        serialization.writeUint(0, s_bytes * 8);
        if (has_idx) {
          allCells.forEach((cell_data, index) => serialization.writeUint(sizeIndex[index], offset_bytes * 8));
        }
        for (let cell_info of allCells) {
          const refcell_ser = serializeForBoc(cell_info.cell, cell_info.refs, s_bytes);
          serialization.writeBuffer(refcell_ser);
        }
        let ser_arr = serialization.getTopUppedArray();
        if (hash_crc32) {
          ser_arr = Buffer.concat([ser_arr, (0, crc32c_1.crc32c)(ser_arr)]);
        }
        return ser_arr;
      });
    }
    exports.serializeToBoc = serializeToBoc;
  }
});

// node_modules/ton/dist/boc/Cell.js
var require_Cell = __commonJS({
  "node_modules/ton/dist/boc/Cell.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cell = void 0;
    var BitString_1 = require_BitString();
    var boc_1 = require_boc();
    var symbol_inspect_1 = __importDefault(require_symbol());
    var __1 = require_dist2();
    var Cell = class {
      constructor(kind = "ordinary", bits = BitString_1.BitString.alloc(1023)) {
        this.refs = [];
        this[_a] = () => this.toString();
        this.kind = kind;
        this.bits = bits;
      }
      static fromBoc(src) {
        return (0, boc_1.deserializeBoc)(typeof src === "string" ? Buffer.from(src, "hex") : src);
      }
      get isExotic() {
        return this.kind !== "ordinary";
      }
      beginParse() {
        if (this.isExotic) {
          throw Error("Unable to parse exotic cell");
        }
        return __1.Slice.fromCell(this);
      }
      writeCell(anotherCell) {
        this.bits.writeBitString(anotherCell.bits);
        for (let r of anotherCell.refs) {
          this.refs.push(r);
        }
      }
      hash() {
        return (0, boc_1.hashCell)(this);
      }
      toBoc(opts) {
        let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : true;
        let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
        let cacheBits = opts && opts.cacheBits !== null && opts.cacheBits !== void 0 ? opts.cacheBits : false;
        let flags = opts && opts.flags !== null && opts.flags !== void 0 ? opts.flags : 0;
        return (0, boc_1.serializeToBoc)(this, idx, crc32, cacheBits, flags);
      }
      toString(indent) {
        let id = indent || "";
        let s = id + "x{" + this.bits.toFiftHex() + "}\n";
        for (let k in this.refs) {
          const i = this.refs[k];
          s += i.toString(id + " ");
        }
        return s;
      }
      toDebugString(indent) {
        let id = indent || "";
        if (this.isExotic) {
          id += "(exotic)";
        }
        let s = id + "x{" + this.bits.toFiftHex() + "}\n";
        for (let k in this.refs) {
          const i = this.refs[k];
          s += i.toString(id + " ");
        }
        return s;
      }
      withReference(cell) {
        this.refs.push(cell);
        return this;
      }
      withData(src) {
        for (let s of src) {
          if (s === "0") {
            this.bits.writeBit(0);
          } else {
            this.bits.writeBit(1);
          }
        }
        return this;
      }
      equals(src) {
        if (src.refs.length !== this.refs.length) {
          return false;
        }
        for (let i = 0; i < src.refs.length; i++) {
          if (!src.refs[i].equals(this.refs[i])) {
            return false;
          }
        }
        return this.bits.equals(src.bits);
      }
      getMaxLevel() {
        return (0, boc_1.getMaxLevel)(this);
      }
      getMaxDepth() {
        return (0, boc_1.getMaxDepth)(this);
      }
    };
    exports.Cell = Cell;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/ton/dist/utils/crc16.js
var require_crc16 = __commonJS({
  "node_modules/ton/dist/utils/crc16.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc16 = void 0;
    function crc16(data) {
      const poly = 4129;
      let reg = 0;
      const message = Buffer.alloc(data.length + 2);
      message.set(data);
      for (let byte of message) {
        let mask = 128;
        while (mask > 0) {
          reg <<= 1;
          if (byte & mask) {
            reg += 1;
          }
          mask >>= 1;
          if (reg > 65535) {
            reg &= 65535;
            reg ^= poly;
          }
        }
      }
      return Buffer.from([Math.floor(reg / 256), reg % 256]);
    }
    exports.crc16 = crc16;
  }
});

// node_modules/ton/dist/address/Address.js
var require_Address = __commonJS({
  "node_modules/ton/dist/address/Address.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var crc16_1 = require_crc16();
    var bounceable_tag = 17;
    var non_bounceable_tag = 81;
    var test_flag = 128;
    function parseFriendlyAddress(src) {
      const data = Buffer.isBuffer(src) ? src : Buffer.from(src, "base64");
      if (data.length !== 36) {
        throw new Error("Unknown address type: byte length is not equal to 36");
      }
      const addr = data.slice(0, 34);
      const crc = data.slice(34, 36);
      const calcedCrc = (0, crc16_1.crc16)(addr);
      if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
        throw new Error("Invalid checksum: " + src);
      }
      let tag = addr[0];
      let isTestOnly = false;
      let isBounceable = false;
      if (tag & test_flag) {
        isTestOnly = true;
        tag = tag ^ test_flag;
      }
      if (tag !== bounceable_tag && tag !== non_bounceable_tag)
        throw "Unknown address tag";
      isBounceable = tag === bounceable_tag;
      let workchain = null;
      if (addr[1] === 255) {
        workchain = -1;
      } else {
        workchain = addr[1];
      }
      const hashPart = addr.slice(2, 34);
      return { isTestOnly, isBounceable, workchain, hashPart };
    }
    var Address = class {
      constructor(workChain, hash) {
        this.toString = () => {
          return this.workChain + ":" + this.hash.toString("hex");
        };
        this.toBuffer = () => {
          const addressWithChecksum = Buffer.alloc(36);
          addressWithChecksum.set(this.hash);
          addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
          return addressWithChecksum;
        };
        this.toFriendlyBuffer = (args) => {
          let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
          let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
          let tag = bounceable ? bounceable_tag : non_bounceable_tag;
          if (testOnly) {
            tag |= test_flag;
          }
          const addr = Buffer.alloc(34);
          addr[0] = tag;
          addr[1] = this.workChain;
          addr.set(this.hash, 2);
          const addressWithChecksum = Buffer.alloc(36);
          addressWithChecksum.set(addr);
          addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
          return addressWithChecksum;
        };
        this.toFriendly = (args) => {
          let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
          let buffer = this.toFriendlyBuffer(args);
          if (urlSafe) {
            return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
          } else {
            return buffer.toString("base64");
          }
        };
        this[_a] = () => this.toFriendly();
        this.workChain = workChain;
        this.hash = hash;
        Object.freeze(this);
      }
      static isAddress(src) {
        return src instanceof Address;
      }
      static isFriendly(source) {
        return source.indexOf(":") < 0;
      }
      static normalize(source) {
        if (typeof source === "string") {
          return Address.parse(source).toFriendly();
        } else {
          return source.toFriendly();
        }
      }
      static parse(source) {
        if (Address.isFriendly(source)) {
          return this.parseFriendly(source).address;
        } else {
          return this.parseRaw(source);
        }
      }
      static parseRaw(source) {
        let workChain = parseInt(source.split(":")[0]);
        let hash = Buffer.from(source.split(":")[1], "hex");
        return new Address(workChain, hash);
      }
      static parseFriendly(source) {
        if (Buffer.isBuffer(source)) {
          let r = parseFriendlyAddress(source);
          return {
            isBounceable: r.isBounceable,
            isTestOnly: r.isTestOnly,
            address: new Address(r.workchain, r.hashPart)
          };
        } else {
          let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
          let r = parseFriendlyAddress(addr);
          return {
            isBounceable: r.isBounceable,
            isTestOnly: r.isTestOnly,
            address: new Address(r.workchain, r.hashPart)
          };
        }
      }
      equals(src) {
        if (src.workChain !== this.workChain) {
          return false;
        }
        return src.hash.equals(this.hash);
      }
    };
    exports.Address = Address;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/fp-ts/es6/function.js
function identity(a) {
  return a;
}
function constant(a) {
  return function() {
    return a;
  };
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      var ret = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var constTrue, constFalse, constNull, constUndefined, SK;
var init_function = __esm({
  "node_modules/fp-ts/es6/function.js"() {
    constTrue = constant(true);
    constFalse = constant(false);
    constNull = constant(null);
    constUndefined = constant(void 0);
    SK = function(_, b) {
      return b;
    };
  }
});

// node_modules/fp-ts/es6/internal.js
var __spreadArray, isNone, isSome, none, some, isLeft, isRight, left, right, singleton, isNonEmpty, head, tail, emptyReadonlyArray, emptyRecord, has, fromReadonlyNonEmptyArray;
var init_internal = __esm({
  "node_modules/fp-ts/es6/internal.js"() {
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isNone = function(fa) {
      return fa._tag === "None";
    };
    isSome = function(fa) {
      return fa._tag === "Some";
    };
    none = { _tag: "None" };
    some = function(a) {
      return { _tag: "Some", value: a };
    };
    isLeft = function(ma) {
      return ma._tag === "Left";
    };
    isRight = function(ma) {
      return ma._tag === "Right";
    };
    left = function(e) {
      return { _tag: "Left", left: e };
    };
    right = function(a) {
      return { _tag: "Right", right: a };
    };
    singleton = function(a) {
      return [a];
    };
    isNonEmpty = function(as) {
      return as.length > 0;
    };
    head = function(as) {
      return as[0];
    };
    tail = function(as) {
      return as.slice(1);
    };
    emptyReadonlyArray = [];
    emptyRecord = {};
    has = Object.prototype.hasOwnProperty;
    fromReadonlyNonEmptyArray = function(as) {
      return __spreadArray([as[0]], as.slice(1), true);
    };
  }
});

// node_modules/fp-ts/es6/Apply.js
function apFirst(A) {
  return function(second) {
    return function(first2) {
      return A.ap(A.map(first2, function(a) {
        return function() {
          return a;
        };
      }), second);
    };
  };
}
function apSecond(A) {
  return function(second) {
    return function(first2) {
      return A.ap(A.map(first2, function() {
        return function(b) {
          return b;
        };
      }), second);
    };
  };
}
function apS(F) {
  return function(name, fb) {
    return function(fa) {
      return F.ap(F.map(fa, function(a) {
        return function(b) {
          var _a;
          return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
        };
      }), fb);
    };
  };
}
function getApplySemigroup(F) {
  return function(S) {
    return {
      concat: function(first2, second) {
        return F.ap(F.map(first2, function(x) {
          return function(y) {
            return S.concat(x, y);
          };
        }), second);
      }
    };
  };
}
var init_Apply = __esm({
  "node_modules/fp-ts/es6/Apply.js"() {
    init_function();
    init_internal();
  }
});

// node_modules/fp-ts/es6/Functor.js
function flap(F) {
  return function(a) {
    return function(fab) {
      return F.map(fab, function(f) {
        return f(a);
      });
    };
  };
}
function bindTo(F) {
  return function(name) {
    return function(fa) {
      return F.map(fa, function(a) {
        var _a;
        return _a = {}, _a[name] = a, _a;
      });
    };
  };
}
var init_Functor = __esm({
  "node_modules/fp-ts/es6/Functor.js"() {
    init_function();
  }
});

// node_modules/fp-ts/es6/Applicative.js
function getApplicativeMonoid(F) {
  var f = getApplySemigroup(F);
  return function(M) {
    return {
      concat: f(M).concat,
      empty: F.of(M.empty)
    };
  };
}
var init_Applicative = __esm({
  "node_modules/fp-ts/es6/Applicative.js"() {
    init_Apply();
    init_function();
    init_Functor();
  }
});

// node_modules/fp-ts/es6/Chain.js
function chainFirst(M) {
  return function(f) {
    return function(first2) {
      return M.chain(first2, function(a) {
        return M.map(f(a), function() {
          return a;
        });
      });
    };
  };
}
function bind(M) {
  return function(name, f) {
    return function(ma) {
      return M.chain(ma, function(a) {
        return M.map(f(a), function(b) {
          var _a;
          return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
        });
      });
    };
  };
}
var init_Chain = __esm({
  "node_modules/fp-ts/es6/Chain.js"() {
  }
});

// node_modules/fp-ts/es6/ChainRec.js
var tailRec;
var init_ChainRec = __esm({
  "node_modules/fp-ts/es6/ChainRec.js"() {
    tailRec = function(startWith, f) {
      var ab = f(startWith);
      while (ab._tag === "Left") {
        ab = f(ab.left);
      }
      return ab.right;
    };
  }
});

// node_modules/fp-ts/es6/FromEither.js
function fromOption(F) {
  return function(onNone) {
    return function(ma) {
      return F.fromEither(isNone(ma) ? left(onNone()) : right(ma.value));
    };
  };
}
function fromPredicate(F) {
  return function(predicate, onFalse) {
    return function(a) {
      return F.fromEither(predicate(a) ? right(a) : left(onFalse(a)));
    };
  };
}
function fromOptionK(F) {
  var fromOptionF = fromOption(F);
  return function(onNone) {
    var from = fromOptionF(onNone);
    return function(f) {
      return flow(f, from);
    };
  };
}
function chainOptionK(F, M) {
  var fromOptionKF = fromOptionK(F);
  return function(onNone) {
    var from = fromOptionKF(onNone);
    return function(f) {
      return function(ma) {
        return M.chain(ma, from(f));
      };
    };
  };
}
function fromEitherK(F) {
  return function(f) {
    return flow(f, F.fromEither);
  };
}
function chainEitherK(F, M) {
  var fromEitherKF = fromEitherK(F);
  return function(f) {
    return function(ma) {
      return M.chain(ma, fromEitherKF(f));
    };
  };
}
function chainFirstEitherK(F, M) {
  return flow(fromEitherK(F), chainFirst(M));
}
function filterOrElse(F, M) {
  return function(predicate, onFalse) {
    return function(ma) {
      return M.chain(ma, function(a) {
        return F.fromEither(predicate(a) ? right(a) : left(onFalse(a)));
      });
    };
  };
}
var init_FromEither = __esm({
  "node_modules/fp-ts/es6/FromEither.js"() {
    init_Chain();
    init_function();
    init_internal();
  }
});

// node_modules/fp-ts/es6/Separated.js
var separated, _map, map, URI, Functor, flap2, left2, right2;
var init_Separated = __esm({
  "node_modules/fp-ts/es6/Separated.js"() {
    init_function();
    init_Functor();
    separated = function(left4, right4) {
      return { left: left4, right: right4 };
    };
    _map = function(fa, f) {
      return pipe(fa, map(f));
    };
    map = function(f) {
      return function(fa) {
        return separated(left2(fa), f(right2(fa)));
      };
    };
    URI = "Separated";
    Functor = {
      URI,
      map: _map
    };
    flap2 = flap(Functor);
    left2 = function(s) {
      return s.left;
    };
    right2 = function(s) {
      return s.right;
    };
  }
});

// node_modules/fp-ts/es6/Witherable.js
function wiltDefault(T, C) {
  return function(F) {
    var traverseF = T.traverse(F);
    return function(wa, f) {
      return F.map(traverseF(wa, f), C.separate);
    };
  };
}
function witherDefault(T, C) {
  return function(F) {
    var traverseF = T.traverse(F);
    return function(wa, f) {
      return F.map(traverseF(wa, f), C.compact);
    };
  };
}
function filterE(W) {
  return function(F) {
    var witherF = W.wither(F);
    return function(predicate) {
      return function(ga) {
        return witherF(ga, function(a) {
          return F.map(predicate(a), function(b) {
            return b ? some(a) : none;
          });
        });
      };
    };
  };
}
var init_Witherable = __esm({
  "node_modules/fp-ts/es6/Witherable.js"() {
    init_internal();
  }
});

// node_modules/fp-ts/es6/Either.js
var Either_exports = {};
__export(Either_exports, {
  Alt: () => Alt,
  ApT: () => ApT,
  Applicative: () => Applicative,
  Apply: () => Apply,
  Bifunctor: () => Bifunctor,
  Chain: () => Chain,
  ChainRec: () => ChainRec,
  Do: () => Do,
  Extend: () => Extend,
  Foldable: () => Foldable,
  FromEither: () => FromEither,
  Functor: () => Functor2,
  Monad: () => Monad,
  MonadThrow: () => MonadThrow,
  Pointed: () => Pointed,
  Traversable: () => Traversable,
  URI: () => URI2,
  alt: () => alt,
  altW: () => altW,
  ap: () => ap2,
  apFirst: () => apFirst2,
  apFirstW: () => apFirstW,
  apS: () => apS2,
  apSW: () => apSW,
  apSecond: () => apSecond2,
  apSecondW: () => apSecondW,
  apW: () => apW,
  bimap: () => bimap,
  bind: () => bind2,
  bindTo: () => bindTo2,
  bindW: () => bindW,
  chain: () => chain,
  chainFirst: () => chainFirst2,
  chainFirstW: () => chainFirstW,
  chainNullableK: () => chainNullableK,
  chainOptionK: () => chainOptionK2,
  chainW: () => chainW,
  duplicate: () => duplicate,
  either: () => either,
  elem: () => elem,
  exists: () => exists,
  extend: () => extend,
  filterOrElse: () => filterOrElse2,
  filterOrElseW: () => filterOrElseW,
  flap: () => flap3,
  flatten: () => flatten,
  flattenW: () => flattenW,
  fold: () => fold,
  foldMap: () => foldMap,
  foldW: () => foldW,
  fromNullable: () => fromNullable,
  fromNullableK: () => fromNullableK,
  fromOption: () => fromOption2,
  fromOptionK: () => fromOptionK2,
  fromPredicate: () => fromPredicate2,
  getAltValidation: () => getAltValidation,
  getApplicativeValidation: () => getApplicativeValidation,
  getApplyMonoid: () => getApplyMonoid,
  getApplySemigroup: () => getApplySemigroup2,
  getCompactable: () => getCompactable,
  getEq: () => getEq,
  getFilterable: () => getFilterable,
  getOrElse: () => getOrElse,
  getOrElseW: () => getOrElseW,
  getSemigroup: () => getSemigroup,
  getShow: () => getShow,
  getValidation: () => getValidation,
  getValidationMonoid: () => getValidationMonoid,
  getValidationSemigroup: () => getValidationSemigroup,
  getWitherable: () => getWitherable,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left3,
  map: () => map2,
  mapLeft: () => mapLeft,
  match: () => match,
  matchW: () => matchW,
  of: () => of,
  orElse: () => orElse,
  orElseW: () => orElseW,
  parseJSON: () => parseJSON,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  right: () => right3,
  sequence: () => sequence,
  sequenceArray: () => sequenceArray,
  stringifyJSON: () => stringifyJSON,
  swap: () => swap,
  throwError: () => throwError,
  toError: () => toError,
  toUnion: () => toUnion,
  traverse: () => traverse,
  traverseArray: () => traverseArray,
  traverseArrayWithIndex: () => traverseArrayWithIndex,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex,
  tryCatch: () => tryCatch,
  tryCatchK: () => tryCatchK
});
function toError(e) {
  return e instanceof Error ? e : new Error(String(e));
}
function elem(E) {
  return function(a, ma) {
    if (ma === void 0) {
      var elemE_1 = elem(E);
      return function(ma2) {
        return elemE_1(a, ma2);
      };
    }
    return isLeft2(ma) ? false : E.equals(a, ma.right);
  };
}
function parseJSON(s, onError) {
  return tryCatch(function() {
    return JSON.parse(s);
  }, onError);
}
function getValidation(SE) {
  var ap8 = getApplicativeValidation(SE).ap;
  var alt5 = getAltValidation(SE).alt;
  return {
    URI: URI2,
    _E: void 0,
    map: _map2,
    of,
    chain: _chain,
    bimap: _bimap,
    mapLeft: _mapLeft,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    extend: _extend,
    traverse: _traverse,
    sequence,
    chainRec: _chainRec,
    throwError,
    ap: ap8,
    alt: alt5
  };
}
var left3, right3, _map2, _ap, _chain, _reduce, _foldMap, _reduceRight, _traverse, _bimap, _mapLeft, _alt, _extend, _chainRec, URI2, getShow, getEq, getSemigroup, getCompactable, getFilterable, getWitherable, getApplicativeValidation, getAltValidation, map2, Functor2, of, Pointed, apW, ap2, Apply, Applicative, chainW, chain, Chain, Monad, reduce, foldMap, reduceRight, Foldable, traverse, sequence, Traversable, bimap, mapLeft, Bifunctor, altW, alt, Alt, extend, Extend, ChainRec, throwError, MonadThrow, FromEither, fromPredicate2, fromOption2, isLeft2, isRight2, matchW, foldW, match, fold, getOrElseW, getOrElse, flap3, apFirst2, apFirstW, apSecond2, apSecondW, chainFirst2, chainFirstW, flattenW, flatten, duplicate, fromOptionK2, chainOptionK2, filterOrElse2, filterOrElseW, swap, orElseW, orElse, fromNullable, tryCatch, tryCatchK, fromNullableK, chainNullableK, toUnion, exists, Do, bindTo2, bind2, bindW, apS2, apSW, ApT, traverseReadonlyNonEmptyArrayWithIndex, traverseReadonlyArrayWithIndex, traverseArrayWithIndex, traverseArray, sequenceArray, stringifyJSON, either, getApplySemigroup2, getApplyMonoid, getValidationSemigroup, getValidationMonoid;
var init_Either = __esm({
  "node_modules/fp-ts/es6/Either.js"() {
    init_Applicative();
    init_Apply();
    init_Chain();
    init_ChainRec();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_Separated();
    init_Witherable();
    left3 = left;
    right3 = right;
    _map2 = function(fa, f) {
      return pipe(fa, map2(f));
    };
    _ap = function(fab, fa) {
      return pipe(fab, ap2(fa));
    };
    _chain = function(ma, f) {
      return pipe(ma, chain(f));
    };
    _reduce = function(fa, b, f) {
      return pipe(fa, reduce(b, f));
    };
    _foldMap = function(M) {
      return function(fa, f) {
        var foldMapM = foldMap(M);
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight = function(fa, b, f) {
      return pipe(fa, reduceRight(b, f));
    };
    _traverse = function(F) {
      var traverseF = traverse(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _bimap = function(fa, f, g) {
      return pipe(fa, bimap(f, g));
    };
    _mapLeft = function(fa, f) {
      return pipe(fa, mapLeft(f));
    };
    _alt = function(fa, that) {
      return pipe(fa, alt(that));
    };
    _extend = function(wa, f) {
      return pipe(wa, extend(f));
    };
    _chainRec = function(a, f) {
      return tailRec(f(a), function(e) {
        return isLeft2(e) ? right3(left3(e.left)) : isLeft2(e.right) ? left3(f(e.right.left)) : right3(right3(e.right.right));
      });
    };
    URI2 = "Either";
    getShow = function(SE, SA) {
      return {
        show: function(ma) {
          return isLeft2(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
        }
      };
    };
    getEq = function(EL, EA) {
      return {
        equals: function(x, y) {
          return x === y || (isLeft2(x) ? isLeft2(y) && EL.equals(x.left, y.left) : isRight2(y) && EA.equals(x.right, y.right));
        }
      };
    };
    getSemigroup = function(S) {
      return {
        concat: function(x, y) {
          return isLeft2(y) ? x : isLeft2(x) ? y : right3(S.concat(x.right, y.right));
        }
      };
    };
    getCompactable = function(M) {
      var empty7 = left3(M.empty);
      return {
        URI: URI2,
        _E: void 0,
        compact: function(ma) {
          return isLeft2(ma) ? ma : ma.right._tag === "None" ? empty7 : right3(ma.right.value);
        },
        separate: function(ma) {
          return isLeft2(ma) ? separated(ma, ma) : isLeft2(ma.right) ? separated(right3(ma.right.left), empty7) : separated(empty7, right3(ma.right.right));
        }
      };
    };
    getFilterable = function(M) {
      var empty7 = left3(M.empty);
      var _a = getCompactable(M), compact6 = _a.compact, separate6 = _a.separate;
      var filter7 = function(ma, predicate) {
        return isLeft2(ma) ? ma : predicate(ma.right) ? ma : empty7;
      };
      var partition6 = function(ma, p) {
        return isLeft2(ma) ? separated(ma, ma) : p(ma.right) ? separated(empty7, right3(ma.right)) : separated(right3(ma.right), empty7);
      };
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        compact: compact6,
        separate: separate6,
        filter: filter7,
        filterMap: function(ma, f) {
          if (isLeft2(ma)) {
            return ma;
          }
          var ob = f(ma.right);
          return ob._tag === "None" ? empty7 : right3(ob.value);
        },
        partition: partition6,
        partitionMap: function(ma, f) {
          if (isLeft2(ma)) {
            return separated(ma, ma);
          }
          var e = f(ma.right);
          return isLeft2(e) ? separated(right3(e.left), empty7) : separated(empty7, right3(e.right));
        }
      };
    };
    getWitherable = function(M) {
      var F_ = getFilterable(M);
      var C = getCompactable(M);
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse,
        sequence,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        wither: witherDefault(Traversable, C),
        wilt: wiltDefault(Traversable, C)
      };
    };
    getApplicativeValidation = function(SE) {
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return isLeft2(fab) ? isLeft2(fa) ? left3(SE.concat(fab.left, fa.left)) : fab : isLeft2(fa) ? fa : right3(fab.right(fa.right));
        },
        of
      };
    };
    getAltValidation = function(SE) {
      return {
        URI: URI2,
        _E: void 0,
        map: _map2,
        alt: function(me, that) {
          if (isRight2(me)) {
            return me;
          }
          var ea = that();
          return isLeft2(ea) ? left3(SE.concat(me.left, ea.left)) : ea;
        }
      };
    };
    map2 = function(f) {
      return function(fa) {
        return isLeft2(fa) ? fa : right3(f(fa.right));
      };
    };
    Functor2 = {
      URI: URI2,
      map: _map2
    };
    of = right3;
    Pointed = {
      URI: URI2,
      of
    };
    apW = function(fa) {
      return function(fab) {
        return isLeft2(fab) ? fab : isLeft2(fa) ? fa : right3(fab.right(fa.right));
      };
    };
    ap2 = apW;
    Apply = {
      URI: URI2,
      map: _map2,
      ap: _ap
    };
    Applicative = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of
    };
    chainW = function(f) {
      return function(ma) {
        return isLeft2(ma) ? ma : f(ma.right);
      };
    };
    chain = chainW;
    Chain = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      chain: _chain
    };
    Monad = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of,
      chain: _chain
    };
    reduce = function(b, f) {
      return function(fa) {
        return isLeft2(fa) ? b : f(b, fa.right);
      };
    };
    foldMap = function(M) {
      return function(f) {
        return function(fa) {
          return isLeft2(fa) ? M.empty : f(fa.right);
        };
      };
    };
    reduceRight = function(b, f) {
      return function(fa) {
        return isLeft2(fa) ? b : f(fa.right, b);
      };
    };
    Foldable = {
      URI: URI2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    traverse = function(F) {
      return function(f) {
        return function(ta) {
          return isLeft2(ta) ? F.of(left3(ta.left)) : F.map(f(ta.right), right3);
        };
      };
    };
    sequence = function(F) {
      return function(ma) {
        return isLeft2(ma) ? F.of(left3(ma.left)) : F.map(ma.right, right3);
      };
    };
    Traversable = {
      URI: URI2,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence
    };
    bimap = function(f, g) {
      return function(fa) {
        return isLeft2(fa) ? left3(f(fa.left)) : right3(g(fa.right));
      };
    };
    mapLeft = function(f) {
      return function(fa) {
        return isLeft2(fa) ? left3(f(fa.left)) : fa;
      };
    };
    Bifunctor = {
      URI: URI2,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    altW = function(that) {
      return function(fa) {
        return isLeft2(fa) ? that() : fa;
      };
    };
    alt = altW;
    Alt = {
      URI: URI2,
      map: _map2,
      alt: _alt
    };
    extend = function(f) {
      return function(wa) {
        return isLeft2(wa) ? wa : right3(f(wa));
      };
    };
    Extend = {
      URI: URI2,
      map: _map2,
      extend: _extend
    };
    ChainRec = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      chain: _chain,
      chainRec: _chainRec
    };
    throwError = left3;
    MonadThrow = {
      URI: URI2,
      map: _map2,
      ap: _ap,
      of,
      chain: _chain,
      throwError
    };
    FromEither = {
      URI: URI2,
      fromEither: identity
    };
    fromPredicate2 = fromPredicate(FromEither);
    fromOption2 = fromOption(FromEither);
    isLeft2 = isLeft;
    isRight2 = isRight;
    matchW = function(onLeft, onRight) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : onRight(ma.right);
      };
    };
    foldW = matchW;
    match = matchW;
    fold = match;
    getOrElseW = function(onLeft) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : ma.right;
      };
    };
    getOrElse = getOrElseW;
    flap3 = flap(Functor2);
    apFirst2 = apFirst(Apply);
    apFirstW = apFirst2;
    apSecond2 = apSecond(Apply);
    apSecondW = apSecond2;
    chainFirst2 = chainFirst(Chain);
    chainFirstW = chainFirst2;
    flattenW = chainW(identity);
    flatten = flattenW;
    duplicate = extend(identity);
    fromOptionK2 = fromOptionK(FromEither);
    chainOptionK2 = chainOptionK(FromEither, Chain);
    filterOrElse2 = filterOrElse(FromEither, Chain);
    filterOrElseW = filterOrElse2;
    swap = function(ma) {
      return isLeft2(ma) ? right3(ma.left) : left3(ma.right);
    };
    orElseW = function(onLeft) {
      return function(ma) {
        return isLeft2(ma) ? onLeft(ma.left) : ma;
      };
    };
    orElse = orElseW;
    fromNullable = function(e) {
      return function(a) {
        return a == null ? left3(e) : right3(a);
      };
    };
    tryCatch = function(f, onThrow) {
      try {
        return right3(f());
      } catch (e) {
        return left3(onThrow(e));
      }
    };
    tryCatchK = function(f, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return tryCatch(function() {
          return f.apply(void 0, a);
        }, onThrow);
      };
    };
    fromNullableK = function(e) {
      var from = fromNullable(e);
      return function(f) {
        return flow(f, from);
      };
    };
    chainNullableK = function(e) {
      var from = fromNullableK(e);
      return function(f) {
        return chain(from(f));
      };
    };
    toUnion = foldW(identity, identity);
    exists = function(predicate) {
      return function(ma) {
        return isLeft2(ma) ? false : predicate(ma.right);
      };
    };
    Do = of(emptyRecord);
    bindTo2 = bindTo(Functor2);
    bind2 = bind(Chain);
    bindW = bind2;
    apS2 = apS(Apply);
    apSW = apS2;
    ApT = of(emptyReadonlyArray);
    traverseReadonlyNonEmptyArrayWithIndex = function(f) {
      return function(as) {
        var e = f(0, head(as));
        if (isLeft2(e)) {
          return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
          var e_1 = f(i, as[i]);
          if (isLeft2(e_1)) {
            return e_1;
          }
          out.push(e_1.right);
        }
        return right3(out);
      };
    };
    traverseReadonlyArrayWithIndex = function(f) {
      var g = traverseReadonlyNonEmptyArrayWithIndex(f);
      return function(as) {
        return isNonEmpty(as) ? g(as) : ApT;
      };
    };
    traverseArrayWithIndex = traverseReadonlyArrayWithIndex;
    traverseArray = function(f) {
      return traverseReadonlyArrayWithIndex(function(_, a) {
        return f(a);
      });
    };
    sequenceArray = traverseArray(identity);
    stringifyJSON = function(u, onError) {
      return tryCatch(function() {
        var s = JSON.stringify(u);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, onError);
    };
    either = {
      URI: URI2,
      map: _map2,
      of,
      ap: _ap,
      chain: _chain,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence,
      bimap: _bimap,
      mapLeft: _mapLeft,
      alt: _alt,
      extend: _extend,
      chainRec: _chainRec,
      throwError
    };
    getApplySemigroup2 = getApplySemigroup(Apply);
    getApplyMonoid = getApplicativeMonoid(Applicative);
    getValidationSemigroup = function(SE, SA) {
      return getApplySemigroup(getApplicativeValidation(SE))(SA);
    };
    getValidationMonoid = function(SE, MA) {
      return getApplicativeMonoid(getApplicativeValidation(SE))(MA);
    };
  }
});

// node_modules/io-ts/es6/index.js
var es6_exports = {};
__export(es6_exports, {
  AnyArrayType: () => AnyArrayType,
  AnyDictionaryType: () => AnyDictionaryType,
  AnyType: () => AnyType,
  Array: () => UnknownArray,
  ArrayType: () => ArrayType,
  BigIntType: () => BigIntType,
  BooleanType: () => BooleanType,
  Dictionary: () => Dictionary,
  DictionaryType: () => DictionaryType,
  ExactType: () => ExactType,
  Function: () => Function,
  FunctionType: () => FunctionType,
  Int: () => Int,
  Integer: () => Integer,
  InterfaceType: () => InterfaceType,
  IntersectionType: () => IntersectionType,
  KeyofType: () => KeyofType,
  LiteralType: () => LiteralType,
  NeverType: () => NeverType,
  NullType: () => NullType,
  NumberType: () => NumberType,
  ObjectType: () => ObjectType,
  PartialType: () => PartialType,
  ReadonlyArrayType: () => ReadonlyArrayType,
  ReadonlyType: () => ReadonlyType,
  RecursiveType: () => RecursiveType,
  RefinementType: () => RefinementType,
  StrictType: () => StrictType,
  StringType: () => StringType,
  TaggedUnionType: () => TaggedUnionType,
  TupleType: () => TupleType,
  Type: () => Type,
  UndefinedType: () => UndefinedType,
  UnionType: () => UnionType,
  UnknownArray: () => UnknownArray,
  UnknownRecord: () => UnknownRecord,
  UnknownType: () => UnknownType,
  VoidType: () => VoidType,
  alias: () => alias,
  any: () => any,
  appendContext: () => appendContext,
  array: () => array,
  bigint: () => bigint,
  boolean: () => boolean,
  brand: () => brand,
  clean: () => clean,
  dictionary: () => dictionary,
  emptyTags: () => emptyTags,
  exact: () => exact,
  failure: () => failure,
  failures: () => failures,
  getContextEntry: () => getContextEntry,
  getDefaultContext: () => getDefaultContext,
  getDomainKeys: () => getDomainKeys,
  getFunctionName: () => getFunctionName,
  getIndex: () => getIndex,
  getTags: () => getTags,
  getValidationError: () => getValidationError,
  identity: () => identity2,
  interface: () => type,
  intersection: () => intersection,
  keyof: () => keyof,
  literal: () => literal,
  mergeAll: () => mergeAll,
  never: () => never,
  null: () => nullType,
  nullType: () => nullType,
  number: () => number,
  object: () => object,
  partial: () => partial,
  readonly: () => readonly,
  readonlyArray: () => readonlyArray,
  record: () => record,
  recursion: () => recursion,
  refinement: () => refinement,
  strict: () => strict,
  string: () => string,
  success: () => success,
  taggedUnion: () => taggedUnion,
  tuple: () => tuple2,
  type: () => type,
  undefined: () => undefinedType,
  union: () => union,
  unknown: () => unknown,
  void: () => voidType,
  voidType: () => voidType
});
function getFunctionName(f) {
  return f.displayName || f.name || "<function".concat(f.length, ">");
}
function getContextEntry(key, decoder) {
  return { key, type: decoder };
}
function appendContext(c, key, decoder, actual) {
  var len = c.length;
  var r = Array(len + 1);
  for (var i = 0; i < len; i++) {
    r[i] = c[i];
  }
  r[len] = { key, type: decoder, actual };
  return r;
}
function pushAll(xs, ys) {
  var l = ys.length;
  for (var i = 0; i < l; i++) {
    xs.push(ys[i]);
  }
}
function getNameFromProps(props) {
  return Object.keys(props).map(function(k) {
    return "".concat(k, ": ").concat(props[k].name);
  }).join(", ");
}
function useIdentity(codecs) {
  for (var i = 0; i < codecs.length; i++) {
    if (codecs[i].encode !== identity2) {
      return false;
    }
  }
  return true;
}
function getInterfaceTypeName(props) {
  return "{ ".concat(getNameFromProps(props), " }");
}
function getPartialTypeName(inner) {
  return "Partial<".concat(inner, ">");
}
function enumerableRecord(keys3, domain, codomain, name) {
  if (name === void 0) {
    name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
  }
  var len = keys3.length;
  return new DictionaryType(name, function(u) {
    return UnknownRecord.is(u) && keys3.every(function(k) {
      return codomain.is(u[k]);
    });
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = {};
    var errors = [];
    var changed = false;
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ok = o[k];
      var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
      if (isLeft2(codomainResult)) {
        pushAll(errors, codomainResult.left);
      } else {
        var vok = codomainResult.right;
        changed = changed || vok !== ok;
        a[k] = vok;
      }
    }
    return errors.length > 0 ? failures(errors) : success(changed || Object.keys(o).length !== len ? a : o);
  }, codomain.encode === identity2 ? identity2 : function(a) {
    var s = {};
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      s[k] = codomain.encode(a[k]);
    }
    return s;
  }, domain, codomain);
}
function getDomainKeys(domain) {
  var _a;
  if (isLiteralC(domain)) {
    var literal_1 = domain.value;
    if (string.is(literal_1)) {
      return _a = {}, _a[literal_1] = null, _a;
    }
  } else if (isKeyofC(domain)) {
    return domain.keys;
  } else if (isUnionC(domain)) {
    var keys3 = domain.types.map(function(type2) {
      return getDomainKeys(type2);
    });
    return keys3.some(undefinedType.is) ? void 0 : Object.assign.apply(Object, __spreadArray2([{}], keys3, false));
  }
  return void 0;
}
function nonEnumerableRecord(domain, codomain, name) {
  if (name === void 0) {
    name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
  }
  return new DictionaryType(name, function(u) {
    if (UnknownRecord.is(u)) {
      return Object.keys(u).every(function(k) {
        return domain.is(k) && codomain.is(u[k]);
      });
    }
    return isAnyC(codomain) && Array.isArray(u);
  }, function(u, c) {
    if (UnknownRecord.is(u)) {
      var a = {};
      var errors = [];
      var keys3 = Object.keys(u);
      var len = keys3.length;
      var changed = false;
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var ok = u[k];
        var domainResult = domain.validate(k, appendContext(c, k, domain, k));
        if (isLeft2(domainResult)) {
          pushAll(errors, domainResult.left);
        } else {
          var vk = domainResult.right;
          changed = changed || vk !== k;
          k = vk;
          var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
          if (isLeft2(codomainResult)) {
            pushAll(errors, codomainResult.left);
          } else {
            var vok = codomainResult.right;
            changed = changed || vok !== ok;
            a[k] = vok;
          }
        }
      }
      return errors.length > 0 ? failures(errors) : success(changed ? a : u);
    }
    if (isAnyC(codomain) && Array.isArray(u)) {
      return success(u);
    }
    return failure(u, c);
  }, domain.encode === identity2 && codomain.encode === identity2 ? identity2 : function(a) {
    var s = {};
    var keys3 = Object.keys(a);
    var len = keys3.length;
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      s[String(domain.encode(k))] = codomain.encode(a[k]);
    }
    return s;
  }, domain, codomain);
}
function getUnionName(codecs) {
  return "(" + codecs.map(function(type2) {
    return type2.name;
  }).join(" | ") + ")";
}
function mergeAll(base, us) {
  var equal = true;
  var primitive = true;
  var baseIsNotADictionary = !UnknownRecord.is(base);
  for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
    var u = us_1[_i];
    if (u !== base) {
      equal = false;
    }
    if (UnknownRecord.is(u)) {
      primitive = false;
    }
  }
  if (equal) {
    return base;
  } else if (primitive) {
    return us[us.length - 1];
  }
  var r = {};
  for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
    var u = us_2[_a];
    for (var k in u) {
      if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
        r[k] = u[k];
      }
    }
  }
  return r;
}
function getProps(codec) {
  switch (codec._tag) {
    case "RefinementType":
    case "ReadonlyType":
      return getProps(codec.type);
    case "InterfaceType":
    case "StrictType":
    case "PartialType":
      return codec.props;
    case "IntersectionType":
      return codec.types.reduce(function(props, type2) {
        return Object.assign(props, getProps(type2));
      }, {});
  }
}
function stripKeys(o, props) {
  var keys3 = Object.getOwnPropertyNames(o);
  var shouldStrip = false;
  var r = {};
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (!hasOwnProperty.call(props, key)) {
      shouldStrip = true;
    } else {
      r[key] = o[key];
    }
  }
  return shouldStrip ? r : o;
}
function getExactTypeName(codec) {
  if (isTypeC(codec)) {
    return "{| ".concat(getNameFromProps(codec.props), " |}");
  } else if (isPartialC(codec)) {
    return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
  }
  return "Exact<".concat(codec.name, ">");
}
function isNonEmpty2(as) {
  return as.length > 0;
}
function intersect(a, b) {
  var r = [];
  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
    var v = a_1[_i];
    if (b.indexOf(v) !== -1) {
      r.push(v);
    }
  }
  return r;
}
function mergeTags(a, b) {
  if (a === emptyTags) {
    return b;
  }
  if (b === emptyTags) {
    return a;
  }
  var r = Object.assign({}, a);
  for (var k in b) {
    if (hasOwnProperty.call(a, k)) {
      var intersection_1 = intersect(a[k], b[k]);
      if (isNonEmpty2(intersection_1)) {
        r[k] = intersection_1;
      } else {
        r = emptyTags;
        break;
      }
    } else {
      r[k] = b[k];
    }
  }
  return r;
}
function intersectTags(a, b) {
  if (a === emptyTags || b === emptyTags) {
    return emptyTags;
  }
  var r = emptyTags;
  for (var k in a) {
    if (hasOwnProperty.call(b, k)) {
      var intersection_2 = intersect(a[k], b[k]);
      if (intersection_2.length === 0) {
        if (r === emptyTags) {
          r = {};
        }
        r[k] = a[k].concat(b[k]);
      }
    }
  }
  return r;
}
function isAnyC(codec) {
  return codec._tag === "AnyType";
}
function isLiteralC(codec) {
  return codec._tag === "LiteralType";
}
function isKeyofC(codec) {
  return codec._tag === "KeyofType";
}
function isTypeC(codec) {
  return codec._tag === "InterfaceType";
}
function isPartialC(codec) {
  return codec._tag === "PartialType";
}
function isStrictC(codec) {
  return codec._tag === "StrictType";
}
function isExactC(codec) {
  return codec._tag === "ExactType";
}
function isRefinementC(codec) {
  return codec._tag === "RefinementType";
}
function isIntersectionC(codec) {
  return codec._tag === "IntersectionType";
}
function isUnionC(codec) {
  return codec._tag === "UnionType";
}
function isRecursiveC(codec) {
  return codec._tag === "RecursiveType";
}
function getTags(codec) {
  if (lazyCodecs.indexOf(codec) !== -1) {
    return emptyTags;
  }
  if (isTypeC(codec) || isStrictC(codec)) {
    var index = emptyTags;
    for (var k in codec.props) {
      var prop = codec.props[k];
      if (isLiteralC(prop)) {
        if (index === emptyTags) {
          index = {};
        }
        index[k] = [prop.value];
      }
    }
    return index;
  } else if (isExactC(codec) || isRefinementC(codec)) {
    return getTags(codec.type);
  } else if (isIntersectionC(codec)) {
    return codec.types.reduce(function(tags2, codec2) {
      return mergeTags(tags2, getTags(codec2));
    }, emptyTags);
  } else if (isUnionC(codec)) {
    return codec.types.slice(1).reduce(function(tags2, codec2) {
      return intersectTags(tags2, getTags(codec2));
    }, getTags(codec.types[0]));
  } else if (isRecursiveC(codec)) {
    lazyCodecs.push(codec);
    var tags = getTags(codec.type);
    lazyCodecs.pop();
    return tags;
  }
  return emptyTags;
}
function getIndex(codecs) {
  var tags = getTags(codecs[0]);
  var keys3 = Object.keys(tags);
  var len = codecs.length;
  var _loop_1 = function(k2) {
    var all = tags[k2].slice();
    var index = [tags[k2]];
    for (var i = 1; i < len; i++) {
      var codec = codecs[i];
      var ctags = getTags(codec);
      var values = ctags[k2];
      if (values === void 0) {
        return "continue-keys";
      } else {
        if (values.some(function(v) {
          return all.indexOf(v) !== -1;
        })) {
          return "continue-keys";
        } else {
          all.push.apply(all, values);
          index.push(values);
        }
      }
    }
    return { value: [k2, index] };
  };
  keys:
    for (var _i = 0, keys_1 = keys3; _i < keys_1.length; _i++) {
      var k = keys_1[_i];
      var state_1 = _loop_1(k);
      if (typeof state_1 === "object")
        return state_1.value;
      switch (state_1) {
        case "continue-keys":
          continue keys;
      }
    }
  return void 0;
}
function literal(value, name) {
  if (name === void 0) {
    name = JSON.stringify(value);
  }
  var is = function(u) {
    return u === value;
  };
  return new LiteralType(name, is, function(u, c) {
    return is(u) ? success(value) : failure(u, c);
  }, identity2, value);
}
function keyof(keys3, name) {
  if (name === void 0) {
    name = Object.keys(keys3).map(function(k) {
      return JSON.stringify(k);
    }).join(" | ");
  }
  var is = function(u) {
    return string.is(u) && hasOwnProperty.call(keys3, u);
  };
  return new KeyofType(name, is, function(u, c) {
    return is(u) ? success(u) : failure(u, c);
  }, identity2, keys3);
}
function brand(codec, predicate, name) {
  return refinement(codec, predicate, name);
}
function recursion(name, definition) {
  var cache;
  var runDefinition = function() {
    if (!cache) {
      cache = definition(Self);
      cache.name = name;
    }
    return cache;
  };
  var Self = new RecursiveType(name, function(u) {
    return runDefinition().is(u);
  }, function(u, c) {
    return runDefinition().validate(u, c);
  }, function(a) {
    return runDefinition().encode(a);
  }, runDefinition);
  return Self;
}
function array(item, name) {
  if (name === void 0) {
    name = "Array<".concat(item.name, ">");
  }
  return new ArrayType(name, function(u) {
    return UnknownArray.is(u) && u.every(item.is);
  }, function(u, c) {
    var e = UnknownArray.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var us = e.right;
    var len = us.length;
    var as = us;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var ui = us[i];
      var result = item.validate(ui, appendContext(c, String(i), item, ui));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var ai = result.right;
        if (ai !== ui) {
          if (as === us) {
            as = us.slice();
          }
          as[i] = ai;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(as);
  }, item.encode === identity2 ? identity2 : function(a) {
    return a.map(item.encode);
  }, item);
}
function type(props, name) {
  if (name === void 0) {
    name = getInterfaceTypeName(props);
  }
  var keys3 = Object.keys(props);
  var types = keys3.map(function(key) {
    return props[key];
  });
  var len = keys3.length;
  return new InterfaceType(name, function(u) {
    if (UnknownRecord.is(u)) {
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var uk = u[k];
        if (uk === void 0 && !hasOwnProperty.call(u, k) || !types[i].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = o;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      var type_1 = types[i];
      var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var vak = result.right;
        if (vak !== ak || vak === void 0 && !hasOwnProperty.call(a, k)) {
          if (a === o) {
            a = __assign({}, o);
          }
          a[k] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a);
  }, useIdentity(types) ? identity2 : function(a) {
    var s = __assign({}, a);
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var encode = types[i].encode;
      if (encode !== identity2) {
        s[k] = encode(a[k]);
      }
    }
    return s;
  }, props);
}
function partial(props, name) {
  if (name === void 0) {
    name = getPartialTypeName(getInterfaceTypeName(props));
  }
  var keys3 = Object.keys(props);
  var types = keys3.map(function(key) {
    return props[key];
  });
  var len = keys3.length;
  return new PartialType(name, function(u) {
    if (UnknownRecord.is(u)) {
      for (var i = 0; i < len; i++) {
        var k = keys3[i];
        var uk = u[k];
        if (uk !== void 0 && !props[k].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var o = e.right;
    var a = o;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      var type_2 = props[k];
      var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
      if (isLeft2(result)) {
        if (ak !== void 0) {
          pushAll(errors, result.left);
        }
      } else {
        var vak = result.right;
        if (vak !== ak) {
          if (a === o) {
            a = __assign({}, o);
          }
          a[k] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a);
  }, useIdentity(types) ? identity2 : function(a) {
    var s = __assign({}, a);
    for (var i = 0; i < len; i++) {
      var k = keys3[i];
      var ak = a[k];
      if (ak !== void 0) {
        s[k] = types[i].encode(ak);
      }
    }
    return s;
  }, props);
}
function record(domain, codomain, name) {
  var keys3 = getDomainKeys(domain);
  return keys3 ? enumerableRecord(Object.keys(keys3), domain, codomain, name) : nonEnumerableRecord(domain, codomain, name);
}
function union(codecs, name) {
  if (name === void 0) {
    name = getUnionName(codecs);
  }
  var index = getIndex(codecs);
  if (index !== void 0 && codecs.length > 0) {
    var tag_1 = index[0], groups_1 = index[1];
    var len_1 = groups_1.length;
    var find_1 = function(value) {
      for (var i = 0; i < len_1; i++) {
        if (groups_1[i].indexOf(value) !== -1) {
          return i;
        }
      }
      return void 0;
    };
    return new TaggedUnionType(name, function(u) {
      if (UnknownRecord.is(u)) {
        var i = find_1(u[tag_1]);
        return i !== void 0 ? codecs[i].is(u) : false;
      }
      return false;
    }, function(u, c) {
      var e = UnknownRecord.validate(u, c);
      if (isLeft2(e)) {
        return e;
      }
      var r = e.right;
      var i = find_1(r[tag_1]);
      if (i === void 0) {
        return failure(u, c);
      }
      var codec = codecs[i];
      return codec.validate(r, appendContext(c, String(i), codec, r));
    }, useIdentity(codecs) ? identity2 : function(a) {
      var i = find_1(a[tag_1]);
      if (i === void 0) {
        throw new Error("no codec found to encode value in union codec ".concat(name));
      } else {
        return codecs[i].encode(a);
      }
    }, codecs, tag_1);
  } else {
    return new UnionType(name, function(u) {
      return codecs.some(function(type2) {
        return type2.is(u);
      });
    }, function(u, c) {
      var errors = [];
      for (var i = 0; i < codecs.length; i++) {
        var codec = codecs[i];
        var result = codec.validate(u, appendContext(c, String(i), codec, u));
        if (isLeft2(result)) {
          pushAll(errors, result.left);
        } else {
          return success(result.right);
        }
      }
      return failures(errors);
    }, useIdentity(codecs) ? identity2 : function(a) {
      for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
        var codec = codecs_1[_i];
        if (codec.is(a)) {
          return codec.encode(a);
        }
      }
      throw new Error("no codec found to encode value in union type ".concat(name));
    }, codecs);
  }
}
function intersection(codecs, name) {
  if (name === void 0) {
    name = "(".concat(codecs.map(function(type2) {
      return type2.name;
    }).join(" & "), ")");
  }
  var len = codecs.length;
  return new IntersectionType(name, function(u) {
    return codecs.every(function(type2) {
      return type2.is(u);
    });
  }, codecs.length === 0 ? success : function(u, c) {
    var us = [];
    var errors = [];
    for (var i = 0; i < len; i++) {
      var codec = codecs[i];
      var result = codec.validate(u, appendContext(c, String(i), codec, u));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        us.push(result.right);
      }
    }
    return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));
  }, codecs.length === 0 ? identity2 : function(a) {
    return mergeAll(a, codecs.map(function(codec) {
      return codec.encode(a);
    }));
  }, codecs);
}
function tuple2(codecs, name) {
  if (name === void 0) {
    name = "[".concat(codecs.map(function(type2) {
      return type2.name;
    }).join(", "), "]");
  }
  var len = codecs.length;
  return new TupleType(name, function(u) {
    return UnknownArray.is(u) && u.length === len && codecs.every(function(type2, i) {
      return type2.is(u[i]);
    });
  }, function(u, c) {
    var e = UnknownArray.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var us = e.right;
    var as = us.length > len ? us.slice(0, len) : us;
    var errors = [];
    for (var i = 0; i < len; i++) {
      var a = us[i];
      var type_3 = codecs[i];
      var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var va = result.right;
        if (va !== a) {
          if (as === us) {
            as = us.slice();
          }
          as[i] = va;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(as);
  }, useIdentity(codecs) ? identity2 : function(a) {
    return codecs.map(function(type2, i) {
      return type2.encode(a[i]);
    });
  }, codecs);
}
function readonly(codec, name) {
  if (name === void 0) {
    name = "Readonly<".concat(codec.name, ">");
  }
  return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
}
function readonlyArray(item, name) {
  if (name === void 0) {
    name = "ReadonlyArray<".concat(item.name, ">");
  }
  var codec = array(item);
  return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
}
function exact(codec, name) {
  if (name === void 0) {
    name = getExactTypeName(codec);
  }
  var props = getProps(codec);
  return new ExactType(name, codec.is, function(u, c) {
    var e = UnknownRecord.validate(u, c);
    if (isLeft2(e)) {
      return e;
    }
    var ce = codec.validate(u, c);
    if (isLeft2(ce)) {
      return ce;
    }
    return right3(stripKeys(ce.right, props));
  }, function(a) {
    return codec.encode(stripKeys(a, props));
  }, codec);
}
function refinement(codec, predicate, name) {
  if (name === void 0) {
    name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
  }
  return new RefinementType(name, function(u) {
    return codec.is(u) && predicate(u);
  }, function(i, c) {
    var e = codec.validate(i, c);
    if (isLeft2(e)) {
      return e;
    }
    var a = e.right;
    return predicate(a) ? success(a) : failure(a, c);
  }, codec.encode, codec, predicate);
}
function clean(codec) {
  return codec;
}
function alias(codec) {
  return function() {
    return codec;
  };
}
var __extends, __assign, __spreadArray2, failures, failure, success, Type, identity2, hasOwnProperty, emptyTags, lazyCodecs, NullType, nullType, UndefinedType, undefinedType, VoidType, voidType, UnknownType, unknown, StringType, string, NumberType, number, BigIntType, bigint, BooleanType, boolean, AnyArrayType, UnknownArray, AnyDictionaryType, UnknownRecord, LiteralType, KeyofType, RefinementType, Int, RecursiveType, ArrayType, InterfaceType, PartialType, DictionaryType, UnionType, IntersectionType, TupleType, ReadonlyType, ReadonlyArrayType, strict, ExactType, FunctionType, Function, TaggedUnionType, taggedUnion, getValidationError, getDefaultContext, NeverType, never, AnyType, any, Dictionary, ObjectType, object, Integer, dictionary, StrictType;
var init_es6 = __esm({
  "node_modules/io-ts/es6/index.js"() {
    init_Either();
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    failures = left3;
    failure = function(value, context, message) {
      return failures([{ value, context, message }]);
    };
    success = right3;
    Type = function() {
      function Type2(name, is, validate, encode) {
        this.name = name;
        this.is = is;
        this.validate = validate;
        this.encode = encode;
        this.decode = this.decode.bind(this);
      }
      Type2.prototype.pipe = function(ab, name) {
        var _this = this;
        if (name === void 0) {
          name = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
        }
        return new Type2(name, ab.is, function(i, c) {
          var e = _this.validate(i, c);
          if (isLeft2(e)) {
            return e;
          }
          return ab.validate(e.right, c);
        }, this.encode === identity2 && ab.encode === identity2 ? identity2 : function(b) {
          return _this.encode(ab.encode(b));
        });
      };
      Type2.prototype.asDecoder = function() {
        return this;
      };
      Type2.prototype.asEncoder = function() {
        return this;
      };
      Type2.prototype.decode = function(i) {
        return this.validate(i, [{ key: "", type: this, actual: i }]);
      };
      return Type2;
    }();
    identity2 = function(a) {
      return a;
    };
    hasOwnProperty = Object.prototype.hasOwnProperty;
    emptyTags = {};
    lazyCodecs = [];
    NullType = function(_super) {
      __extends(NullType2, _super);
      function NullType2() {
        var _this = _super.call(this, "null", function(u) {
          return u === null;
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "NullType";
        return _this;
      }
      return NullType2;
    }(Type);
    nullType = new NullType();
    UndefinedType = function(_super) {
      __extends(UndefinedType2, _super);
      function UndefinedType2() {
        var _this = _super.call(this, "undefined", function(u) {
          return u === void 0;
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "UndefinedType";
        return _this;
      }
      return UndefinedType2;
    }(Type);
    undefinedType = new UndefinedType();
    VoidType = function(_super) {
      __extends(VoidType2, _super);
      function VoidType2() {
        var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, identity2) || this;
        _this._tag = "VoidType";
        return _this;
      }
      return VoidType2;
    }(Type);
    voidType = new VoidType();
    UnknownType = function(_super) {
      __extends(UnknownType2, _super);
      function UnknownType2() {
        var _this = _super.call(this, "unknown", function(_) {
          return true;
        }, success, identity2) || this;
        _this._tag = "UnknownType";
        return _this;
      }
      return UnknownType2;
    }(Type);
    unknown = new UnknownType();
    StringType = function(_super) {
      __extends(StringType2, _super);
      function StringType2() {
        var _this = _super.call(this, "string", function(u) {
          return typeof u === "string";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "StringType";
        return _this;
      }
      return StringType2;
    }(Type);
    string = new StringType();
    NumberType = function(_super) {
      __extends(NumberType2, _super);
      function NumberType2() {
        var _this = _super.call(this, "number", function(u) {
          return typeof u === "number";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "NumberType";
        return _this;
      }
      return NumberType2;
    }(Type);
    number = new NumberType();
    BigIntType = function(_super) {
      __extends(BigIntType2, _super);
      function BigIntType2() {
        var _this = _super.call(
          this,
          "bigint",
          function(u) {
            return typeof u === "bigint";
          },
          function(u, c) {
            return _this.is(u) ? success(u) : failure(u, c);
          },
          identity2
        ) || this;
        _this._tag = "BigIntType";
        return _this;
      }
      return BigIntType2;
    }(Type);
    bigint = new BigIntType();
    BooleanType = function(_super) {
      __extends(BooleanType2, _super);
      function BooleanType2() {
        var _this = _super.call(this, "boolean", function(u) {
          return typeof u === "boolean";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "BooleanType";
        return _this;
      }
      return BooleanType2;
    }(Type);
    boolean = new BooleanType();
    AnyArrayType = function(_super) {
      __extends(AnyArrayType2, _super);
      function AnyArrayType2() {
        var _this = _super.call(this, "UnknownArray", Array.isArray, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "AnyArrayType";
        return _this;
      }
      return AnyArrayType2;
    }(Type);
    UnknownArray = new AnyArrayType();
    AnyDictionaryType = function(_super) {
      __extends(AnyDictionaryType2, _super);
      function AnyDictionaryType2() {
        var _this = _super.call(this, "UnknownRecord", function(u) {
          var s = Object.prototype.toString.call(u);
          return s === "[object Object]" || s === "[object Window]";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "AnyDictionaryType";
        return _this;
      }
      return AnyDictionaryType2;
    }(Type);
    UnknownRecord = new AnyDictionaryType();
    LiteralType = function(_super) {
      __extends(LiteralType2, _super);
      function LiteralType2(name, is, validate, encode, value) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.value = value;
        _this._tag = "LiteralType";
        return _this;
      }
      return LiteralType2;
    }(Type);
    KeyofType = function(_super) {
      __extends(KeyofType2, _super);
      function KeyofType2(name, is, validate, encode, keys3) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.keys = keys3;
        _this._tag = "KeyofType";
        return _this;
      }
      return KeyofType2;
    }(Type);
    RefinementType = function(_super) {
      __extends(RefinementType2, _super);
      function RefinementType2(name, is, validate, encode, type2, predicate) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this.predicate = predicate;
        _this._tag = "RefinementType";
        return _this;
      }
      return RefinementType2;
    }(Type);
    Int = brand(number, function(n) {
      return Number.isInteger(n);
    }, "Int");
    RecursiveType = function(_super) {
      __extends(RecursiveType2, _super);
      function RecursiveType2(name, is, validate, encode, runDefinition) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.runDefinition = runDefinition;
        _this._tag = "RecursiveType";
        return _this;
      }
      return RecursiveType2;
    }(Type);
    Object.defineProperty(RecursiveType.prototype, "type", {
      get: function() {
        return this.runDefinition();
      },
      enumerable: true,
      configurable: true
    });
    ArrayType = function(_super) {
      __extends(ArrayType2, _super);
      function ArrayType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ArrayType";
        return _this;
      }
      return ArrayType2;
    }(Type);
    InterfaceType = function(_super) {
      __extends(InterfaceType2, _super);
      function InterfaceType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "InterfaceType";
        return _this;
      }
      return InterfaceType2;
    }(Type);
    PartialType = function(_super) {
      __extends(PartialType2, _super);
      function PartialType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "PartialType";
        return _this;
      }
      return PartialType2;
    }(Type);
    DictionaryType = function(_super) {
      __extends(DictionaryType2, _super);
      function DictionaryType2(name, is, validate, encode, domain, codomain) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.domain = domain;
        _this.codomain = codomain;
        _this._tag = "DictionaryType";
        return _this;
      }
      return DictionaryType2;
    }(Type);
    UnionType = function(_super) {
      __extends(UnionType2, _super);
      function UnionType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "UnionType";
        return _this;
      }
      return UnionType2;
    }(Type);
    IntersectionType = function(_super) {
      __extends(IntersectionType2, _super);
      function IntersectionType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "IntersectionType";
        return _this;
      }
      return IntersectionType2;
    }(Type);
    TupleType = function(_super) {
      __extends(TupleType2, _super);
      function TupleType2(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        _this._tag = "TupleType";
        return _this;
      }
      return TupleType2;
    }(Type);
    ReadonlyType = function(_super) {
      __extends(ReadonlyType2, _super);
      function ReadonlyType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ReadonlyType";
        return _this;
      }
      return ReadonlyType2;
    }(Type);
    ReadonlyArrayType = function(_super) {
      __extends(ReadonlyArrayType2, _super);
      function ReadonlyArrayType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ReadonlyArrayType";
        return _this;
      }
      return ReadonlyArrayType2;
    }(Type);
    strict = function(props, name) {
      return exact(type(props), name);
    };
    ExactType = function(_super) {
      __extends(ExactType2, _super);
      function ExactType2(name, is, validate, encode, type2) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type2;
        _this._tag = "ExactType";
        return _this;
      }
      return ExactType2;
    }(Type);
    FunctionType = function(_super) {
      __extends(FunctionType2, _super);
      function FunctionType2() {
        var _this = _super.call(
          this,
          "Function",
          function(u) {
            return typeof u === "function";
          },
          function(u, c) {
            return _this.is(u) ? success(u) : failure(u, c);
          },
          identity2
        ) || this;
        _this._tag = "FunctionType";
        return _this;
      }
      return FunctionType2;
    }(Type);
    Function = new FunctionType();
    TaggedUnionType = function(_super) {
      __extends(TaggedUnionType2, _super);
      function TaggedUnionType2(name, is, validate, encode, codecs, tag) {
        var _this = _super.call(this, name, is, validate, encode, codecs) || this;
        _this.tag = tag;
        return _this;
      }
      return TaggedUnionType2;
    }(UnionType);
    taggedUnion = function(tag, codecs, name) {
      if (name === void 0) {
        name = getUnionName(codecs);
      }
      var U = union(codecs, name);
      if (U instanceof TaggedUnionType) {
        return U;
      } else {
        console.warn("[io-ts] Cannot build a tagged union for ".concat(name, ", returning a de-optimized union"));
        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);
      }
    };
    getValidationError = function(value, context) {
      return {
        value,
        context
      };
    };
    getDefaultContext = function(decoder) {
      return [
        { key: "", type: decoder }
      ];
    };
    NeverType = function(_super) {
      __extends(NeverType2, _super);
      function NeverType2() {
        var _this = _super.call(
          this,
          "never",
          function(_) {
            return false;
          },
          function(u, c) {
            return failure(u, c);
          },
          function() {
            throw new Error("cannot encode never");
          }
        ) || this;
        _this._tag = "NeverType";
        return _this;
      }
      return NeverType2;
    }(Type);
    never = new NeverType();
    AnyType = function(_super) {
      __extends(AnyType2, _super);
      function AnyType2() {
        var _this = _super.call(this, "any", function(_) {
          return true;
        }, success, identity2) || this;
        _this._tag = "AnyType";
        return _this;
      }
      return AnyType2;
    }(Type);
    any = new AnyType();
    Dictionary = UnknownRecord;
    ObjectType = function(_super) {
      __extends(ObjectType2, _super);
      function ObjectType2() {
        var _this = _super.call(this, "object", function(u) {
          return u !== null && typeof u === "object";
        }, function(u, c) {
          return _this.is(u) ? success(u) : failure(u, c);
        }, identity2) || this;
        _this._tag = "ObjectType";
        return _this;
      }
      return ObjectType2;
    }(Type);
    object = new ObjectType();
    Integer = refinement(number, Number.isInteger, "Integer");
    dictionary = record;
    StrictType = function(_super) {
      __extends(StrictType2, _super);
      function StrictType2(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        _this._tag = "StrictType";
        return _this;
      }
      return StrictType2;
    }(Type);
  }
});

// node_modules/fp-ts/lib/function.js
var require_function = __commonJS({
  "node_modules/fp-ts/lib/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
    var getBooleanAlgebra = function(B) {
      return function() {
        return {
          meet: function(x, y) {
            return function(a) {
              return B.meet(x(a), y(a));
            };
          },
          join: function(x, y) {
            return function(a) {
              return B.join(x(a), y(a));
            };
          },
          zero: function() {
            return B.zero;
          },
          one: function() {
            return B.one;
          },
          implies: function(x, y) {
            return function(a) {
              return B.implies(x(a), y(a));
            };
          },
          not: function(x) {
            return function(a) {
              return B.not(x(a));
            };
          }
        };
      };
    };
    exports.getBooleanAlgebra = getBooleanAlgebra;
    var getSemigroup6 = function(S) {
      return function() {
        return {
          concat: function(f, g) {
            return function(a) {
              return S.concat(f(a), g(a));
            };
          }
        };
      };
    };
    exports.getSemigroup = getSemigroup6;
    var getMonoid6 = function(M) {
      var getSemigroupM = (0, exports.getSemigroup)(M);
      return function() {
        return {
          concat: getSemigroupM().concat,
          empty: function() {
            return M.empty;
          }
        };
      };
    };
    exports.getMonoid = getMonoid6;
    var getSemiring = function(S) {
      return {
        add: function(f, g) {
          return function(x) {
            return S.add(f(x), g(x));
          };
        },
        zero: function() {
          return S.zero;
        },
        mul: function(f, g) {
          return function(x) {
            return S.mul(f(x), g(x));
          };
        },
        one: function() {
          return S.one;
        }
      };
    };
    exports.getSemiring = getSemiring;
    var getRing = function(R) {
      var S = (0, exports.getSemiring)(R);
      return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function(f, g) {
          return function(x) {
            return R.sub(f(x), g(x));
          };
        }
      };
    };
    exports.getRing = getRing;
    var apply = function(a) {
      return function(f) {
        return f(a);
      };
    };
    exports.apply = apply;
    function identity3(a) {
      return a;
    }
    exports.identity = identity3;
    exports.unsafeCoerce = identity3;
    function constant3(a) {
      return function() {
        return a;
      };
    }
    exports.constant = constant3;
    exports.constTrue = constant3(true);
    exports.constFalse = constant3(false);
    exports.constNull = constant3(null);
    exports.constUndefined = constant3(void 0);
    exports.constVoid = exports.constUndefined;
    function flip(f) {
      return function(b, a) {
        return f(a, b);
      };
    }
    exports.flip = flip;
    function flow2(ab, bc, cd, de, ef, fg, gh, hi, ij) {
      switch (arguments.length) {
        case 1:
          return ab;
        case 2:
          return function() {
            return bc(ab.apply(this, arguments));
          };
        case 3:
          return function() {
            return cd(bc(ab.apply(this, arguments)));
          };
        case 4:
          return function() {
            return de(cd(bc(ab.apply(this, arguments))));
          };
        case 5:
          return function() {
            return ef(de(cd(bc(ab.apply(this, arguments)))));
          };
        case 6:
          return function() {
            return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
          };
        case 7:
          return function() {
            return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
          };
        case 8:
          return function() {
            return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
          };
        case 9:
          return function() {
            return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
          };
      }
      return;
    }
    exports.flow = flow2;
    function tuple3() {
      var t = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        t[_i] = arguments[_i];
      }
      return t;
    }
    exports.tuple = tuple3;
    function increment(n) {
      return n + 1;
    }
    exports.increment = increment;
    function decrement(n) {
      return n - 1;
    }
    exports.decrement = decrement;
    function absurd(_) {
      throw new Error("Called `absurd` function which should be uncallable");
    }
    exports.absurd = absurd;
    function tupled(f) {
      return function(a) {
        return f.apply(void 0, a);
      };
    }
    exports.tupled = tupled;
    function untupled(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return f(a);
      };
    }
    exports.untupled = untupled;
    function pipe3(a, ab, bc, cd, de, ef, fg, gh, hi) {
      switch (arguments.length) {
        case 1:
          return a;
        case 2:
          return ab(a);
        case 3:
          return bc(ab(a));
        case 4:
          return cd(bc(ab(a)));
        case 5:
          return de(cd(bc(ab(a))));
        case 6:
          return ef(de(cd(bc(ab(a)))));
        case 7:
          return fg(ef(de(cd(bc(ab(a))))));
        case 8:
          return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
          return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default: {
          var ret = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            ret = arguments[i](ret);
          }
          return ret;
        }
      }
    }
    exports.pipe = pipe3;
    exports.hole = absurd;
    var SK2 = function(_, b) {
      return b;
    };
    exports.SK = SK2;
    function not2(predicate) {
      return function(a) {
        return !predicate(a);
      };
    }
    exports.not = not2;
    var getEndomorphismMonoid = function() {
      return {
        concat: function(first2, second) {
          return flow2(first2, second);
        },
        empty: identity3
      };
    };
    exports.getEndomorphismMonoid = getEndomorphismMonoid;
  }
});

// node_modules/fp-ts/lib/internal.js
var require_internal = __commonJS({
  "node_modules/fp-ts/lib/internal.js"(exports) {
    "use strict";
    var __spreadArray6 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
    var isNone3 = function(fa) {
      return fa._tag === "None";
    };
    exports.isNone = isNone3;
    var isSome3 = function(fa) {
      return fa._tag === "Some";
    };
    exports.isSome = isSome3;
    exports.none = { _tag: "None" };
    var some6 = function(a) {
      return { _tag: "Some", value: a };
    };
    exports.some = some6;
    var isLeft3 = function(ma) {
      return ma._tag === "Left";
    };
    exports.isLeft = isLeft3;
    var isRight3 = function(ma) {
      return ma._tag === "Right";
    };
    exports.isRight = isRight3;
    var left4 = function(e) {
      return { _tag: "Left", left: e };
    };
    exports.left = left4;
    var right4 = function(a) {
      return { _tag: "Right", right: a };
    };
    exports.right = right4;
    var singleton4 = function(a) {
      return [a];
    };
    exports.singleton = singleton4;
    var isNonEmpty7 = function(as) {
      return as.length > 0;
    };
    exports.isNonEmpty = isNonEmpty7;
    var head6 = function(as) {
      return as[0];
    };
    exports.head = head6;
    var tail5 = function(as) {
      return as.slice(1);
    };
    exports.tail = tail5;
    exports.emptyReadonlyArray = [];
    exports.emptyRecord = {};
    exports.has = Object.prototype.hasOwnProperty;
    var fromReadonlyNonEmptyArray3 = function(as) {
      return __spreadArray6([as[0]], as.slice(1), true);
    };
    exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray3;
  }
});

// node_modules/fp-ts/lib/Apply.js
var require_Apply = __commonJS({
  "node_modules/fp-ts/lib/Apply.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceS = exports.sequenceT = exports.getApplySemigroup = exports.apS = exports.apSecond = exports.apFirst = exports.ap = void 0;
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function ap8(F, G) {
      return function(fa) {
        return function(fab) {
          return F.ap(F.map(fab, function(gab) {
            return function(ga) {
              return G.ap(gab, ga);
            };
          }), fa);
        };
      };
    }
    exports.ap = ap8;
    function apFirst8(A) {
      return function(second) {
        return function(first2) {
          return A.ap(A.map(first2, function(a) {
            return function() {
              return a;
            };
          }), second);
        };
      };
    }
    exports.apFirst = apFirst8;
    function apSecond8(A) {
      return function(second) {
        return function(first2) {
          return A.ap(A.map(first2, function() {
            return function(b) {
              return b;
            };
          }), second);
        };
      };
    }
    exports.apSecond = apSecond8;
    function apS8(F) {
      return function(name, fb) {
        return function(fa) {
          return F.ap(F.map(fa, function(a) {
            return function(b) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            };
          }), fb);
        };
      };
    }
    exports.apS = apS8;
    function getApplySemigroup4(F) {
      return function(S) {
        return {
          concat: function(first2, second) {
            return F.ap(F.map(first2, function(x) {
              return function(y) {
                return S.concat(x, y);
              };
            }), second);
          }
        };
      };
    }
    exports.getApplySemigroup = getApplySemigroup4;
    function curried(f, n, acc) {
      return function(x) {
        var combined = Array(acc.length + 1);
        for (var i = 0; i < acc.length; i++) {
          combined[i] = acc[i];
        }
        combined[acc.length] = x;
        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
      };
    }
    var tupleConstructors = {
      1: function(a) {
        return [a];
      },
      2: function(a) {
        return function(b) {
          return [a, b];
        };
      },
      3: function(a) {
        return function(b) {
          return function(c) {
            return [a, b, c];
          };
        };
      },
      4: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return [a, b, c, d];
            };
          };
        };
      },
      5: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return function(e) {
                return [a, b, c, d, e];
              };
            };
          };
        };
      }
    };
    function getTupleConstructor(len) {
      if (!_.has.call(tupleConstructors, len)) {
        tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
      }
      return tupleConstructors[len];
    }
    function sequenceT(F) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var len = args.length;
        var f = getTupleConstructor(len);
        var fas = F.map(args[0], f);
        for (var i = 1; i < len; i++) {
          fas = F.ap(fas, args[i]);
        }
        return fas;
      };
    }
    exports.sequenceT = sequenceT;
    function getRecordConstructor(keys3) {
      var len = keys3.length;
      switch (len) {
        case 1:
          return function(a) {
            var _a;
            return _a = {}, _a[keys3[0]] = a, _a;
          };
        case 2:
          return function(a) {
            return function(b) {
              var _a;
              return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a;
            };
          };
        case 3:
          return function(a) {
            return function(b) {
              return function(c) {
                var _a;
                return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a;
              };
            };
          };
        case 4:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  var _a;
                  return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a[keys3[3]] = d, _a;
                };
              };
            };
          };
        case 5:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  return function(e) {
                    var _a;
                    return _a = {}, _a[keys3[0]] = a, _a[keys3[1]] = b, _a[keys3[2]] = c, _a[keys3[3]] = d, _a[keys3[4]] = e, _a;
                  };
                };
              };
            };
          };
        default:
          return curried(function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var r = {};
            for (var i = 0; i < len; i++) {
              r[keys3[i]] = args[i];
            }
            return r;
          }, len - 1, []);
      }
    }
    function sequenceS(F) {
      return function(r) {
        var keys3 = Object.keys(r);
        var len = keys3.length;
        var f = getRecordConstructor(keys3);
        var fr = F.map(r[keys3[0]], f);
        for (var i = 1; i < len; i++) {
          fr = F.ap(fr, r[keys3[i]]);
        }
        return fr;
      };
    }
    exports.sequenceS = sequenceS;
  }
});

// node_modules/fp-ts/lib/Functor.js
var require_Functor = __commonJS({
  "node_modules/fp-ts/lib/Functor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctorComposition = exports.bindTo = exports.flap = exports.map = void 0;
    var function_1 = require_function();
    function map10(F, G) {
      return function(f) {
        return function(fa) {
          return F.map(fa, function(ga) {
            return G.map(ga, f);
          });
        };
      };
    }
    exports.map = map10;
    function flap11(F) {
      return function(a) {
        return function(fab) {
          return F.map(fab, function(f) {
            return f(a);
          });
        };
      };
    }
    exports.flap = flap11;
    function bindTo8(F) {
      return function(name) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a;
            return _a = {}, _a[name] = a, _a;
          });
        };
      };
    }
    exports.bindTo = bindTo8;
    function getFunctorComposition2(F, G) {
      var _map10 = map10(F, G);
      return {
        map: function(fga, f) {
          return (0, function_1.pipe)(fga, _map10(f));
        }
      };
    }
    exports.getFunctorComposition = getFunctorComposition2;
  }
});

// node_modules/fp-ts/lib/Applicative.js
var require_Applicative = __commonJS({
  "node_modules/fp-ts/lib/Applicative.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApplicativeComposition = exports.getApplicativeMonoid = void 0;
    var Apply_1 = require_Apply();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function getApplicativeMonoid2(F) {
      var f = (0, Apply_1.getApplySemigroup)(F);
      return function(M) {
        return {
          concat: f(M).concat,
          empty: F.of(M.empty)
        };
      };
    }
    exports.getApplicativeMonoid = getApplicativeMonoid2;
    function getApplicativeComposition(F, G) {
      var map10 = (0, Functor_1.getFunctorComposition)(F, G).map;
      var _ap7 = (0, Apply_1.ap)(F, G);
      return {
        map: map10,
        of: function(a) {
          return F.of(G.of(a));
        },
        ap: function(fgab, fga) {
          return (0, function_1.pipe)(fgab, _ap7(fga));
        }
      };
    }
    exports.getApplicativeComposition = getApplicativeComposition;
  }
});

// node_modules/fp-ts/lib/Chain.js
var require_Chain = __commonJS({
  "node_modules/fp-ts/lib/Chain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bind = exports.chainFirst = void 0;
    function chainFirst8(M) {
      return function(f) {
        return function(first2) {
          return M.chain(first2, function(a) {
            return M.map(f(a), function() {
              return a;
            });
          });
        };
      };
    }
    exports.chainFirst = chainFirst8;
    function bind8(M) {
      return function(name, f) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return M.map(f(a), function(b) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            });
          });
        };
      };
    }
    exports.bind = bind8;
  }
});

// node_modules/fp-ts/lib/ChainRec.js
var require_ChainRec = __commonJS({
  "node_modules/fp-ts/lib/ChainRec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tailRec = void 0;
    var tailRec2 = function(startWith, f) {
      var ab = f(startWith);
      while (ab._tag === "Left") {
        ab = f(ab.left);
      }
      return ab.right;
    };
    exports.tailRec = tailRec2;
  }
});

// node_modules/fp-ts/lib/FromEither.js
var require_FromEither = __commonJS({
  "node_modules/fp-ts/lib/FromEither.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function fromOption4(F) {
      return function(onNone) {
        return function(ma) {
          return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
        };
      };
    }
    exports.fromOption = fromOption4;
    function fromPredicate5(F) {
      return function(predicate, onFalse) {
        return function(a) {
          return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
        };
      };
    }
    exports.fromPredicate = fromPredicate5;
    function fromOptionK4(F) {
      var fromOptionF = fromOption4(F);
      return function(onNone) {
        var from = fromOptionF(onNone);
        return function(f) {
          return (0, function_1.flow)(f, from);
        };
      };
    }
    exports.fromOptionK = fromOptionK4;
    function chainOptionK3(F, M) {
      var fromOptionKF = fromOptionK4(F);
      return function(onNone) {
        var from = fromOptionKF(onNone);
        return function(f) {
          return function(ma) {
            return M.chain(ma, from(f));
          };
        };
      };
    }
    exports.chainOptionK = chainOptionK3;
    function fromEitherK5(F) {
      return function(f) {
        return (0, function_1.flow)(f, F.fromEither);
      };
    }
    exports.fromEitherK = fromEitherK5;
    function chainEitherK3(F, M) {
      var fromEitherKF = fromEitherK5(F);
      return function(f) {
        return function(ma) {
          return M.chain(ma, fromEitherKF(f));
        };
      };
    }
    exports.chainEitherK = chainEitherK3;
    function chainFirstEitherK3(F, M) {
      return (0, function_1.flow)(fromEitherK5(F), (0, Chain_1.chainFirst)(M));
    }
    exports.chainFirstEitherK = chainFirstEitherK3;
    function filterOrElse3(F, M) {
      return function(predicate, onFalse) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
          });
        };
      };
    }
    exports.filterOrElse = filterOrElse3;
  }
});

// node_modules/fp-ts/lib/Separated.js
var require_Separated = __commonJS({
  "node_modules/fp-ts/lib/Separated.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var separated2 = function(left5, right5) {
      return { left: left5, right: right5 };
    };
    exports.separated = separated2;
    var _map10 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f));
    };
    var _mapLeft2 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
    };
    var _bimap2 = function(fa, g, f) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f));
    };
    var map10 = function(f) {
      return function(fa) {
        return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));
      };
    };
    exports.map = map10;
    var mapLeft2 = function(f) {
      return function(fa) {
        return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));
      };
    };
    exports.mapLeft = mapLeft2;
    var bimap2 = function(f, g) {
      return function(fa) {
        return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));
      };
    };
    exports.bimap = bimap2;
    exports.URI = "Separated";
    exports.Bifunctor = {
      URI: exports.URI,
      mapLeft: _mapLeft2,
      bimap: _bimap2
    };
    exports.Functor = {
      URI: exports.URI,
      map: _map10
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    var left4 = function(s) {
      return s.left;
    };
    exports.left = left4;
    var right4 = function(s) {
      return s.right;
    };
    exports.right = right4;
  }
});

// node_modules/fp-ts/lib/Witherable.js
var require_Witherable = __commonJS({
  "node_modules/fp-ts/lib/Witherable.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterE = exports.witherDefault = exports.wiltDefault = void 0;
    var _ = __importStar(require_internal());
    function wiltDefault2(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f) {
          return F.map(traverseF(wa, f), C.separate);
        };
      };
    }
    exports.wiltDefault = wiltDefault2;
    function witherDefault2(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f) {
          return F.map(traverseF(wa, f), C.compact);
        };
      };
    }
    exports.witherDefault = witherDefault2;
    function filterE4(W) {
      return function(F) {
        var witherF = W.wither(F);
        return function(predicate) {
          return function(ga) {
            return witherF(ga, function(a) {
              return F.map(predicate(a), function(b) {
                return b ? _.some(a) : _.none;
              });
            });
          };
        };
      };
    }
    exports.filterE = filterE4;
  }
});

// node_modules/fp-ts/lib/Either.js
var require_Either = __commonJS({
  "node_modules/fp-ts/lib/Either.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fold = exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.chainW = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.right = exports.left = void 0;
    exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.chainFirstW = exports.chainFirst = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = void 0;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var Chain_1 = require_Chain();
    var ChainRec_1 = require_ChainRec();
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    exports.left = _.left;
    exports.right = _.right;
    var _map10 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f));
    };
    var _ap7 = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _chain7 = function(ma, f) {
      return (0, function_1.pipe)(ma, (0, exports.chain)(f));
    };
    var _reduce8 = function(fa, b, f) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
    };
    var _foldMap8 = function(M) {
      return function(fa, f) {
        var foldMapM = (0, exports.foldMap)(M);
        return (0, function_1.pipe)(fa, foldMapM(f));
      };
    };
    var _reduceRight8 = function(fa, b, f) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
    };
    var _traverse8 = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f) {
        return (0, function_1.pipe)(ta, traverseF(f));
      };
    };
    var _bimap2 = function(fa, f, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g));
    };
    var _mapLeft2 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
    };
    var _alt5 = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _extend5 = function(wa, f) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f));
    };
    var _chainRec2 = function(a, f) {
      return (0, ChainRec_1.tailRec)(f(a), function(e) {
        return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
      });
    };
    exports.URI = "Either";
    var getShow9 = function(SE, SA) {
      return {
        show: function(ma) {
          return (0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
        }
      };
    };
    exports.getShow = getShow9;
    var getEq9 = function(EL, EA) {
      return {
        equals: function(x, y) {
          return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
        }
      };
    };
    exports.getEq = getEq9;
    var getSemigroup6 = function(S) {
      return {
        concat: function(x, y) {
          return (0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right));
        }
      };
    };
    exports.getSemigroup = getSemigroup6;
    var getCompactable2 = function(M) {
      var empty7 = (0, exports.left)(M.empty);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: function(ma) {
          return (0, exports.isLeft)(ma) ? ma : ma.right._tag === "None" ? empty7 : (0, exports.right)(ma.right.value);
        },
        separate: function(ma) {
          return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : (0, exports.isLeft)(ma.right) ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty7) : (0, Separated_1.separated)(empty7, (0, exports.right)(ma.right.right));
        }
      };
    };
    exports.getCompactable = getCompactable2;
    var getFilterable2 = function(M) {
      var empty7 = (0, exports.left)(M.empty);
      var _a = (0, exports.getCompactable)(M), compact6 = _a.compact, separate6 = _a.separate;
      var filter7 = function(ma, predicate) {
        return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty7;
      };
      var partition6 = function(ma, p) {
        return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : p(ma.right) ? (0, Separated_1.separated)(empty7, (0, exports.right)(ma.right)) : (0, Separated_1.separated)((0, exports.right)(ma.right), empty7);
      };
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        compact: compact6,
        separate: separate6,
        filter: filter7,
        filterMap: function(ma, f) {
          if ((0, exports.isLeft)(ma)) {
            return ma;
          }
          var ob = f(ma.right);
          return ob._tag === "None" ? empty7 : (0, exports.right)(ob.value);
        },
        partition: partition6,
        partitionMap: function(ma, f) {
          if ((0, exports.isLeft)(ma)) {
            return (0, Separated_1.separated)(ma, ma);
          }
          var e = f(ma.right);
          return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty7) : (0, Separated_1.separated)(empty7, (0, exports.right)(e.right));
        }
      };
    };
    exports.getFilterable = getFilterable2;
    var getWitherable3 = function(M) {
      var F_ = (0, exports.getFilterable)(M);
      var C = (0, exports.getCompactable)(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse8,
        sequence: exports.sequence,
        reduce: _reduce8,
        foldMap: _foldMap8,
        reduceRight: _reduceRight8,
        wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
        wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
      };
    };
    exports.getWitherable = getWitherable3;
    var getApplicativeValidation2 = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        ap: function(fab, fa) {
          return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? (0, exports.left)(SE.concat(fab.left, fa.left)) : fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
        },
        of: exports.of
      };
    };
    exports.getApplicativeValidation = getApplicativeValidation2;
    var getAltValidation2 = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        alt: function(me, that) {
          if ((0, exports.isRight)(me)) {
            return me;
          }
          var ea = that();
          return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
        }
      };
    };
    exports.getAltValidation = getAltValidation2;
    var map10 = function(f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));
      };
    };
    exports.map = map10;
    exports.Functor = {
      URI: exports.URI,
      map: _map10
    };
    exports.of = exports.right;
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    var apW2 = function(fa) {
      return function(fab) {
        return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
      };
    };
    exports.apW = apW2;
    exports.ap = exports.apW;
    exports.Apply = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7
    };
    exports.Applicative = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of
    };
    var chainW2 = function(f) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? ma : f(ma.right);
      };
    };
    exports.chainW = chainW2;
    exports.chain = exports.chainW;
    exports.Chain = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      chain: _chain7
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of,
      chain: _chain7
    };
    var reduce9 = function(b, f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f(b, fa.right);
      };
    };
    exports.reduce = reduce9;
    var foldMap9 = function(M) {
      return function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
        };
      };
    };
    exports.foldMap = foldMap9;
    var reduceRight9 = function(b, f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f(fa.right, b);
      };
    };
    exports.reduceRight = reduceRight9;
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8
    };
    var traverse8 = function(F) {
      return function(f) {
        return function(ta) {
          return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);
        };
      };
    };
    exports.traverse = traverse8;
    var sequence8 = function(F) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
      };
    };
    exports.sequence = sequence8;
    exports.Traversable = {
      URI: exports.URI,
      map: _map10,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8,
      traverse: _traverse8,
      sequence: exports.sequence
    };
    var bimap2 = function(f, g) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));
      };
    };
    exports.bimap = bimap2;
    var mapLeft2 = function(f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;
      };
    };
    exports.mapLeft = mapLeft2;
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap2,
      mapLeft: _mapLeft2
    };
    var altW5 = function(that) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? that() : fa;
      };
    };
    exports.altW = altW5;
    exports.alt = exports.altW;
    exports.Alt = {
      URI: exports.URI,
      map: _map10,
      alt: _alt5
    };
    var extend7 = function(f) {
      return function(wa) {
        return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));
      };
    };
    exports.extend = extend7;
    exports.Extend = {
      URI: exports.URI,
      map: _map10,
      extend: _extend5
    };
    exports.ChainRec = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      chain: _chain7,
      chainRec: _chainRec2
    };
    exports.throwError = exports.left;
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map10,
      ap: _ap7,
      of: exports.of,
      chain: _chain7,
      throwError: exports.throwError
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: function_1.identity
    };
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.fromOption = (0, FromEither_1.fromOption)(exports.FromEither);
    exports.isLeft = _.isLeft;
    exports.isRight = _.isRight;
    var matchW5 = function(onLeft, onRight) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
      };
    };
    exports.matchW = matchW5;
    exports.foldW = exports.matchW;
    exports.match = exports.matchW;
    exports.fold = exports.match;
    var getOrElseW3 = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
      };
    };
    exports.getOrElseW = getOrElseW3;
    exports.getOrElse = exports.getOrElseW;
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.apSecondW = exports.apSecond;
    exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
    exports.chainFirstW = exports.chainFirst;
    exports.flattenW = (0, exports.chainW)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.fromOptionK = (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    var swap2 = function(ma) {
      return (0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right);
    };
    exports.swap = swap2;
    var orElseW2 = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
      };
    };
    exports.orElseW = orElseW2;
    exports.orElse = exports.orElseW;
    var fromNullable3 = function(e) {
      return function(a) {
        return a == null ? (0, exports.left)(e) : (0, exports.right)(a);
      };
    };
    exports.fromNullable = fromNullable3;
    var tryCatch3 = function(f, onThrow) {
      try {
        return (0, exports.right)(f());
      } catch (e) {
        return (0, exports.left)(onThrow(e));
      }
    };
    exports.tryCatch = tryCatch3;
    var tryCatchK3 = function(f, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f.apply(void 0, a);
        }, onThrow);
      };
    };
    exports.tryCatchK = tryCatchK3;
    var fromNullableK3 = function(e) {
      var from = (0, exports.fromNullable)(e);
      return function(f) {
        return (0, function_1.flow)(f, from);
      };
    };
    exports.fromNullableK = fromNullableK3;
    var chainNullableK3 = function(e) {
      var from = (0, exports.fromNullableK)(e);
      return function(f) {
        return (0, exports.chain)(from(f));
      };
    };
    exports.chainNullableK = chainNullableK3;
    exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
    function toError2(e) {
      return e instanceof Error ? e : new Error(String(e));
    }
    exports.toError = toError2;
    function elem7(E) {
      return function(a, ma) {
        if (ma === void 0) {
          var elemE_1 = elem7(E);
          return function(ma2) {
            return elemE_1(a, ma2);
          };
        }
        return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
      };
    }
    exports.elem = elem7;
    var exists4 = function(predicate) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
      };
    };
    exports.exists = exists4;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    exports.bind = (0, Chain_1.bind)(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex3 = function(f) {
      return function(as) {
        var e = f(0, _.head(as));
        if ((0, exports.isLeft)(e)) {
          return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
          var e_1 = f(i, as[i]);
          if ((0, exports.isLeft)(e_1)) {
            return e_1;
          }
          out.push(e_1.right);
        }
        return (0, exports.right)(out);
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex3;
    var traverseReadonlyArrayWithIndex3 = function(f) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
      return function(as) {
        return _.isNonEmpty(as) ? g(as) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex3;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray3 = function(f) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f(a);
      });
    };
    exports.traverseArray = traverseArray3;
    exports.sequenceArray = (0, exports.traverseArray)(function_1.identity);
    function parseJSON2(s, onError) {
      return (0, exports.tryCatch)(function() {
        return JSON.parse(s);
      }, onError);
    }
    exports.parseJSON = parseJSON2;
    var stringifyJSON2 = function(u, onError) {
      return (0, exports.tryCatch)(function() {
        var s = JSON.stringify(u);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, onError);
    };
    exports.stringifyJSON = stringifyJSON2;
    exports.either = {
      URI: exports.URI,
      map: _map10,
      of: exports.of,
      ap: _ap7,
      chain: _chain7,
      reduce: _reduce8,
      foldMap: _foldMap8,
      reduceRight: _reduceRight8,
      traverse: _traverse8,
      sequence: exports.sequence,
      bimap: _bimap2,
      mapLeft: _mapLeft2,
      alt: _alt5,
      extend: _extend5,
      chainRec: _chainRec2,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getApplyMonoid = (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
    var getValidationSemigroup2 = function(SE, SA) {
      return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
    };
    exports.getValidationSemigroup = getValidationSemigroup2;
    var getValidationMonoid2 = function(SE, MA) {
      return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
    };
    exports.getValidationMonoid = getValidationMonoid2;
    function getValidation2(SE) {
      var ap8 = (0, exports.getApplicativeValidation)(SE).ap;
      var alt5 = (0, exports.getAltValidation)(SE).alt;
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map10,
        of: exports.of,
        chain: _chain7,
        bimap: _bimap2,
        mapLeft: _mapLeft2,
        reduce: _reduce8,
        foldMap: _foldMap8,
        reduceRight: _reduceRight8,
        extend: _extend5,
        traverse: _traverse8,
        sequence: exports.sequence,
        chainRec: _chainRec2,
        throwError: exports.throwError,
        ap: ap8,
        alt: alt5
      };
    }
    exports.getValidation = getValidation2;
  }
});

// node_modules/fp-ts/es6/Eq.js
var fromEquals, eqStrict, strictEqual;
var init_Eq = __esm({
  "node_modules/fp-ts/es6/Eq.js"() {
    init_function();
    fromEquals = function(equals) {
      return {
        equals: function(x, y) {
          return x === y || equals(x, y);
        }
      };
    };
    eqStrict = {
      equals: function(a, b) {
        return a === b;
      }
    };
    strictEqual = eqStrict.equals;
  }
});

// node_modules/fp-ts/es6/Ord.js
function compare(first2, second) {
  return first2 < second ? -1 : first2 > second ? 1 : 0;
}
var equalsDefault, fromCompare, contramap, getSemigroup2, getMonoid, trivial, min, max, strictOrd, ordNumber, ordDate;
var init_Ord = __esm({
  "node_modules/fp-ts/es6/Ord.js"() {
    init_Eq();
    init_function();
    equalsDefault = function(compare2) {
      return function(first2, second) {
        return first2 === second || compare2(first2, second) === 0;
      };
    };
    fromCompare = function(compare2) {
      return {
        equals: equalsDefault(compare2),
        compare: function(first2, second) {
          return first2 === second ? 0 : compare2(first2, second);
        }
      };
    };
    contramap = function(f) {
      return function(fa) {
        return fromCompare(function(first2, second) {
          return fa.compare(f(first2), f(second));
        });
      };
    };
    getSemigroup2 = function() {
      return {
        concat: function(first2, second) {
          return fromCompare(function(a, b) {
            var ox = first2.compare(a, b);
            return ox !== 0 ? ox : second.compare(a, b);
          });
        }
      };
    };
    getMonoid = function() {
      return {
        concat: getSemigroup2().concat,
        empty: fromCompare(function() {
          return 0;
        })
      };
    };
    trivial = {
      equals: constTrue,
      compare: constant(0)
    };
    min = function(O) {
      return function(first2, second) {
        return first2 === second || O.compare(first2, second) < 1 ? first2 : second;
      };
    };
    max = function(O) {
      return function(first2, second) {
        return first2 === second || O.compare(first2, second) > -1 ? first2 : second;
      };
    };
    strictOrd = {
      equals: eqStrict.equals,
      compare
    };
    ordNumber = strictOrd;
    ordDate = pipe(
      ordNumber,
      contramap(function(date) {
        return date.valueOf();
      })
    );
  }
});

// node_modules/fp-ts/es6/Magma.js
var init_Magma = __esm({
  "node_modules/fp-ts/es6/Magma.js"() {
  }
});

// node_modules/fp-ts/es6/Semigroup.js
var min2, max2, constant2, first, last, semigroupVoid;
var init_Semigroup = __esm({
  "node_modules/fp-ts/es6/Semigroup.js"() {
    init_function();
    init_internal();
    init_Magma();
    init_Ord();
    min2 = function(O) {
      return {
        concat: min(O)
      };
    };
    max2 = function(O) {
      return {
        concat: max(O)
      };
    };
    constant2 = function(a) {
      return {
        concat: function() {
          return a;
        }
      };
    };
    first = function() {
      return { concat: identity };
    };
    last = function() {
      return { concat: function(_, y) {
        return y;
      } };
    };
    semigroupVoid = constant2(void 0);
  }
});

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var __spreadArray3, empty, isNonEmpty3, isOutOfBound, prependW, prepend, appendW, append, prependAll, intersperse, chainWithIndex, _map3, _ap2, _chain2, of2, ap3, chain2, extend2, duplicate2, flatten2, map3, mapWithIndex, reduce2, foldMap2, reduceRight2, reduceWithIndex, foldMapWithIndex, reduceRightWithIndex, extract, URI3, getShow2, getEq2, Functor3, flap4, Apply2, apFirst3, apSecond3, Chain2, chainFirst3, Do2, bindTo3, bind3, apS3, head2, tail2, last2, min3, max3, concatAll2, intercalate;
var init_ReadonlyNonEmptyArray = __esm({
  "node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js"() {
    init_Apply();
    init_Chain();
    init_Eq();
    init_function();
    init_Functor();
    init_internal();
    init_Ord();
    init_Semigroup();
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    empty = emptyReadonlyArray;
    isNonEmpty3 = isNonEmpty;
    isOutOfBound = function(i, as) {
      return i < 0 || i >= as.length;
    };
    prependW = function(head6) {
      return function(tail5) {
        return __spreadArray3([head6], tail5, true);
      };
    };
    prepend = prependW;
    appendW = function(end) {
      return function(init4) {
        return __spreadArray3(__spreadArray3([], init4, true), [end], false);
      };
    };
    append = appendW;
    prependAll = function(middle) {
      return function(as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
          out.push(middle, as[i]);
        }
        return out;
      };
    };
    intersperse = function(middle) {
      return function(as) {
        var rest = tail2(as);
        return isNonEmpty3(rest) ? pipe(rest, prependAll(middle), prepend(head2(as))) : as;
      };
    };
    chainWithIndex = function(f) {
      return function(as) {
        var out = fromReadonlyNonEmptyArray(f(0, head2(as)));
        for (var i = 1; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    _map3 = function(fa, f) {
      return pipe(fa, map3(f));
    };
    _ap2 = function(fab, fa) {
      return pipe(fab, ap3(fa));
    };
    _chain2 = function(ma, f) {
      return pipe(ma, chain2(f));
    };
    of2 = singleton;
    ap3 = function(as) {
      return chain2(function(f) {
        return pipe(as, map3(f));
      });
    };
    chain2 = function(f) {
      return chainWithIndex(function(_, a) {
        return f(a);
      });
    };
    extend2 = function(f) {
      return function(as) {
        var next = tail2(as);
        var out = [f(as)];
        while (isNonEmpty3(next)) {
          out.push(f(next));
          next = tail2(next);
        }
        return out;
      };
    };
    duplicate2 = extend2(identity);
    flatten2 = chain2(identity);
    map3 = function(f) {
      return mapWithIndex(function(_, a) {
        return f(a);
      });
    };
    mapWithIndex = function(f) {
      return function(as) {
        var out = [f(0, head2(as))];
        for (var i = 1; i < as.length; i++) {
          out.push(f(i, as[i]));
        }
        return out;
      };
    };
    reduce2 = function(b, f) {
      return reduceWithIndex(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    foldMap2 = function(S) {
      return function(f) {
        return function(as) {
          return as.slice(1).reduce(function(s, a) {
            return S.concat(s, f(a));
          }, f(as[0]));
        };
      };
    };
    reduceRight2 = function(b, f) {
      return reduceRightWithIndex(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    reduceWithIndex = function(b, f) {
      return function(as) {
        return as.reduce(function(b2, a, i) {
          return f(i, b2, a);
        }, b);
      };
    };
    foldMapWithIndex = function(S) {
      return function(f) {
        return function(as) {
          return as.slice(1).reduce(function(s, a, i) {
            return S.concat(s, f(i + 1, a));
          }, f(0, as[0]));
        };
      };
    };
    reduceRightWithIndex = function(b, f) {
      return function(as) {
        return as.reduceRight(function(b2, a, i) {
          return f(i, a, b2);
        }, b);
      };
    };
    extract = head;
    URI3 = "ReadonlyNonEmptyArray";
    getShow2 = function(S) {
      return {
        show: function(as) {
          return "[".concat(as.map(S.show).join(", "), "]");
        }
      };
    };
    getEq2 = function(E) {
      return fromEquals(function(xs, ys) {
        return xs.length === ys.length && xs.every(function(x, i) {
          return E.equals(x, ys[i]);
        });
      });
    };
    Functor3 = {
      URI: URI3,
      map: _map3
    };
    flap4 = flap(Functor3);
    Apply2 = {
      URI: URI3,
      map: _map3,
      ap: _ap2
    };
    apFirst3 = apFirst(Apply2);
    apSecond3 = apSecond(Apply2);
    Chain2 = {
      URI: URI3,
      map: _map3,
      ap: _ap2,
      chain: _chain2
    };
    chainFirst3 = chainFirst(Chain2);
    Do2 = of2(emptyRecord);
    bindTo3 = bindTo(Functor3);
    bind3 = bind(Chain2);
    apS3 = apS(Apply2);
    head2 = extract;
    tail2 = tail;
    last2 = function(as) {
      return as[as.length - 1];
    };
    min3 = function(O) {
      var S = min2(O);
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    max3 = function(O) {
      var S = max2(O);
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    concatAll2 = function(S) {
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    intercalate = function(S) {
      var concatAllS = concatAll2(S);
      return function(middle) {
        return flow(intersperse(middle), concatAllS);
      };
    };
  }
});

// node_modules/fp-ts/es6/NonEmptyArray.js
var NonEmptyArray_exports = {};
__export(NonEmptyArray_exports, {
  Alt: () => Alt2,
  Applicative: () => Applicative2,
  Apply: () => Apply3,
  Chain: () => Chain3,
  Comonad: () => Comonad,
  Do: () => Do3,
  Foldable: () => Foldable2,
  FoldableWithIndex: () => FoldableWithIndex,
  Functor: () => Functor4,
  FunctorWithIndex: () => FunctorWithIndex,
  Monad: () => Monad2,
  Pointed: () => Pointed2,
  Traversable: () => Traversable2,
  TraversableWithIndex: () => TraversableWithIndex,
  URI: () => URI4,
  alt: () => alt2,
  altW: () => altW2,
  ap: () => ap4,
  apFirst: () => apFirst4,
  apS: () => apS4,
  apSecond: () => apSecond4,
  append: () => append2,
  appendW: () => appendW2,
  bind: () => bind4,
  bindTo: () => bindTo4,
  chain: () => chain3,
  chainFirst: () => chainFirst4,
  chainWithIndex: () => chainWithIndex2,
  chop: () => chop,
  chunksOf: () => chunksOf,
  concat: () => concat,
  concatAll: () => concatAll3,
  concatW: () => concatW,
  cons: () => cons,
  copy: () => copy,
  duplicate: () => duplicate3,
  extend: () => extend3,
  extract: () => extract2,
  filter: () => filter,
  filterWithIndex: () => filterWithIndex,
  flap: () => flap5,
  flatten: () => flatten3,
  fold: () => fold2,
  foldMap: () => foldMap3,
  foldMapWithIndex: () => foldMapWithIndex2,
  fromArray: () => fromArray,
  fromReadonlyNonEmptyArray: () => fromReadonlyNonEmptyArray2,
  getEq: () => getEq3,
  getSemigroup: () => getSemigroup4,
  getShow: () => getShow3,
  getUnionSemigroup: () => getUnionSemigroup,
  group: () => group,
  groupBy: () => groupBy,
  groupSort: () => groupSort,
  head: () => head3,
  init: () => init,
  insertAt: () => insertAt,
  intercalate: () => intercalate2,
  intersperse: () => intersperse2,
  isNonEmpty: () => isNonEmpty4,
  isOutOfBound: () => isOutOfBound2,
  last: () => last3,
  makeBy: () => makeBy,
  map: () => map4,
  mapWithIndex: () => mapWithIndex2,
  matchLeft: () => matchLeft,
  matchRight: () => matchRight,
  max: () => max4,
  min: () => min4,
  modifyAt: () => modifyAt,
  modifyHead: () => modifyHead,
  modifyLast: () => modifyLast,
  nonEmptyArray: () => nonEmptyArray,
  of: () => of3,
  prepend: () => prepend2,
  prependAll: () => prependAll2,
  prependToAll: () => prependToAll,
  prependW: () => prependW2,
  range: () => range,
  reduce: () => reduce3,
  reduceRight: () => reduceRight3,
  reduceRightWithIndex: () => reduceRightWithIndex2,
  reduceWithIndex: () => reduceWithIndex2,
  replicate: () => replicate,
  reverse: () => reverse2,
  rotate: () => rotate,
  sequence: () => sequence2,
  snoc: () => snoc,
  sort: () => sort,
  sortBy: () => sortBy,
  splitAt: () => splitAt,
  tail: () => tail3,
  traverse: () => traverse2,
  traverseWithIndex: () => traverseWithIndex,
  unappend: () => unappend,
  uncons: () => uncons,
  union: () => union2,
  uniq: () => uniq,
  unprepend: () => unprepend,
  unsafeInsertAt: () => unsafeInsertAt,
  unsafeUpdateAt: () => unsafeUpdateAt,
  unsnoc: () => unsnoc,
  unzip: () => unzip,
  updateAt: () => updateAt,
  updateHead: () => updateHead,
  updateLast: () => updateLast,
  zip: () => zip,
  zipWith: () => zipWith
});
function concatW(second) {
  return function(first2) {
    return first2.concat(second);
  };
}
function concat(x, y) {
  return y ? x.concat(y) : function(y2) {
    return y2.concat(x);
  };
}
function group(E) {
  return function(as) {
    var len = as.length;
    if (len === 0) {
      return [];
    }
    var out = [];
    var head6 = as[0];
    var nea = [head6];
    for (var i = 1; i < len; i++) {
      var a = as[i];
      if (E.equals(a, head6)) {
        nea.push(a);
      } else {
        out.push(nea);
        head6 = a;
        nea = [head6];
      }
    }
    out.push(nea);
    return out;
  };
}
function zip(as, bs) {
  if (bs === void 0) {
    return function(bs2) {
      return zip(bs2, as);
    };
  }
  return zipWith(as, bs, function(a, b) {
    return [a, b];
  });
}
function groupSort(O) {
  var sortO = sort(O);
  var groupO = group(O);
  return function(as) {
    return isNonEmpty4(as) ? groupO(sortO(as)) : [];
  };
}
function filter(predicate) {
  return filterWithIndex(function(_, a) {
    return predicate(a);
  });
}
function cons(head6, tail5) {
  return tail5 === void 0 ? prepend2(head6) : pipe(tail5, prepend2(head6));
}
var __spreadArray4, isNonEmpty4, isOutOfBound2, prependW2, prepend2, appendW2, append2, unsafeInsertAt, unsafeUpdateAt, uniq, sortBy, union2, rotate, fromReadonlyNonEmptyArray2, fromArray, makeBy, replicate, range, unprepend, unappend, reverse2, groupBy, sort, insertAt, updateAt, modifyAt, copy, of3, zipWith, unzip, prependAll2, intersperse2, foldMapWithIndex2, foldMap3, chainWithIndex2, chop, splitAt, chunksOf, _map4, _mapWithIndex, _ap3, _chain3, _extend2, _reduce2, _foldMap2, _reduceRight2, _traverse2, _alt2, _reduceWithIndex, _foldMapWithIndex, _reduceRightWithIndex, _traverseWithIndex, altW2, alt2, ap4, chain3, extend3, duplicate3, flatten3, map4, mapWithIndex2, reduce3, reduceWithIndex2, reduceRight3, reduceRightWithIndex2, traverse2, sequence2, traverseWithIndex, extract2, URI4, getShow3, getSemigroup4, getEq3, getUnionSemigroup, Functor4, flap5, Pointed2, FunctorWithIndex, Apply3, apFirst4, apSecond4, Applicative2, Chain3, chainFirst4, Monad2, Foldable2, FoldableWithIndex, Traversable2, TraversableWithIndex, Alt2, Comonad, Do3, bindTo4, bind4, apS4, head3, tail3, last3, init, min4, max4, concatAll3, matchLeft, matchRight, modifyHead, updateHead, modifyLast, updateLast, intercalate2, filterWithIndex, uncons, unsnoc, snoc, prependToAll, fold2, nonEmptyArray;
var init_NonEmptyArray = __esm({
  "node_modules/fp-ts/es6/NonEmptyArray.js"() {
    init_Apply();
    init_Chain();
    init_function();
    init_Functor();
    init_internal();
    init_Ord();
    init_ReadonlyNonEmptyArray();
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isNonEmpty4 = function(as) {
      return as.length > 0;
    };
    isOutOfBound2 = function(i, as) {
      return i < 0 || i >= as.length;
    };
    prependW2 = function(head6) {
      return function(tail5) {
        return __spreadArray4([head6], tail5, true);
      };
    };
    prepend2 = prependW2;
    appendW2 = function(end) {
      return function(init4) {
        return __spreadArray4(__spreadArray4([], init4, true), [end], false);
      };
    };
    append2 = appendW2;
    unsafeInsertAt = function(i, a, as) {
      if (isNonEmpty4(as)) {
        var xs = fromReadonlyNonEmptyArray2(as);
        xs.splice(i, 0, a);
        return xs;
      }
      return [a];
    };
    unsafeUpdateAt = function(i, a, as) {
      var xs = fromReadonlyNonEmptyArray2(as);
      xs[i] = a;
      return xs;
    };
    uniq = function(E) {
      return function(as) {
        if (as.length === 1) {
          return copy(as);
        }
        var out = [head3(as)];
        var rest = tail3(as);
        var _loop_1 = function(a2) {
          if (out.every(function(o) {
            return !E.equals(o, a2);
          })) {
            out.push(a2);
          }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
          var a = rest_1[_i];
          _loop_1(a);
        }
        return out;
      };
    };
    sortBy = function(ords) {
      if (isNonEmpty4(ords)) {
        var M = getMonoid();
        return sort(ords.reduce(M.concat, M.empty));
      }
      return copy;
    };
    union2 = function(E) {
      var uniqE = uniq(E);
      return function(second) {
        return function(first2) {
          return uniqE(pipe(first2, concat(second)));
        };
      };
    };
    rotate = function(n) {
      return function(as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if (isOutOfBound2(Math.abs(m), as) || m === 0) {
          return copy(as);
        }
        if (m < 0) {
          var _a = splitAt(-m)(as), f = _a[0], s = _a[1];
          return pipe(s, concat(f));
        } else {
          return rotate(m - len)(as);
        }
      };
    };
    fromReadonlyNonEmptyArray2 = fromReadonlyNonEmptyArray;
    fromArray = function(as) {
      return isNonEmpty4(as) ? some(as) : none;
    };
    makeBy = function(f) {
      return function(n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f(0)];
        for (var i = 1; i < j; i++) {
          out.push(f(i));
        }
        return out;
      };
    };
    replicate = function(a) {
      return makeBy(function() {
        return a;
      });
    };
    range = function(start, end) {
      return start <= end ? makeBy(function(i) {
        return start + i;
      })(end - start + 1) : [start];
    };
    unprepend = function(as) {
      return [head3(as), tail3(as)];
    };
    unappend = function(as) {
      return [init(as), last3(as)];
    };
    reverse2 = function(as) {
      return __spreadArray4([last3(as)], as.slice(0, -1).reverse(), true);
    };
    groupBy = function(f) {
      return function(as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
          var a = as_1[_i];
          var k = f(a);
          if (has.call(out, k)) {
            out[k].push(a);
          } else {
            out[k] = [a];
          }
        }
        return out;
      };
    };
    sort = function(O) {
      return function(as) {
        return as.slice().sort(O.compare);
      };
    };
    insertAt = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? none : some(unsafeInsertAt(i, a, as));
      };
    };
    updateAt = function(i, a) {
      return modifyAt(i, function() {
        return a;
      });
    };
    modifyAt = function(i, f) {
      return function(as) {
        return isOutOfBound2(i, as) ? none : some(unsafeUpdateAt(i, f(as[i]), as));
      };
    };
    copy = fromReadonlyNonEmptyArray2;
    of3 = function(a) {
      return [a];
    };
    zipWith = function(as, bs, f) {
      var cs = [f(as[0], bs[0])];
      var len = Math.min(as.length, bs.length);
      for (var i = 1; i < len; i++) {
        cs[i] = f(as[i], bs[i]);
      }
      return cs;
    };
    unzip = function(abs) {
      var fa = [abs[0][0]];
      var fb = [abs[0][1]];
      for (var i = 1; i < abs.length; i++) {
        fa[i] = abs[i][0];
        fb[i] = abs[i][1];
      }
      return [fa, fb];
    };
    prependAll2 = function(middle) {
      return function(as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
          out.push(middle, as[i]);
        }
        return out;
      };
    };
    intersperse2 = function(middle) {
      return function(as) {
        var rest = tail3(as);
        return isNonEmpty4(rest) ? pipe(rest, prependAll2(middle), prepend2(head3(as))) : copy(as);
      };
    };
    foldMapWithIndex2 = foldMapWithIndex;
    foldMap3 = foldMap2;
    chainWithIndex2 = function(f) {
      return function(as) {
        var out = fromReadonlyNonEmptyArray2(f(0, head3(as)));
        for (var i = 1; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    chop = function(f) {
      return function(as) {
        var _a = f(as), b = _a[0], rest = _a[1];
        var out = [b];
        var next = rest;
        while (isNonEmpty4(next)) {
          var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
          out.push(b_1);
          next = rest_2;
        }
        return out;
      };
    };
    splitAt = function(n) {
      return function(as) {
        var m = Math.max(1, n);
        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend2(head3(as))), as.slice(m)];
      };
    };
    chunksOf = function(n) {
      return chop(splitAt(n));
    };
    _map4 = function(fa, f) {
      return pipe(fa, map4(f));
    };
    _mapWithIndex = function(fa, f) {
      return pipe(fa, mapWithIndex2(f));
    };
    _ap3 = function(fab, fa) {
      return pipe(fab, ap4(fa));
    };
    _chain3 = function(ma, f) {
      return pipe(ma, chain3(f));
    };
    _extend2 = function(wa, f) {
      return pipe(wa, extend3(f));
    };
    _reduce2 = function(fa, b, f) {
      return pipe(fa, reduce3(b, f));
    };
    _foldMap2 = function(M) {
      var foldMapM = foldMap3(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight2 = function(fa, b, f) {
      return pipe(fa, reduceRight3(b, f));
    };
    _traverse2 = function(F) {
      var traverseF = traverse2(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _alt2 = function(fa, that) {
      return pipe(fa, alt2(that));
    };
    _reduceWithIndex = function(fa, b, f) {
      return pipe(fa, reduceWithIndex2(b, f));
    };
    _foldMapWithIndex = function(M) {
      var foldMapWithIndexM = foldMapWithIndex2(M);
      return function(fa, f) {
        return pipe(fa, foldMapWithIndexM(f));
      };
    };
    _reduceRightWithIndex = function(fa, b, f) {
      return pipe(fa, reduceRightWithIndex2(b, f));
    };
    _traverseWithIndex = function(F) {
      var traverseWithIndexF = traverseWithIndex(F);
      return function(ta, f) {
        return pipe(ta, traverseWithIndexF(f));
      };
    };
    altW2 = function(that) {
      return function(as) {
        return pipe(as, concatW(that()));
      };
    };
    alt2 = altW2;
    ap4 = function(as) {
      return chain3(function(f) {
        return pipe(as, map4(f));
      });
    };
    chain3 = function(f) {
      return chainWithIndex2(function(_, a) {
        return f(a);
      });
    };
    extend3 = function(f) {
      return function(as) {
        var next = tail3(as);
        var out = [f(as)];
        while (isNonEmpty4(next)) {
          out.push(f(next));
          next = tail3(next);
        }
        return out;
      };
    };
    duplicate3 = extend3(identity);
    flatten3 = chain3(identity);
    map4 = function(f) {
      return mapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    mapWithIndex2 = function(f) {
      return function(as) {
        var out = [f(0, head3(as))];
        for (var i = 1; i < as.length; i++) {
          out.push(f(i, as[i]));
        }
        return out;
      };
    };
    reduce3 = reduce2;
    reduceWithIndex2 = reduceWithIndex;
    reduceRight3 = reduceRight2;
    reduceRightWithIndex2 = reduceRightWithIndex;
    traverse2 = function(F) {
      var traverseWithIndexF = traverseWithIndex(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence2 = function(F) {
      return traverseWithIndex(F)(function(_, a) {
        return a;
      });
    };
    traverseWithIndex = function(F) {
      return function(f) {
        return function(as) {
          var out = F.map(f(0, head3(as)), of3);
          for (var i = 1; i < as.length; i++) {
            out = F.ap(F.map(out, function(bs) {
              return function(b) {
                return pipe(bs, append2(b));
              };
            }), f(i, as[i]));
          }
          return out;
        };
      };
    };
    extract2 = head2;
    URI4 = "NonEmptyArray";
    getShow3 = getShow2;
    getSemigroup4 = function() {
      return {
        concat
      };
    };
    getEq3 = getEq2;
    getUnionSemigroup = function(E) {
      var unionE = union2(E);
      return {
        concat: function(first2, second) {
          return unionE(second)(first2);
        }
      };
    };
    Functor4 = {
      URI: URI4,
      map: _map4
    };
    flap5 = flap(Functor4);
    Pointed2 = {
      URI: URI4,
      of: of3
    };
    FunctorWithIndex = {
      URI: URI4,
      map: _map4,
      mapWithIndex: _mapWithIndex
    };
    Apply3 = {
      URI: URI4,
      map: _map4,
      ap: _ap3
    };
    apFirst4 = apFirst(Apply3);
    apSecond4 = apSecond(Apply3);
    Applicative2 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      of: of3
    };
    Chain3 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      chain: _chain3
    };
    chainFirst4 = chainFirst(Chain3);
    Monad2 = {
      URI: URI4,
      map: _map4,
      ap: _ap3,
      of: of3,
      chain: _chain3
    };
    Foldable2 = {
      URI: URI4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2
    };
    FoldableWithIndex = {
      URI: URI4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex
    };
    Traversable2 = {
      URI: URI4,
      map: _map4,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2
    };
    TraversableWithIndex = {
      URI: URI4,
      map: _map4,
      mapWithIndex: _mapWithIndex,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex
    };
    Alt2 = {
      URI: URI4,
      map: _map4,
      alt: _alt2
    };
    Comonad = {
      URI: URI4,
      map: _map4,
      extend: _extend2,
      extract: extract2
    };
    Do3 = of3(emptyRecord);
    bindTo4 = bindTo(Functor4);
    bind4 = bind(Chain3);
    apS4 = apS(Apply3);
    head3 = head2;
    tail3 = function(as) {
      return as.slice(1);
    };
    last3 = last2;
    init = function(as) {
      return as.slice(0, -1);
    };
    min4 = min3;
    max4 = max3;
    concatAll3 = function(S) {
      return function(as) {
        return as.reduce(S.concat);
      };
    };
    matchLeft = function(f) {
      return function(as) {
        return f(head3(as), tail3(as));
      };
    };
    matchRight = function(f) {
      return function(as) {
        return f(init(as), last3(as));
      };
    };
    modifyHead = function(f) {
      return function(as) {
        return __spreadArray4([
          f(head3(as))
        ], tail3(as), true);
      };
    };
    updateHead = function(a) {
      return modifyHead(function() {
        return a;
      });
    };
    modifyLast = function(f) {
      return function(as) {
        return pipe(init(as), append2(f(last3(as))));
      };
    };
    updateLast = function(a) {
      return modifyLast(function() {
        return a;
      });
    };
    intercalate2 = intercalate;
    filterWithIndex = function(predicate) {
      return function(as) {
        return fromArray(as.filter(function(a, i) {
          return predicate(i, a);
        }));
      };
    };
    uncons = unprepend;
    unsnoc = unappend;
    snoc = function(init4, end) {
      return pipe(init4, append2(end));
    };
    prependToAll = prependAll2;
    fold2 = concatAll2;
    nonEmptyArray = {
      URI: URI4,
      of: of3,
      map: _map4,
      mapWithIndex: _mapWithIndex,
      ap: _ap3,
      chain: _chain3,
      extend: _extend2,
      extract: extract2,
      reduce: _reduce2,
      foldMap: _foldMap2,
      reduceRight: _reduceRight2,
      traverse: _traverse2,
      sequence: sequence2,
      reduceWithIndex: _reduceWithIndex,
      foldMapWithIndex: _foldMapWithIndex,
      reduceRightWithIndex: _reduceRightWithIndex,
      traverseWithIndex: _traverseWithIndex,
      alt: _alt2
    };
  }
});

// node_modules/fp-ts/es6/number.js
var Eq, Ord, Bounded, MagmaSub, SemigroupSum, SemigroupProduct, MonoidSum, MonoidProduct, Field;
var init_number = __esm({
  "node_modules/fp-ts/es6/number.js"() {
    Eq = {
      equals: function(first2, second) {
        return first2 === second;
      }
    };
    Ord = {
      equals: Eq.equals,
      compare: function(first2, second) {
        return first2 < second ? -1 : first2 > second ? 1 : 0;
      }
    };
    Bounded = {
      equals: Eq.equals,
      compare: Ord.compare,
      top: Infinity,
      bottom: -Infinity
    };
    MagmaSub = {
      concat: function(first2, second) {
        return first2 - second;
      }
    };
    SemigroupSum = {
      concat: function(first2, second) {
        return first2 + second;
      }
    };
    SemigroupProduct = {
      concat: function(first2, second) {
        return first2 * second;
      }
    };
    MonoidSum = {
      concat: SemigroupSum.concat,
      empty: 0
    };
    MonoidProduct = {
      concat: SemigroupProduct.concat,
      empty: 1
    };
    Field = {
      add: SemigroupSum.concat,
      zero: 0,
      mul: SemigroupProduct.concat,
      one: 1,
      sub: MagmaSub.concat,
      degree: function(_) {
        return 1;
      },
      div: function(first2, second) {
        return first2 / second;
      },
      mod: function(first2, second) {
        return first2 % second;
      }
    };
  }
});

// node_modules/fp-ts/es6/Zero.js
function guard(F, P) {
  return function(b) {
    return b ? P.of(void 0) : F.zero();
  };
}
var init_Zero = __esm({
  "node_modules/fp-ts/es6/Zero.js"() {
  }
});

// node_modules/fp-ts/es6/ReadonlyArray.js
function lookup(i, as) {
  return as === void 0 ? function(as2) {
    return lookup(i, as2);
  } : isOutOfBound3(i, as) ? none : some(as[i]);
}
function findFirst(predicate) {
  return function(as) {
    for (var i = 0; i < as.length; i++) {
      if (predicate(as[i])) {
        return some(as[i]);
      }
    }
    return none;
  };
}
function findLast(predicate) {
  return function(as) {
    for (var i = as.length - 1; i >= 0; i--) {
      if (predicate(as[i])) {
        return some(as[i]);
      }
    }
    return none;
  };
}
function elem2(E) {
  return function(a, as) {
    if (as === void 0) {
      var elemE_1 = elem2(E);
      return function(as2) {
        return elemE_1(a, as2);
      };
    }
    var predicate = function(element) {
      return E.equals(element, a);
    };
    var i = 0;
    for (; i < as.length; i++) {
      if (predicate(as[i])) {
        return true;
      }
    }
    return false;
  };
}
function every(predicate) {
  return function(as) {
    return as.every(predicate);
  };
}
var __spreadArray5, isEmpty, isNonEmpty5, append3, fromEither, matchW2, match2, chainWithIndex3, isOutOfBound3, head4, last4, findIndex, findFirstMap, findLastMap, findLastIndex, _map5, _ap4, _chain4, _filter, _filterMap, _partition, _partitionMap, _reduce3, _foldMap3, _reduceRight3, _traverse3, _chainRecDepthFirst, _chainRecBreadthFirst, of4, zero, ap5, chain4, flatten4, map5, separate, filter2, filterMapWithIndex, filterMap, compact, partition, partitionWithIndex, partitionMap, partitionMapWithIndex, extend4, duplicate4, foldMapWithIndex3, reduce4, foldMap4, reduceWithIndex3, reduceRight4, reduceRightWithIndex3, traverse3, sequence3, traverseWithIndex2, URI5, getShow4, getEq4, getOrd, Functor5, flap6, Pointed3, Apply4, apFirst5, apSecond5, Chain4, chainFirst5, Zero, guard2, Compactable, Traversable3, chainRecDepthFirst, chainRecBreadthFirst, _wither, _wilt, Witherable, filterE2, FromEither2, fromEitherK2, empty2, intercalate3, Do4, bindTo5, bind5, apS5;
var init_ReadonlyArray = __esm({
  "node_modules/fp-ts/es6/ReadonlyArray.js"() {
    init_Apply();
    init_Chain();
    init_Eq();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_number();
    init_Ord();
    init_ReadonlyNonEmptyArray();
    init_Separated();
    init_Witherable();
    init_Zero();
    __spreadArray5 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    isEmpty = function(as) {
      return as.length === 0;
    };
    isNonEmpty5 = isNonEmpty3;
    append3 = append;
    fromEither = function(e) {
      return isLeft(e) ? empty2 : [e.right];
    };
    matchW2 = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty5(as) ? onNonEmpty(as) : onEmpty();
      };
    };
    match2 = matchW2;
    chainWithIndex3 = function(f) {
      return function(as) {
        if (isEmpty(as)) {
          return empty2;
        }
        var out = [];
        for (var i = 0; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    isOutOfBound3 = isOutOfBound;
    head4 = function(as) {
      return isNonEmpty5(as) ? some(head2(as)) : none;
    };
    last4 = function(as) {
      return isNonEmpty5(as) ? some(last2(as)) : none;
    };
    findIndex = function(predicate) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          if (predicate(as[i])) {
            return some(i);
          }
        }
        return none;
      };
    };
    findFirstMap = function(f) {
      return function(as) {
        for (var i = 0; i < as.length; i++) {
          var out = f(as[i]);
          if (isSome(out)) {
            return out;
          }
        }
        return none;
      };
    };
    findLastMap = function(f) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          var out = f(as[i]);
          if (isSome(out)) {
            return out;
          }
        }
        return none;
      };
    };
    findLastIndex = function(predicate) {
      return function(as) {
        for (var i = as.length - 1; i >= 0; i--) {
          if (predicate(as[i])) {
            return some(i);
          }
        }
        return none;
      };
    };
    _map5 = function(fa, f) {
      return pipe(fa, map5(f));
    };
    _ap4 = function(fab, fa) {
      return pipe(fab, ap5(fa));
    };
    _chain4 = function(ma, f) {
      return pipe(ma, chain4(f));
    };
    _filter = function(fa, predicate) {
      return pipe(fa, filter2(predicate));
    };
    _filterMap = function(fa, f) {
      return pipe(fa, filterMap(f));
    };
    _partition = function(fa, predicate) {
      return pipe(fa, partition(predicate));
    };
    _partitionMap = function(fa, f) {
      return pipe(fa, partitionMap(f));
    };
    _reduce3 = function(fa, b, f) {
      return pipe(fa, reduce4(b, f));
    };
    _foldMap3 = function(M) {
      var foldMapM = foldMap4(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight3 = function(fa, b, f) {
      return pipe(fa, reduceRight4(b, f));
    };
    _traverse3 = function(F) {
      var traverseF = traverse3(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _chainRecDepthFirst = function(a, f) {
      return pipe(a, chainRecDepthFirst(f));
    };
    _chainRecBreadthFirst = function(a, f) {
      return pipe(a, chainRecBreadthFirst(f));
    };
    of4 = of2;
    zero = function() {
      return empty2;
    };
    ap5 = function(fa) {
      return chain4(function(f) {
        return pipe(fa, map5(f));
      });
    };
    chain4 = function(f) {
      return function(ma) {
        return pipe(ma, chainWithIndex3(function(_, a) {
          return f(a);
        }));
      };
    };
    flatten4 = chain4(identity);
    map5 = function(f) {
      return function(fa) {
        return fa.map(function(a) {
          return f(a);
        });
      };
    };
    separate = function(fa) {
      var left4 = [];
      var right4 = [];
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === "Left") {
          left4.push(e.left);
        } else {
          right4.push(e.right);
        }
      }
      return separated(left4, right4);
    };
    filter2 = function(predicate) {
      return function(as) {
        return as.filter(predicate);
      };
    };
    filterMapWithIndex = function(f) {
      return function(fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
          var optionB = f(i, fa[i]);
          if (isSome(optionB)) {
            out.push(optionB.value);
          }
        }
        return out;
      };
    };
    filterMap = function(f) {
      return filterMapWithIndex(function(_, a) {
        return f(a);
      });
    };
    compact = filterMap(identity);
    partition = function(predicate) {
      return partitionWithIndex(function(_, a) {
        return predicate(a);
      });
    };
    partitionWithIndex = function(predicateWithIndex) {
      return function(as) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < as.length; i++) {
          var a = as[i];
          if (predicateWithIndex(i, a)) {
            right4.push(a);
          } else {
            left4.push(a);
          }
        }
        return separated(left4, right4);
      };
    };
    partitionMap = function(f) {
      return partitionMapWithIndex(function(_, a) {
        return f(a);
      });
    };
    partitionMapWithIndex = function(f) {
      return function(fa) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < fa.length; i++) {
          var e = f(i, fa[i]);
          if (e._tag === "Left") {
            left4.push(e.left);
          } else {
            right4.push(e.right);
          }
        }
        return separated(left4, right4);
      };
    };
    extend4 = function(f) {
      return function(wa) {
        return wa.map(function(_, i) {
          return f(wa.slice(i));
        });
      };
    };
    duplicate4 = extend4(identity);
    foldMapWithIndex3 = function(M) {
      return function(f) {
        return function(fa) {
          return fa.reduce(function(b, a, i) {
            return M.concat(b, f(i, a));
          }, M.empty);
        };
      };
    };
    reduce4 = function(b, f) {
      return reduceWithIndex3(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
    foldMap4 = function(M) {
      var foldMapWithIndexM = foldMapWithIndex3(M);
      return function(f) {
        return foldMapWithIndexM(function(_, a) {
          return f(a);
        });
      };
    };
    reduceWithIndex3 = function(b, f) {
      return function(fa) {
        var len = fa.length;
        var out = b;
        for (var i = 0; i < len; i++) {
          out = f(i, out, fa[i]);
        }
        return out;
      };
    };
    reduceRight4 = function(b, f) {
      return reduceRightWithIndex3(b, function(_, a, b2) {
        return f(a, b2);
      });
    };
    reduceRightWithIndex3 = function(b, f) {
      return function(fa) {
        return fa.reduceRight(function(b2, a, i) {
          return f(i, a, b2);
        }, b);
      };
    };
    traverse3 = function(F) {
      var traverseWithIndexF = traverseWithIndex2(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence3 = function(F) {
      return function(ta) {
        return _reduce3(ta, F.of(zero()), function(fas, fa) {
          return F.ap(F.map(fas, function(as) {
            return function(a) {
              return pipe(as, append3(a));
            };
          }), fa);
        });
      };
    };
    traverseWithIndex2 = function(F) {
      return function(f) {
        return reduceWithIndex3(F.of(zero()), function(i, fbs, a) {
          return F.ap(F.map(fbs, function(bs) {
            return function(b) {
              return pipe(bs, append3(b));
            };
          }), f(i, a));
        });
      };
    };
    URI5 = "ReadonlyArray";
    getShow4 = function(S) {
      return {
        show: function(as) {
          return "[".concat(as.map(S.show).join(", "), "]");
        }
      };
    };
    getEq4 = function(E) {
      return fromEquals(function(xs, ys) {
        return xs.length === ys.length && xs.every(function(x, i) {
          return E.equals(x, ys[i]);
        });
      });
    };
    getOrd = function(O) {
      return fromCompare(function(a, b) {
        var aLen = a.length;
        var bLen = b.length;
        var len = Math.min(aLen, bLen);
        for (var i = 0; i < len; i++) {
          var ordering = O.compare(a[i], b[i]);
          if (ordering !== 0) {
            return ordering;
          }
        }
        return Ord.compare(aLen, bLen);
      });
    };
    Functor5 = {
      URI: URI5,
      map: _map5
    };
    flap6 = flap(Functor5);
    Pointed3 = {
      URI: URI5,
      of: of4
    };
    Apply4 = {
      URI: URI5,
      map: _map5,
      ap: _ap4
    };
    apFirst5 = apFirst(Apply4);
    apSecond5 = apSecond(Apply4);
    Chain4 = {
      URI: URI5,
      map: _map5,
      ap: _ap4,
      chain: _chain4
    };
    chainFirst5 = chainFirst(Chain4);
    Zero = {
      URI: URI5,
      zero
    };
    guard2 = guard(Zero, Pointed3);
    Compactable = {
      URI: URI5,
      compact,
      separate
    };
    Traversable3 = {
      URI: URI5,
      map: _map5,
      reduce: _reduce3,
      foldMap: _foldMap3,
      reduceRight: _reduceRight3,
      traverse: _traverse3,
      sequence: sequence3
    };
    chainRecDepthFirst = function(f) {
      return function(a) {
        var todo = __spreadArray5([], f(a), true);
        var out = [];
        while (todo.length > 0) {
          var e = todo.shift();
          if (isLeft(e)) {
            todo.unshift.apply(todo, f(e.left));
          } else {
            out.push(e.right);
          }
        }
        return out;
      };
    };
    chainRecBreadthFirst = function(f) {
      return function(a) {
        var initial = f(a);
        var todo = [];
        var out = [];
        function go(e2) {
          if (isLeft(e2)) {
            f(e2.left).forEach(function(v) {
              return todo.push(v);
            });
          } else {
            out.push(e2.right);
          }
        }
        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
          var e = initial_1[_i];
          go(e);
        }
        while (todo.length > 0) {
          go(todo.shift());
        }
        return out;
      };
    };
    _wither = witherDefault(Traversable3, Compactable);
    _wilt = wiltDefault(Traversable3, Compactable);
    Witherable = {
      URI: URI5,
      map: _map5,
      compact,
      separate,
      filter: _filter,
      filterMap: _filterMap,
      partition: _partition,
      partitionMap: _partitionMap,
      reduce: _reduce3,
      foldMap: _foldMap3,
      reduceRight: _reduceRight3,
      traverse: _traverse3,
      sequence: sequence3,
      wither: _wither,
      wilt: _wilt
    };
    filterE2 = filterE(Witherable);
    FromEither2 = {
      URI: URI5,
      fromEither
    };
    fromEitherK2 = fromEitherK(FromEither2);
    empty2 = empty;
    intercalate3 = function(M) {
      var intercalateM = intercalate(M);
      return function(middle) {
        return match2(function() {
          return M.empty;
        }, intercalateM(middle));
      };
    };
    Do4 = of4(emptyRecord);
    bindTo5 = bindTo(Functor5);
    bind5 = bind(Chain4);
    apS5 = apS(Apply4);
  }
});

// node_modules/fp-ts/es6/Array.js
var Array_exports = {};
__export(Array_exports, {
  Alt: () => Alt3,
  Alternative: () => Alternative,
  Applicative: () => Applicative3,
  Apply: () => Apply5,
  Chain: () => Chain5,
  ChainRecBreadthFirst: () => ChainRecBreadthFirst,
  ChainRecDepthFirst: () => ChainRecDepthFirst,
  Compactable: () => Compactable2,
  Do: () => Do5,
  Extend: () => Extend2,
  Filterable: () => Filterable,
  FilterableWithIndex: () => FilterableWithIndex,
  Foldable: () => Foldable3,
  FoldableWithIndex: () => FoldableWithIndex2,
  FromEither: () => FromEither3,
  Functor: () => Functor6,
  FunctorWithIndex: () => FunctorWithIndex2,
  Monad: () => Monad3,
  Pointed: () => Pointed4,
  Traversable: () => Traversable4,
  TraversableWithIndex: () => TraversableWithIndex2,
  URI: () => URI6,
  Unfoldable: () => Unfoldable,
  Witherable: () => Witherable2,
  Zero: () => Zero2,
  alt: () => alt3,
  altW: () => altW3,
  ap: () => ap6,
  apFirst: () => apFirst6,
  apS: () => apS6,
  apSecond: () => apSecond6,
  append: () => append4,
  appendW: () => appendW3,
  array: () => array2,
  bind: () => bind6,
  bindTo: () => bindTo6,
  chain: () => chain5,
  chainFirst: () => chainFirst6,
  chainRecBreadthFirst: () => chainRecBreadthFirst2,
  chainRecDepthFirst: () => chainRecDepthFirst2,
  chainWithIndex: () => chainWithIndex4,
  chop: () => chop3,
  chunksOf: () => chunksOf3,
  compact: () => compact2,
  comprehension: () => comprehension,
  concat: () => concat2,
  concatW: () => concatW2,
  cons: () => cons3,
  copy: () => copy2,
  deleteAt: () => deleteAt,
  difference: () => difference,
  dropLeft: () => dropLeft,
  dropLeftWhile: () => dropLeftWhile,
  dropRight: () => dropRight,
  duplicate: () => duplicate5,
  elem: () => elem3,
  empty: () => empty3,
  every: () => every2,
  exists: () => exists2,
  extend: () => extend5,
  filter: () => filter3,
  filterE: () => filterE3,
  filterMap: () => filterMap2,
  filterMapWithIndex: () => filterMapWithIndex2,
  filterWithIndex: () => filterWithIndex2,
  findFirst: () => findFirst2,
  findFirstMap: () => findFirstMap2,
  findIndex: () => findIndex2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  findLastMap: () => findLastMap2,
  flap: () => flap7,
  flatten: () => flatten5,
  foldLeft: () => foldLeft,
  foldMap: () => foldMap5,
  foldMapWithIndex: () => foldMapWithIndex4,
  foldRight: () => foldRight,
  fromEither: () => fromEither2,
  fromEitherK: () => fromEitherK3,
  fromOption: () => fromOption3,
  fromOptionK: () => fromOptionK3,
  fromPredicate: () => fromPredicate3,
  getDifferenceMagma: () => getDifferenceMagma,
  getEq: () => getEq5,
  getIntersectionSemigroup: () => getIntersectionSemigroup,
  getMonoid: () => getMonoid2,
  getOrd: () => getOrd2,
  getSemigroup: () => getSemigroup5,
  getShow: () => getShow5,
  getUnionMonoid: () => getUnionMonoid,
  getUnionSemigroup: () => getUnionSemigroup2,
  guard: () => guard3,
  head: () => head5,
  init: () => init3,
  insertAt: () => insertAt2,
  intercalate: () => intercalate4,
  intersection: () => intersection2,
  intersperse: () => intersperse3,
  isEmpty: () => isEmpty2,
  isNonEmpty: () => isNonEmpty6,
  isOutOfBound: () => isOutOfBound4,
  last: () => last5,
  lefts: () => lefts,
  lookup: () => lookup2,
  makeBy: () => makeBy3,
  map: () => map6,
  mapWithIndex: () => mapWithIndex3,
  match: () => match3,
  matchLeft: () => matchLeft2,
  matchLeftW: () => matchLeftW,
  matchRight: () => matchRight2,
  matchRightW: () => matchRightW,
  matchW: () => matchW3,
  modifyAt: () => modifyAt2,
  of: () => of5,
  partition: () => partition2,
  partitionMap: () => partitionMap2,
  partitionMapWithIndex: () => partitionMapWithIndex2,
  partitionWithIndex: () => partitionWithIndex2,
  prepend: () => prepend3,
  prependAll: () => prependAll3,
  prependToAll: () => prependToAll2,
  prependW: () => prependW3,
  range: () => range3,
  reduce: () => reduce5,
  reduceRight: () => reduceRight5,
  reduceRightWithIndex: () => reduceRightWithIndex4,
  reduceWithIndex: () => reduceWithIndex4,
  replicate: () => replicate2,
  reverse: () => reverse3,
  rights: () => rights,
  rotate: () => rotate3,
  scanLeft: () => scanLeft,
  scanRight: () => scanRight,
  separate: () => separate2,
  sequence: () => sequence4,
  size: () => size,
  snoc: () => snoc3,
  some: () => some2,
  sort: () => sort2,
  sortBy: () => sortBy3,
  spanLeft: () => spanLeft,
  splitAt: () => splitAt3,
  tail: () => tail4,
  takeLeft: () => takeLeft,
  takeLeftWhile: () => takeLeftWhile,
  takeRight: () => takeRight,
  traverse: () => traverse4,
  traverseWithIndex: () => traverseWithIndex3,
  unfold: () => unfold,
  union: () => union4,
  uniq: () => uniq3,
  unsafeDeleteAt: () => unsafeDeleteAt,
  unsafeInsertAt: () => unsafeInsertAt3,
  unsafeUpdateAt: () => unsafeUpdateAt3,
  unzip: () => unzip2,
  updateAt: () => updateAt2,
  wilt: () => wilt,
  wither: () => wither,
  zero: () => zero2,
  zip: () => zip2,
  zipWith: () => zipWith2
});
function fromPredicate3(predicate) {
  return function(a) {
    return predicate(a) ? [a] : [];
  };
}
function takeLeftWhile(predicate) {
  return function(as) {
    var out = [];
    for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
      var a = as_1[_i];
      if (!predicate(a)) {
        break;
      }
      out.push(a);
    }
    return out;
  };
}
function spanLeft(predicate) {
  return function(as) {
    var _a = splitAt3(spanLeftIndex(as, predicate))(as), init4 = _a[0], rest = _a[1];
    return { init: init4, rest };
  };
}
function dropLeftWhile(predicate) {
  return function(as) {
    return as.slice(spanLeftIndex(as, predicate));
  };
}
function findFirst2(predicate) {
  return findFirst(predicate);
}
function findLast2(predicate) {
  return findLast(predicate);
}
function zip2(as, bs) {
  if (bs === void 0) {
    return function(bs2) {
      return zip2(bs2, as);
    };
  }
  return zipWith2(as, bs, function(a, b) {
    return [a, b];
  });
}
function comprehension(input, f, g) {
  if (g === void 0) {
    g = function() {
      return true;
    };
  }
  var go = function(scope, input2) {
    return isNonEmpty6(input2) ? pipe(head3(input2), chain5(function(x) {
      return go(pipe(scope, append4(x)), tail3(input2));
    })) : g.apply(void 0, scope) ? [f.apply(void 0, scope)] : [];
  };
  return go([], input);
}
function union4(E) {
  var unionE = union2(E);
  return function(first2, second) {
    if (second === void 0) {
      var unionE_1 = union4(E);
      return function(second2) {
        return unionE_1(second2, first2);
      };
    }
    return isNonEmpty6(first2) && isNonEmpty6(second) ? unionE(second)(first2) : isNonEmpty6(first2) ? copy2(first2) : copy2(second);
  };
}
function intersection2(E) {
  var elemE = elem3(E);
  return function(xs, ys) {
    if (ys === void 0) {
      var intersectionE_1 = intersection2(E);
      return function(ys2) {
        return intersectionE_1(ys2, xs);
      };
    }
    return xs.filter(function(a) {
      return elemE(a, ys);
    });
  };
}
function difference(E) {
  var elemE = elem3(E);
  return function(xs, ys) {
    if (ys === void 0) {
      var differenceE_1 = difference(E);
      return function(ys2) {
        return differenceE_1(ys2, xs);
      };
    }
    return xs.filter(function(a) {
      return !elemE(a, ys);
    });
  };
}
var isEmpty2, isNonEmpty6, prepend3, prependW3, append4, appendW3, makeBy3, replicate2, fromOption3, fromEither2, matchW3, match3, matchLeftW, matchLeft2, foldLeft, matchRightW, matchRight2, foldRight, chainWithIndex4, scanLeft, scanRight, size, isOutOfBound4, lookup2, head5, last5, tail4, init3, takeLeft, takeRight, spanLeftIndex, dropLeft, dropRight, findIndex2, findFirstMap2, findLastMap2, findLastIndex2, copy2, insertAt2, updateAt2, deleteAt, modifyAt2, reverse3, rights, lefts, sort2, zipWith2, unzip2, prependAll3, intersperse3, rotate3, elem3, uniq3, sortBy3, chop3, splitAt3, chunksOf3, fromOptionK3, concatW2, concat2, _map6, _mapWithIndex2, _ap5, _chain5, _filter2, _filterMap2, _partition2, _partitionMap2, _partitionWithIndex, _partitionMapWithIndex, _alt3, _reduce4, _foldMap4, _reduceRight4, _reduceWithIndex2, _foldMapWithIndex2, _reduceRightWithIndex2, _filterMapWithIndex, _filterWithIndex, _extend3, _traverse4, _traverseWithIndex2, _chainRecDepthFirst2, _chainRecBreadthFirst2, of5, zero2, map6, ap6, chain5, flatten5, mapWithIndex3, filterMapWithIndex2, filterMap2, compact2, separate2, filter3, partition2, partitionWithIndex2, partitionMap2, partitionMapWithIndex2, altW3, alt3, filterWithIndex2, extend5, duplicate5, foldMap5, foldMapWithIndex4, reduce5, reduceWithIndex4, reduceRight5, reduceRightWithIndex4, traverse4, sequence4, traverseWithIndex3, wither, wilt, unfold, URI6, getShow5, getSemigroup5, getMonoid2, getEq5, getOrd2, getUnionSemigroup2, getUnionMonoid, getIntersectionSemigroup, getDifferenceMagma, Functor6, flap7, Pointed4, FunctorWithIndex2, Apply5, apFirst6, apSecond6, Applicative3, Chain5, chainFirst6, Monad3, Unfoldable, Alt3, Zero2, guard3, Alternative, Extend2, Compactable2, Filterable, FilterableWithIndex, Foldable3, FoldableWithIndex2, Traversable4, TraversableWithIndex2, _wither2, _wilt2, Witherable2, chainRecDepthFirst2, ChainRecDepthFirst, chainRecBreadthFirst2, ChainRecBreadthFirst, filterE3, FromEither3, fromEitherK3, unsafeInsertAt3, unsafeUpdateAt3, unsafeDeleteAt, every2, some2, exists2, intercalate4, Do5, bindTo6, bind6, apS6, range3, empty3, cons3, snoc3, prependToAll2, array2;
var init_Array = __esm({
  "node_modules/fp-ts/es6/Array.js"() {
    init_Apply();
    init_Chain();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_NonEmptyArray();
    init_ReadonlyArray();
    init_Separated();
    init_Witherable();
    init_Zero();
    isEmpty2 = function(as) {
      return as.length === 0;
    };
    isNonEmpty6 = isNonEmpty4;
    prepend3 = prepend2;
    prependW3 = prependW2;
    append4 = append2;
    appendW3 = appendW2;
    makeBy3 = function(n, f) {
      return n <= 0 ? [] : makeBy(f)(n);
    };
    replicate2 = function(n, a) {
      return makeBy3(n, function() {
        return a;
      });
    };
    fromOption3 = function(ma) {
      return isNone(ma) ? [] : [ma.value];
    };
    fromEither2 = function(e) {
      return isLeft(e) ? [] : [e.right];
    };
    matchW3 = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(as) : onEmpty();
      };
    };
    match3 = matchW3;
    matchLeftW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(head3(as), tail3(as)) : onEmpty();
      };
    };
    matchLeft2 = matchLeftW;
    foldLeft = matchLeft2;
    matchRightW = function(onEmpty, onNonEmpty) {
      return function(as) {
        return isNonEmpty6(as) ? onNonEmpty(init(as), last3(as)) : onEmpty();
      };
    };
    matchRight2 = matchRightW;
    foldRight = matchRight2;
    chainWithIndex4 = function(f) {
      return function(as) {
        var out = [];
        for (var i = 0; i < as.length; i++) {
          out.push.apply(out, f(i, as[i]));
        }
        return out;
      };
    };
    scanLeft = function(b, f) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
          out[i + 1] = f(out[i], as[i]);
        }
        return out;
      };
    };
    scanRight = function(b, f) {
      return function(as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
          out[i] = f(as[i], out[i + 1]);
        }
        return out;
      };
    };
    size = function(as) {
      return as.length;
    };
    isOutOfBound4 = isOutOfBound2;
    lookup2 = lookup;
    head5 = head4;
    last5 = last4;
    tail4 = function(as) {
      return isNonEmpty6(as) ? some(tail3(as)) : none;
    };
    init3 = function(as) {
      return isNonEmpty6(as) ? some(init(as)) : none;
    };
    takeLeft = function(n) {
      return function(as) {
        return isOutOfBound4(n, as) ? copy2(as) : as.slice(0, n);
      };
    };
    takeRight = function(n) {
      return function(as) {
        return isOutOfBound4(n, as) ? copy2(as) : n === 0 ? [] : as.slice(-n);
      };
    };
    spanLeftIndex = function(as, predicate) {
      var l = as.length;
      var i = 0;
      for (; i < l; i++) {
        if (!predicate(as[i])) {
          break;
        }
      }
      return i;
    };
    dropLeft = function(n) {
      return function(as) {
        return n <= 0 || isEmpty2(as) ? copy2(as) : n >= as.length ? [] : as.slice(n, as.length);
      };
    };
    dropRight = function(n) {
      return function(as) {
        return n <= 0 || isEmpty2(as) ? copy2(as) : n >= as.length ? [] : as.slice(0, as.length - n);
      };
    };
    findIndex2 = findIndex;
    findFirstMap2 = findFirstMap;
    findLastMap2 = findLastMap;
    findLastIndex2 = findLastIndex;
    copy2 = function(as) {
      return as.slice();
    };
    insertAt2 = function(i, a) {
      return function(as) {
        return i < 0 || i > as.length ? none : some(unsafeInsertAt3(i, a, as));
      };
    };
    updateAt2 = function(i, a) {
      return modifyAt2(i, function() {
        return a;
      });
    };
    deleteAt = function(i) {
      return function(as) {
        return isOutOfBound4(i, as) ? none : some(unsafeDeleteAt(i, as));
      };
    };
    modifyAt2 = function(i, f) {
      return function(as) {
        return isOutOfBound4(i, as) ? none : some(unsafeUpdateAt3(i, f(as[i]), as));
      };
    };
    reverse3 = function(as) {
      return isEmpty2(as) ? [] : as.slice().reverse();
    };
    rights = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Right") {
          r.push(a.right);
        }
      }
      return r;
    };
    lefts = function(as) {
      var r = [];
      for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === "Left") {
          r.push(a.left);
        }
      }
      return r;
    };
    sort2 = function(O) {
      return function(as) {
        return as.length <= 1 ? copy2(as) : as.slice().sort(O.compare);
      };
    };
    zipWith2 = function(fa, fb, f) {
      var fc = [];
      var len = Math.min(fa.length, fb.length);
      for (var i = 0; i < len; i++) {
        fc[i] = f(fa[i], fb[i]);
      }
      return fc;
    };
    unzip2 = function(as) {
      var fa = [];
      var fb = [];
      for (var i = 0; i < as.length; i++) {
        fa[i] = as[i][0];
        fb[i] = as[i][1];
      }
      return [fa, fb];
    };
    prependAll3 = function(middle) {
      var f = prependAll2(middle);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : [];
      };
    };
    intersperse3 = function(middle) {
      var f = intersperse2(middle);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    rotate3 = function(n) {
      var f = rotate(n);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    elem3 = elem2;
    uniq3 = function(E) {
      var f = uniq(E);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    sortBy3 = function(ords) {
      var f = sortBy(ords);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : copy2(as);
      };
    };
    chop3 = function(f) {
      var g = chop(f);
      return function(as) {
        return isNonEmpty6(as) ? g(as) : [];
      };
    };
    splitAt3 = function(n) {
      return function(as) {
        return n >= 1 && isNonEmpty6(as) ? splitAt(n)(as) : isEmpty2(as) ? [copy2(as), []] : [[], copy2(as)];
      };
    };
    chunksOf3 = function(n) {
      var f = chunksOf(n);
      return function(as) {
        return isNonEmpty6(as) ? f(as) : [];
      };
    };
    fromOptionK3 = function(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return fromOption3(f.apply(void 0, a));
      };
    };
    concatW2 = function(second) {
      return function(first2) {
        return isEmpty2(first2) ? copy2(second) : isEmpty2(second) ? copy2(first2) : first2.concat(second);
      };
    };
    concat2 = concatW2;
    _map6 = function(fa, f) {
      return pipe(fa, map6(f));
    };
    _mapWithIndex2 = function(fa, f) {
      return pipe(fa, mapWithIndex3(f));
    };
    _ap5 = function(fab, fa) {
      return pipe(fab, ap6(fa));
    };
    _chain5 = function(ma, f) {
      return pipe(ma, chain5(f));
    };
    _filter2 = function(fa, predicate) {
      return pipe(fa, filter3(predicate));
    };
    _filterMap2 = function(fa, f) {
      return pipe(fa, filterMap2(f));
    };
    _partition2 = function(fa, predicate) {
      return pipe(fa, partition2(predicate));
    };
    _partitionMap2 = function(fa, f) {
      return pipe(fa, partitionMap2(f));
    };
    _partitionWithIndex = function(fa, predicateWithIndex) {
      return pipe(fa, partitionWithIndex2(predicateWithIndex));
    };
    _partitionMapWithIndex = function(fa, f) {
      return pipe(fa, partitionMapWithIndex2(f));
    };
    _alt3 = function(fa, that) {
      return pipe(fa, alt3(that));
    };
    _reduce4 = function(fa, b, f) {
      return pipe(fa, reduce5(b, f));
    };
    _foldMap4 = function(M) {
      var foldMapM = foldMap5(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight4 = function(fa, b, f) {
      return pipe(fa, reduceRight5(b, f));
    };
    _reduceWithIndex2 = function(fa, b, f) {
      return pipe(fa, reduceWithIndex4(b, f));
    };
    _foldMapWithIndex2 = function(M) {
      var foldMapWithIndexM = foldMapWithIndex4(M);
      return function(fa, f) {
        return pipe(fa, foldMapWithIndexM(f));
      };
    };
    _reduceRightWithIndex2 = function(fa, b, f) {
      return pipe(fa, reduceRightWithIndex4(b, f));
    };
    _filterMapWithIndex = function(fa, f) {
      return pipe(fa, filterMapWithIndex2(f));
    };
    _filterWithIndex = function(fa, predicateWithIndex) {
      return pipe(fa, filterWithIndex2(predicateWithIndex));
    };
    _extend3 = function(fa, f) {
      return pipe(fa, extend5(f));
    };
    _traverse4 = function(F) {
      var traverseF = traverse4(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _traverseWithIndex2 = function(F) {
      var traverseWithIndexF = traverseWithIndex3(F);
      return function(ta, f) {
        return pipe(ta, traverseWithIndexF(f));
      };
    };
    _chainRecDepthFirst2 = _chainRecDepthFirst;
    _chainRecBreadthFirst2 = _chainRecBreadthFirst;
    of5 = of3;
    zero2 = function() {
      return [];
    };
    map6 = function(f) {
      return function(fa) {
        return fa.map(function(a) {
          return f(a);
        });
      };
    };
    ap6 = function(fa) {
      return chain5(function(f) {
        return pipe(fa, map6(f));
      });
    };
    chain5 = function(f) {
      return function(ma) {
        return pipe(ma, chainWithIndex4(function(_, a) {
          return f(a);
        }));
      };
    };
    flatten5 = chain5(identity);
    mapWithIndex3 = function(f) {
      return function(fa) {
        return fa.map(function(a, i) {
          return f(i, a);
        });
      };
    };
    filterMapWithIndex2 = function(f) {
      return function(fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
          var optionB = f(i, fa[i]);
          if (isSome(optionB)) {
            out.push(optionB.value);
          }
        }
        return out;
      };
    };
    filterMap2 = function(f) {
      return filterMapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    compact2 = filterMap2(identity);
    separate2 = function(fa) {
      var left4 = [];
      var right4 = [];
      for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === "Left") {
          left4.push(e.left);
        } else {
          right4.push(e.right);
        }
      }
      return separated(left4, right4);
    };
    filter3 = function(predicate) {
      return function(as) {
        return as.filter(predicate);
      };
    };
    partition2 = function(predicate) {
      return partitionWithIndex2(function(_, a) {
        return predicate(a);
      });
    };
    partitionWithIndex2 = function(predicateWithIndex) {
      return function(as) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < as.length; i++) {
          var b = as[i];
          if (predicateWithIndex(i, b)) {
            right4.push(b);
          } else {
            left4.push(b);
          }
        }
        return separated(left4, right4);
      };
    };
    partitionMap2 = function(f) {
      return partitionMapWithIndex2(function(_, a) {
        return f(a);
      });
    };
    partitionMapWithIndex2 = function(f) {
      return function(fa) {
        var left4 = [];
        var right4 = [];
        for (var i = 0; i < fa.length; i++) {
          var e = f(i, fa[i]);
          if (e._tag === "Left") {
            left4.push(e.left);
          } else {
            right4.push(e.right);
          }
        }
        return separated(left4, right4);
      };
    };
    altW3 = function(that) {
      return function(fa) {
        return fa.concat(that());
      };
    };
    alt3 = altW3;
    filterWithIndex2 = function(predicateWithIndex) {
      return function(as) {
        return as.filter(function(b, i) {
          return predicateWithIndex(i, b);
        });
      };
    };
    extend5 = function(f) {
      return function(wa) {
        return wa.map(function(_, i) {
          return f(wa.slice(i));
        });
      };
    };
    duplicate5 = extend5(identity);
    foldMap5 = foldMap4;
    foldMapWithIndex4 = foldMapWithIndex3;
    reduce5 = reduce4;
    reduceWithIndex4 = reduceWithIndex3;
    reduceRight5 = reduceRight4;
    reduceRightWithIndex4 = reduceRightWithIndex3;
    traverse4 = function(F) {
      var traverseWithIndexF = traverseWithIndex3(F);
      return function(f) {
        return traverseWithIndexF(function(_, a) {
          return f(a);
        });
      };
    };
    sequence4 = function(F) {
      return function(ta) {
        return _reduce4(ta, F.of(zero2()), function(fas, fa) {
          return F.ap(F.map(fas, function(as) {
            return function(a) {
              return pipe(as, append4(a));
            };
          }), fa);
        });
      };
    };
    traverseWithIndex3 = function(F) {
      return function(f) {
        return reduceWithIndex4(F.of(zero2()), function(i, fbs, a) {
          return F.ap(F.map(fbs, function(bs) {
            return function(b) {
              return pipe(bs, append4(b));
            };
          }), f(i, a));
        });
      };
    };
    wither = function(F) {
      var _witherF = _wither2(F);
      return function(f) {
        return function(fa) {
          return _witherF(fa, f);
        };
      };
    };
    wilt = function(F) {
      var _wiltF = _wilt2(F);
      return function(f) {
        return function(fa) {
          return _wiltF(fa, f);
        };
      };
    };
    unfold = function(b, f) {
      var out = [];
      var bb = b;
      while (true) {
        var mt = f(bb);
        if (isSome(mt)) {
          var _a = mt.value, a = _a[0], b_1 = _a[1];
          out.push(a);
          bb = b_1;
        } else {
          break;
        }
      }
      return out;
    };
    URI6 = "Array";
    getShow5 = getShow4;
    getSemigroup5 = function() {
      return {
        concat: function(first2, second) {
          return first2.concat(second);
        }
      };
    };
    getMonoid2 = function() {
      return {
        concat: getSemigroup5().concat,
        empty: []
      };
    };
    getEq5 = getEq4;
    getOrd2 = getOrd;
    getUnionSemigroup2 = function(E) {
      var unionE = union4(E);
      return {
        concat: function(first2, second) {
          return unionE(second)(first2);
        }
      };
    };
    getUnionMonoid = function(E) {
      return {
        concat: getUnionSemigroup2(E).concat,
        empty: []
      };
    };
    getIntersectionSemigroup = function(E) {
      var intersectionE = intersection2(E);
      return {
        concat: function(first2, second) {
          return intersectionE(second)(first2);
        }
      };
    };
    getDifferenceMagma = function(E) {
      var differenceE = difference(E);
      return {
        concat: function(first2, second) {
          return differenceE(second)(first2);
        }
      };
    };
    Functor6 = {
      URI: URI6,
      map: _map6
    };
    flap7 = flap(Functor6);
    Pointed4 = {
      URI: URI6,
      of: of5
    };
    FunctorWithIndex2 = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2
    };
    Apply5 = {
      URI: URI6,
      map: _map6,
      ap: _ap5
    };
    apFirst6 = apFirst(Apply5);
    apSecond6 = apSecond(Apply5);
    Applicative3 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5
    };
    Chain5 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5
    };
    chainFirst6 = chainFirst(Chain5);
    Monad3 = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5,
      chain: _chain5
    };
    Unfoldable = {
      URI: URI6,
      unfold
    };
    Alt3 = {
      URI: URI6,
      map: _map6,
      alt: _alt3
    };
    Zero2 = {
      URI: URI6,
      zero: zero2
    };
    guard3 = guard(Zero2, Pointed4);
    Alternative = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      of: of5,
      alt: _alt3,
      zero: zero2
    };
    Extend2 = {
      URI: URI6,
      map: _map6,
      extend: _extend3
    };
    Compactable2 = {
      URI: URI6,
      compact: compact2,
      separate: separate2
    };
    Filterable = {
      URI: URI6,
      map: _map6,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2
    };
    FilterableWithIndex = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex
    };
    Foldable3 = {
      URI: URI6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4
    };
    FoldableWithIndex2 = {
      URI: URI6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2
    };
    Traversable4 = {
      URI: URI6,
      map: _map6,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4
    };
    TraversableWithIndex2 = {
      URI: URI6,
      map: _map6,
      mapWithIndex: _mapWithIndex2,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2,
      traverse: _traverse4,
      sequence: sequence4,
      traverseWithIndex: _traverseWithIndex2
    };
    _wither2 = witherDefault(Traversable4, Compactable2);
    _wilt2 = wiltDefault(Traversable4, Compactable2);
    Witherable2 = {
      URI: URI6,
      map: _map6,
      compact: compact2,
      separate: separate2,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4,
      wither: _wither2,
      wilt: _wilt2
    };
    chainRecDepthFirst2 = chainRecDepthFirst;
    ChainRecDepthFirst = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5,
      chainRec: _chainRecDepthFirst2
    };
    chainRecBreadthFirst2 = chainRecBreadthFirst;
    ChainRecBreadthFirst = {
      URI: URI6,
      map: _map6,
      ap: _ap5,
      chain: _chain5,
      chainRec: _chainRecBreadthFirst2
    };
    filterE3 = filterE(Witherable2);
    FromEither3 = {
      URI: URI6,
      fromEither: fromEither2
    };
    fromEitherK3 = fromEitherK(FromEither3);
    unsafeInsertAt3 = unsafeInsertAt;
    unsafeUpdateAt3 = function(i, a, as) {
      return isNonEmpty6(as) ? unsafeUpdateAt(i, a, as) : [];
    };
    unsafeDeleteAt = function(i, as) {
      var xs = as.slice();
      xs.splice(i, 1);
      return xs;
    };
    every2 = every;
    some2 = function(predicate) {
      return function(as) {
        return as.some(predicate);
      };
    };
    exists2 = some2;
    intercalate4 = intercalate3;
    Do5 = of5(emptyRecord);
    bindTo6 = bindTo(Functor6);
    bind6 = bind(Chain5);
    apS6 = apS(Apply5);
    range3 = range;
    empty3 = [];
    cons3 = cons;
    snoc3 = snoc;
    prependToAll2 = prependAll3;
    array2 = {
      URI: URI6,
      compact: compact2,
      separate: separate2,
      map: _map6,
      ap: _ap5,
      of: of5,
      chain: _chain5,
      filter: _filter2,
      filterMap: _filterMap2,
      partition: _partition2,
      partitionMap: _partitionMap2,
      mapWithIndex: _mapWithIndex2,
      partitionMapWithIndex: _partitionMapWithIndex,
      partitionWithIndex: _partitionWithIndex,
      filterMapWithIndex: _filterMapWithIndex,
      filterWithIndex: _filterWithIndex,
      alt: _alt3,
      zero: zero2,
      unfold,
      reduce: _reduce4,
      foldMap: _foldMap4,
      reduceRight: _reduceRight4,
      traverse: _traverse4,
      sequence: sequence4,
      reduceWithIndex: _reduceWithIndex2,
      foldMapWithIndex: _foldMapWithIndex2,
      reduceRightWithIndex: _reduceRightWithIndex2,
      traverseWithIndex: _traverseWithIndex2,
      extend: _extend3,
      wither: _wither2,
      wilt: _wilt2
    };
  }
});

// node_modules/fp-ts/es6/Predicate.js
var not;
var init_Predicate = __esm({
  "node_modules/fp-ts/es6/Predicate.js"() {
    init_function();
    not = function(predicate) {
      return function(a) {
        return !predicate(a);
      };
    };
  }
});

// node_modules/fp-ts/es6/Option.js
var Option_exports = {};
__export(Option_exports, {
  Alt: () => Alt4,
  Alternative: () => Alternative2,
  ApT: () => ApT2,
  Applicative: () => Applicative4,
  Apply: () => Apply6,
  Chain: () => Chain6,
  Compactable: () => Compactable3,
  Do: () => Do6,
  Extend: () => Extend3,
  Filterable: () => Filterable2,
  Foldable: () => Foldable4,
  FromEither: () => FromEither4,
  Functor: () => Functor7,
  Monad: () => Monad4,
  MonadThrow: () => MonadThrow2,
  Pointed: () => Pointed5,
  Traversable: () => Traversable5,
  URI: () => URI7,
  Witherable: () => Witherable3,
  Zero: () => Zero3,
  alt: () => alt4,
  altW: () => altW4,
  ap: () => ap7,
  apFirst: () => apFirst7,
  apS: () => apS7,
  apSecond: () => apSecond7,
  bind: () => bind7,
  bindTo: () => bindTo7,
  chain: () => chain6,
  chainEitherK: () => chainEitherK2,
  chainFirst: () => chainFirst7,
  chainFirstEitherK: () => chainFirstEitherK2,
  chainNullableK: () => chainNullableK2,
  compact: () => compact3,
  duplicate: () => duplicate6,
  elem: () => elem4,
  exists: () => exists3,
  extend: () => extend6,
  filter: () => filter4,
  filterMap: () => filterMap3,
  flap: () => flap8,
  flatten: () => flatten6,
  fold: () => fold3,
  foldMap: () => foldMap6,
  foldW: () => foldW2,
  fromEither: () => fromEither3,
  fromEitherK: () => fromEitherK4,
  fromNullable: () => fromNullable2,
  fromNullableK: () => fromNullableK2,
  fromPredicate: () => fromPredicate4,
  getApplyMonoid: () => getApplyMonoid2,
  getApplySemigroup: () => getApplySemigroup3,
  getEq: () => getEq6,
  getFirstMonoid: () => getFirstMonoid,
  getLastMonoid: () => getLastMonoid,
  getLeft: () => getLeft,
  getMonoid: () => getMonoid3,
  getOrElse: () => getOrElse2,
  getOrElseW: () => getOrElseW2,
  getOrd: () => getOrd3,
  getRefinement: () => getRefinement,
  getRight: () => getRight,
  getShow: () => getShow6,
  guard: () => guard4,
  isNone: () => isNone2,
  isSome: () => isSome2,
  map: () => map7,
  mapNullable: () => mapNullable,
  match: () => match4,
  matchW: () => matchW4,
  none: () => none2,
  of: () => of6,
  option: () => option,
  partition: () => partition3,
  partitionMap: () => partitionMap3,
  reduce: () => reduce6,
  reduceRight: () => reduceRight6,
  separate: () => separate3,
  sequence: () => sequence5,
  sequenceArray: () => sequenceArray2,
  some: () => some3,
  throwError: () => throwError2,
  toNullable: () => toNullable,
  toUndefined: () => toUndefined,
  traverse: () => traverse5,
  traverseArray: () => traverseArray2,
  traverseArrayWithIndex: () => traverseArrayWithIndex2,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex2,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex2,
  tryCatch: () => tryCatch2,
  tryCatchK: () => tryCatchK2,
  wilt: () => wilt2,
  wither: () => wither2,
  zero: () => zero3
});
function fromPredicate4(predicate) {
  return function(a) {
    return predicate(a) ? some3(a) : none2;
  };
}
function elem4(E) {
  return function(a, ma) {
    if (ma === void 0) {
      var elemE_1 = elem4(E);
      return function(ma2) {
        return elemE_1(a, ma2);
      };
    }
    return isNone2(ma) ? false : E.equals(a, ma.value);
  };
}
function getRefinement(getOption) {
  return function(a) {
    return isSome2(getOption(a));
  };
}
var none2, some3, getLeft, getRight, _map7, _ap6, _chain6, _reduce5, _foldMap5, _reduceRight5, _traverse5, _alt4, _filter3, _filterMap3, _extend4, _partition3, _partitionMap3, URI7, getShow6, getEq6, getOrd3, getMonoid3, map7, Functor7, of6, Pointed5, ap7, Apply6, Applicative4, chain6, Chain6, Monad4, reduce6, foldMap6, reduceRight6, Foldable4, altW4, alt4, Alt4, zero3, Zero3, guard4, Alternative2, extend6, Extend3, compact3, defaultSeparated, separate3, Compactable3, filter4, filterMap3, partition3, partitionMap3, Filterable2, traverse5, sequence5, Traversable5, _wither3, _wilt3, wither2, wilt2, Witherable3, throwError2, MonadThrow2, fromEither3, FromEither4, isSome2, isNone2, matchW4, foldW2, match4, fold3, getOrElseW2, getOrElse2, flap8, apFirst7, apSecond7, flatten6, chainFirst7, duplicate6, fromEitherK4, chainEitherK2, chainFirstEitherK2, fromNullable2, tryCatch2, tryCatchK2, fromNullableK2, chainNullableK2, toNullable, toUndefined, exists3, Do6, bindTo7, bind7, apS7, ApT2, traverseReadonlyNonEmptyArrayWithIndex2, traverseReadonlyArrayWithIndex2, traverseArrayWithIndex2, traverseArray2, sequenceArray2, mapNullable, option, getApplySemigroup3, getApplyMonoid2, getFirstMonoid, getLastMonoid;
var init_Option = __esm({
  "node_modules/fp-ts/es6/Option.js"() {
    init_Applicative();
    init_Apply();
    init_Chain();
    init_FromEither();
    init_function();
    init_Functor();
    init_internal();
    init_Predicate();
    init_Semigroup();
    init_Separated();
    init_Witherable();
    init_Zero();
    none2 = none;
    some3 = some;
    getLeft = function(ma) {
      return ma._tag === "Right" ? none2 : some3(ma.left);
    };
    getRight = function(ma) {
      return ma._tag === "Left" ? none2 : some3(ma.right);
    };
    _map7 = function(fa, f) {
      return pipe(fa, map7(f));
    };
    _ap6 = function(fab, fa) {
      return pipe(fab, ap7(fa));
    };
    _chain6 = function(ma, f) {
      return pipe(ma, chain6(f));
    };
    _reduce5 = function(fa, b, f) {
      return pipe(fa, reduce6(b, f));
    };
    _foldMap5 = function(M) {
      var foldMapM = foldMap6(M);
      return function(fa, f) {
        return pipe(fa, foldMapM(f));
      };
    };
    _reduceRight5 = function(fa, b, f) {
      return pipe(fa, reduceRight6(b, f));
    };
    _traverse5 = function(F) {
      var traverseF = traverse5(F);
      return function(ta, f) {
        return pipe(ta, traverseF(f));
      };
    };
    _alt4 = function(fa, that) {
      return pipe(fa, alt4(that));
    };
    _filter3 = function(fa, predicate) {
      return pipe(fa, filter4(predicate));
    };
    _filterMap3 = function(fa, f) {
      return pipe(fa, filterMap3(f));
    };
    _extend4 = function(wa, f) {
      return pipe(wa, extend6(f));
    };
    _partition3 = function(fa, predicate) {
      return pipe(fa, partition3(predicate));
    };
    _partitionMap3 = function(fa, f) {
      return pipe(fa, partitionMap3(f));
    };
    URI7 = "Option";
    getShow6 = function(S) {
      return {
        show: function(ma) {
          return isNone2(ma) ? "none" : "some(".concat(S.show(ma.value), ")");
        }
      };
    };
    getEq6 = function(E) {
      return {
        equals: function(x, y) {
          return x === y || (isNone2(x) ? isNone2(y) : isNone2(y) ? false : E.equals(x.value, y.value));
        }
      };
    };
    getOrd3 = function(O) {
      return {
        equals: getEq6(O).equals,
        compare: function(x, y) {
          return x === y ? 0 : isSome2(x) ? isSome2(y) ? O.compare(x.value, y.value) : 1 : -1;
        }
      };
    };
    getMonoid3 = function(S) {
      return {
        concat: function(x, y) {
          return isNone2(x) ? y : isNone2(y) ? x : some3(S.concat(x.value, y.value));
        },
        empty: none2
      };
    };
    map7 = function(f) {
      return function(fa) {
        return isNone2(fa) ? none2 : some3(f(fa.value));
      };
    };
    Functor7 = {
      URI: URI7,
      map: _map7
    };
    of6 = some3;
    Pointed5 = {
      URI: URI7,
      of: of6
    };
    ap7 = function(fa) {
      return function(fab) {
        return isNone2(fab) ? none2 : isNone2(fa) ? none2 : some3(fab.value(fa.value));
      };
    };
    Apply6 = {
      URI: URI7,
      map: _map7,
      ap: _ap6
    };
    Applicative4 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6
    };
    chain6 = function(f) {
      return function(ma) {
        return isNone2(ma) ? none2 : f(ma.value);
      };
    };
    Chain6 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      chain: _chain6
    };
    Monad4 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      chain: _chain6
    };
    reduce6 = function(b, f) {
      return function(fa) {
        return isNone2(fa) ? b : f(b, fa.value);
      };
    };
    foldMap6 = function(M) {
      return function(f) {
        return function(fa) {
          return isNone2(fa) ? M.empty : f(fa.value);
        };
      };
    };
    reduceRight6 = function(b, f) {
      return function(fa) {
        return isNone2(fa) ? b : f(fa.value, b);
      };
    };
    Foldable4 = {
      URI: URI7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5
    };
    altW4 = function(that) {
      return function(fa) {
        return isNone2(fa) ? that() : fa;
      };
    };
    alt4 = altW4;
    Alt4 = {
      URI: URI7,
      map: _map7,
      alt: _alt4
    };
    zero3 = function() {
      return none2;
    };
    Zero3 = {
      URI: URI7,
      zero: zero3
    };
    guard4 = guard(Zero3, Pointed5);
    Alternative2 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      alt: _alt4,
      zero: zero3
    };
    extend6 = function(f) {
      return function(wa) {
        return isNone2(wa) ? none2 : some3(f(wa));
      };
    };
    Extend3 = {
      URI: URI7,
      map: _map7,
      extend: _extend4
    };
    compact3 = chain6(identity);
    defaultSeparated = separated(none2, none2);
    separate3 = function(ma) {
      return isNone2(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));
    };
    Compactable3 = {
      URI: URI7,
      compact: compact3,
      separate: separate3
    };
    filter4 = function(predicate) {
      return function(fa) {
        return isNone2(fa) ? none2 : predicate(fa.value) ? fa : none2;
      };
    };
    filterMap3 = function(f) {
      return function(fa) {
        return isNone2(fa) ? none2 : f(fa.value);
      };
    };
    partition3 = function(predicate) {
      return function(fa) {
        return separated(_filter3(fa, not(predicate)), _filter3(fa, predicate));
      };
    };
    partitionMap3 = function(f) {
      return flow(map7(f), separate3);
    };
    Filterable2 = {
      URI: URI7,
      map: _map7,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3
    };
    traverse5 = function(F) {
      return function(f) {
        return function(ta) {
          return isNone2(ta) ? F.of(none2) : F.map(f(ta.value), some3);
        };
      };
    };
    sequence5 = function(F) {
      return function(ta) {
        return isNone2(ta) ? F.of(none2) : F.map(ta.value, some3);
      };
    };
    Traversable5 = {
      URI: URI7,
      map: _map7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5
    };
    _wither3 = witherDefault(Traversable5, Compactable3);
    _wilt3 = wiltDefault(Traversable5, Compactable3);
    wither2 = function(F) {
      var _witherF = _wither3(F);
      return function(f) {
        return function(fa) {
          return _witherF(fa, f);
        };
      };
    };
    wilt2 = function(F) {
      var _wiltF = _wilt3(F);
      return function(f) {
        return function(fa) {
          return _wiltF(fa, f);
        };
      };
    };
    Witherable3 = {
      URI: URI7,
      map: _map7,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3,
      wither: _wither3,
      wilt: _wilt3
    };
    throwError2 = function() {
      return none2;
    };
    MonadThrow2 = {
      URI: URI7,
      map: _map7,
      ap: _ap6,
      of: of6,
      chain: _chain6,
      throwError: throwError2
    };
    fromEither3 = getRight;
    FromEither4 = {
      URI: URI7,
      fromEither: fromEither3
    };
    isSome2 = isSome;
    isNone2 = function(fa) {
      return fa._tag === "None";
    };
    matchW4 = function(onNone, onSome) {
      return function(ma) {
        return isNone2(ma) ? onNone() : onSome(ma.value);
      };
    };
    foldW2 = matchW4;
    match4 = matchW4;
    fold3 = match4;
    getOrElseW2 = function(onNone) {
      return function(ma) {
        return isNone2(ma) ? onNone() : ma.value;
      };
    };
    getOrElse2 = getOrElseW2;
    flap8 = flap(Functor7);
    apFirst7 = apFirst(Apply6);
    apSecond7 = apSecond(Apply6);
    flatten6 = compact3;
    chainFirst7 = chainFirst(Chain6);
    duplicate6 = extend6(identity);
    fromEitherK4 = fromEitherK(FromEither4);
    chainEitherK2 = chainEitherK(FromEither4, Chain6);
    chainFirstEitherK2 = chainFirstEitherK(FromEither4, Chain6);
    fromNullable2 = function(a) {
      return a == null ? none2 : some3(a);
    };
    tryCatch2 = function(f) {
      try {
        return some3(f());
      } catch (e) {
        return none2;
      }
    };
    tryCatchK2 = function(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return tryCatch2(function() {
          return f.apply(void 0, a);
        });
      };
    };
    fromNullableK2 = function(f) {
      return flow(f, fromNullable2);
    };
    chainNullableK2 = function(f) {
      return function(ma) {
        return isNone2(ma) ? none2 : fromNullable2(f(ma.value));
      };
    };
    toNullable = match4(constNull, identity);
    toUndefined = match4(constUndefined, identity);
    exists3 = function(predicate) {
      return function(ma) {
        return isNone2(ma) ? false : predicate(ma.value);
      };
    };
    Do6 = of6(emptyRecord);
    bindTo7 = bindTo(Functor7);
    bind7 = bind(Chain6);
    apS7 = apS(Apply6);
    ApT2 = of6(emptyReadonlyArray);
    traverseReadonlyNonEmptyArrayWithIndex2 = function(f) {
      return function(as) {
        var o = f(0, head(as));
        if (isNone2(o)) {
          return none2;
        }
        var out = [o.value];
        for (var i = 1; i < as.length; i++) {
          var o_1 = f(i, as[i]);
          if (isNone2(o_1)) {
            return none2;
          }
          out.push(o_1.value);
        }
        return some3(out);
      };
    };
    traverseReadonlyArrayWithIndex2 = function(f) {
      var g = traverseReadonlyNonEmptyArrayWithIndex2(f);
      return function(as) {
        return isNonEmpty(as) ? g(as) : ApT2;
      };
    };
    traverseArrayWithIndex2 = traverseReadonlyArrayWithIndex2;
    traverseArray2 = function(f) {
      return traverseReadonlyArrayWithIndex2(function(_, a) {
        return f(a);
      });
    };
    sequenceArray2 = traverseArray2(identity);
    mapNullable = chainNullableK2;
    option = {
      URI: URI7,
      map: _map7,
      of: of6,
      ap: _ap6,
      chain: _chain6,
      reduce: _reduce5,
      foldMap: _foldMap5,
      reduceRight: _reduceRight5,
      traverse: _traverse5,
      sequence: sequence5,
      zero: zero3,
      alt: _alt4,
      extend: _extend4,
      compact: compact3,
      separate: separate3,
      filter: _filter3,
      filterMap: _filterMap3,
      partition: _partition3,
      partitionMap: _partitionMap3,
      wither: _wither3,
      wilt: _wilt3,
      throwError: throwError2
    };
    getApplySemigroup3 = getApplySemigroup(Apply6);
    getApplyMonoid2 = getApplicativeMonoid(Applicative4);
    getFirstMonoid = function() {
      return getMonoid3(first());
    };
    getLastMonoid = function() {
      return getMonoid3(last());
    };
  }
});

// node_modules/fp-ts/es6/string.js
var Eq2, Semigroup, empty4, Monoid, Ord2;
var init_string = __esm({
  "node_modules/fp-ts/es6/string.js"() {
    init_ReadonlyNonEmptyArray();
    Eq2 = {
      equals: function(first2, second) {
        return first2 === second;
      }
    };
    Semigroup = {
      concat: function(first2, second) {
        return first2 + second;
      }
    };
    empty4 = "";
    Monoid = {
      concat: Semigroup.concat,
      empty: empty4
    };
    Ord2 = {
      equals: Eq2.equals,
      compare: function(first2, second) {
        return first2 < second ? -1 : first2 > second ? 1 : 0;
      }
    };
  }
});

// node_modules/fp-ts/es6/ReadonlyRecord.js
function collect(O) {
  if (typeof O === "function") {
    return collect(Ord2)(O);
  }
  var keysO = keys_(O);
  return function(f) {
    return function(r) {
      var out = [];
      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
        var key = _a[_i];
        out.push(f(key, r[key]));
      }
      return out;
    };
  };
}
function isSubrecord(E) {
  return function(me, that) {
    if (that === void 0) {
      var isSubrecordE_1 = isSubrecord(E);
      return function(that2) {
        return isSubrecordE_1(that2, me);
      };
    }
    for (var k in me) {
      if (!has.call(that, k) || !E.equals(me[k], that[k])) {
        return false;
      }
    }
    return true;
  };
}
function lookup3(k, r) {
  if (r === void 0) {
    return function(r2) {
      return lookup3(k, r2);
    };
  }
  return has.call(r, k) ? some(r[k]) : none;
}
function mapWithIndex4(f) {
  return function(r) {
    var out = {};
    for (var k in r) {
      if (has.call(r, k)) {
        out[k] = f(k, r[k]);
      }
    }
    return out;
  };
}
function map8(f) {
  return mapWithIndex4(function(_, a) {
    return f(a);
  });
}
function reduceWithIndex5() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 2) {
    return reduceWithIndex5(Ord2).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b, f) {
    return function(fa) {
      var out = b;
      var ks = keysO(fa);
      var len = ks.length;
      for (var i = 0; i < len; i++) {
        var k = ks[i];
        out = f(k, out, fa[k]);
      }
      return out;
    };
  };
}
function foldMapWithIndex5(O) {
  if ("compare" in O) {
    var keysO_1 = keys_(O);
    return function(M) {
      return function(f) {
        return function(fa) {
          var out = M.empty;
          var ks = keysO_1(fa);
          var len = ks.length;
          for (var i = 0; i < len; i++) {
            var k = ks[i];
            out = M.concat(out, f(k, fa[k]));
          }
          return out;
        };
      };
    };
  }
  return foldMapWithIndex5(Ord2)(O);
}
function reduceRightWithIndex5() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 2) {
    return reduceRightWithIndex5(Ord2).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b, f) {
    return function(fa) {
      var out = b;
      var ks = keysO(fa);
      var len = ks.length;
      for (var i = len - 1; i >= 0; i--) {
        var k = ks[i];
        out = f(k, fa[k], out);
      }
      return out;
    };
  };
}
function traverseWithIndex4(F) {
  var traverseWithIndexOF = _traverseWithIndex3(Ord2)(F);
  return function(f) {
    return function(ta) {
      return traverseWithIndexOF(ta, f);
    };
  };
}
function traverse6(F) {
  var traverseOF = _traverse6(Ord2)(F);
  return function(f) {
    return function(ta) {
      return traverseOF(ta, f);
    };
  };
}
function sequence6(F) {
  return _sequence(Ord2)(F);
}
function partitionMapWithIndex3(f) {
  return function(r) {
    var left4 = {};
    var right4 = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var e = f(k, r[k]);
        switch (e._tag) {
          case "Left":
            left4[k] = e.left;
            break;
          case "Right":
            right4[k] = e.right;
            break;
        }
      }
    }
    return separated(left4, right4);
  };
}
function partitionWithIndex3(predicateWithIndex) {
  return function(r) {
    var left4 = {};
    var right4 = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var a = r[k];
        if (predicateWithIndex(k, a)) {
          right4[k] = a;
        } else {
          left4[k] = a;
        }
      }
    }
    return separated(left4, right4);
  };
}
function filterMapWithIndex3(f) {
  return function(r) {
    var out = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var ob = f(k, r[k]);
        if (isSome(ob)) {
          out[k] = ob.value;
        }
      }
    }
    return out;
  };
}
function filterWithIndex3(predicateWithIndex) {
  return function(fa) {
    var out = {};
    var changed = false;
    for (var key in fa) {
      if (has.call(fa, key)) {
        var a = fa[key];
        if (predicateWithIndex(key, a)) {
          out[key] = a;
        } else {
          changed = true;
        }
      }
    }
    return changed ? out : fa;
  };
}
function fromFoldable(M, F) {
  var fromFoldableMapM = fromFoldableMap(M, F);
  return function(fka) {
    return fromFoldableMapM(fka, identity);
  };
}
function fromFoldableMap(M, F) {
  return function(ta, f) {
    return F.reduce(ta, {}, function(r, a) {
      var _a = f(a), k = _a[0], b = _a[1];
      r[k] = has.call(r, k) ? M.concat(r[k], b) : b;
      return r;
    });
  };
}
function every3(predicate) {
  return function(r) {
    for (var k in r) {
      if (!predicate(r[k])) {
        return false;
      }
    }
    return true;
  };
}
function some4(predicate) {
  return function(r) {
    for (var k in r) {
      if (predicate(r[k])) {
        return true;
      }
    }
    return false;
  };
}
function elem5(E) {
  return function(a, fa) {
    if (fa === void 0) {
      var elemE_1 = elem5(E);
      return function(fa2) {
        return elemE_1(a, fa2);
      };
    }
    for (var k in fa) {
      if (E.equals(fa[k], a)) {
        return true;
      }
    }
    return false;
  };
}
function reduce7() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 1) {
    var reduceWithIndexO_1 = reduceWithIndex5(args[0]);
    return function(b, f) {
      return reduceWithIndexO_1(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
  }
  return reduce7(Ord2).apply(void 0, args);
}
function foldMap7(O) {
  if ("compare" in O) {
    var foldMapWithIndexO_1 = foldMapWithIndex5(O);
    return function(M) {
      var foldMapWithIndexM = foldMapWithIndexO_1(M);
      return function(f) {
        return foldMapWithIndexM(function(_, a) {
          return f(a);
        });
      };
    };
  }
  return foldMap7(Ord2)(O);
}
function reduceRight7() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length === 1) {
    var reduceRightWithIndexO_1 = reduceRightWithIndex5(args[0]);
    return function(b, f) {
      return reduceRightWithIndexO_1(b, function(_, b2, a) {
        return f(b2, a);
      });
    };
  }
  return reduceRight7(Ord2).apply(void 0, args);
}
function getShow7(O) {
  if ("compare" in O) {
    return function(S) {
      return {
        show: function(r) {
          var elements = collect(O)(function(k, a) {
            return "".concat(JSON.stringify(k), ": ").concat(S.show(a));
          })(r).join(", ");
          return elements === "" ? "{}" : "{ ".concat(elements, " }");
        }
      };
    };
  }
  return getShow7(Ord2)(O);
}
function getEq7(E) {
  var isSubrecordE = isSubrecord(E);
  return fromEquals(function(x, y) {
    return isSubrecordE(x)(y) && isSubrecordE(y)(x);
  });
}
function getMonoid4(S) {
  return {
    concat: function(first2, second) {
      if (isEmpty3(first2)) {
        return second;
      }
      if (isEmpty3(second)) {
        return first2;
      }
      var r = Object.assign({}, first2);
      for (var k in second) {
        if (has.call(second, k)) {
          r[k] = has.call(first2, k) ? S.concat(first2[k], second[k]) : second[k];
        }
      }
      return r;
    },
    empty: empty5
  };
}
function hasOwnProperty2(k, r) {
  return has.call(r === void 0 ? this : r, k);
}
var size2, isEmpty3, keys_, keys, toReadonlyArray, upsertAt, has2, empty5, singleton2, union5, intersection3, difference2, _map8, _mapWithIndex3, _reduce6, _foldMap6, _reduceRight6, _filter4, _filterMap4, _partition4, _partitionMap4, _reduceWithIndex3, _foldMapWithIndex3, _reduceRightWithIndex3, _partitionMapWithIndex2, _partitionWithIndex2, _filterMapWithIndex2, _filterWithIndex2, _traverse6, _sequence, _traverseWithIndex3, filter5, filterMap4, partition4, partitionMap4, compact4, separate4, URI8, Functor8, flap9, Compactable4, Foldable5, FoldableWithIndex3, Traversable6, TraversableWithIndex3, _wither4, _wilt4, Witherable4, readonlyRecord;
var init_ReadonlyRecord = __esm({
  "node_modules/fp-ts/es6/ReadonlyRecord.js"() {
    init_Eq();
    init_function();
    init_Functor();
    init_internal();
    init_Separated();
    init_string();
    init_Witherable();
    size2 = function(r) {
      return Object.keys(r).length;
    };
    isEmpty3 = function(r) {
      for (var k in r) {
        if (has.call(r, k)) {
          return false;
        }
      }
      return true;
    };
    keys_ = function(O) {
      return function(r) {
        return Object.keys(r).sort(O.compare);
      };
    };
    keys = keys_(Ord2);
    toReadonlyArray = collect(Ord2)(function(k, a) {
      return [k, a];
    });
    upsertAt = function(k, a) {
      return function(r) {
        if (has.call(r, k) && r[k] === a) {
          return r;
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return out;
      };
    };
    has2 = function(k, r) {
      return has.call(r, k);
    };
    empty5 = {};
    singleton2 = function(k, a) {
      var _a;
      return _a = {}, _a[k] = a, _a;
    };
    union5 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty3(first2)) {
            return second;
          }
          if (isEmpty3(second)) {
            return first2;
          }
          var out = {};
          for (var k in first2) {
            if (has2(k, second)) {
              out[k] = M.concat(first2[k], second[k]);
            } else {
              out[k] = first2[k];
            }
          }
          for (var k in second) {
            if (!has2(k, out)) {
              out[k] = second[k];
            }
          }
          return out;
        };
      };
    };
    intersection3 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty3(first2) || isEmpty3(second)) {
            return empty5;
          }
          var out = {};
          for (var k in first2) {
            if (has2(k, second)) {
              out[k] = M.concat(first2[k], second[k]);
            }
          }
          return out;
        };
      };
    };
    difference2 = function(second) {
      return function(first2) {
        if (isEmpty3(first2)) {
          return second;
        }
        if (isEmpty3(second)) {
          return first2;
        }
        var out = {};
        for (var k in first2) {
          if (!has2(k, second)) {
            out[k] = first2[k];
          }
        }
        for (var k in second) {
          if (!has2(k, first2)) {
            out[k] = second[k];
          }
        }
        return out;
      };
    };
    _map8 = function(fa, f) {
      return pipe(fa, map8(f));
    };
    _mapWithIndex3 = function(fa, f) {
      return pipe(fa, mapWithIndex4(f));
    };
    _reduce6 = function(O) {
      var reduceO = reduce7(O);
      return function(fa, b, f) {
        return pipe(fa, reduceO(b, f));
      };
    };
    _foldMap6 = function(O) {
      return function(M) {
        var foldMapM = foldMap7(O)(M);
        return function(fa, f) {
          return pipe(fa, foldMapM(f));
        };
      };
    };
    _reduceRight6 = function(O) {
      var reduceRightO = reduceRight7(O);
      return function(fa, b, f) {
        return pipe(fa, reduceRightO(b, f));
      };
    };
    _filter4 = function(fa, predicate) {
      return pipe(fa, filter5(predicate));
    };
    _filterMap4 = function(fa, f) {
      return pipe(fa, filterMap4(f));
    };
    _partition4 = function(fa, predicate) {
      return pipe(fa, partition4(predicate));
    };
    _partitionMap4 = function(fa, f) {
      return pipe(fa, partitionMap4(f));
    };
    _reduceWithIndex3 = function(O) {
      var reduceWithIndexO = reduceWithIndex5(O);
      return function(fa, b, f) {
        return pipe(fa, reduceWithIndexO(b, f));
      };
    };
    _foldMapWithIndex3 = function(O) {
      var foldMapWithIndexO = foldMapWithIndex5(O);
      return function(M) {
        var foldMapWithIndexM = foldMapWithIndexO(M);
        return function(fa, f) {
          return pipe(fa, foldMapWithIndexM(f));
        };
      };
    };
    _reduceRightWithIndex3 = function(O) {
      var reduceRightWithIndexO = reduceRightWithIndex5(O);
      return function(fa, b, f) {
        return pipe(fa, reduceRightWithIndexO(b, f));
      };
    };
    _partitionMapWithIndex2 = function(fa, f) {
      return pipe(fa, partitionMapWithIndex3(f));
    };
    _partitionWithIndex2 = function(fa, predicateWithIndex) {
      return pipe(fa, partitionWithIndex3(predicateWithIndex));
    };
    _filterMapWithIndex2 = function(fa, f) {
      return pipe(fa, filterMapWithIndex3(f));
    };
    _filterWithIndex2 = function(fa, predicateWithIndex) {
      return pipe(fa, filterWithIndex3(predicateWithIndex));
    };
    _traverse6 = function(O) {
      var traverseWithIndexO = _traverseWithIndex3(O);
      return function(F) {
        var traverseWithIndexOF = traverseWithIndexO(F);
        return function(ta, f) {
          return traverseWithIndexOF(ta, flow(SK, f));
        };
      };
    };
    _sequence = function(O) {
      var traverseO = _traverse6(O);
      return function(F) {
        var traverseOF = traverseO(F);
        return function(ta) {
          return traverseOF(ta, identity);
        };
      };
    };
    _traverseWithIndex3 = function(O) {
      return function(F) {
        var keysO = keys_(O);
        return function(ta, f) {
          var ks = keysO(ta);
          if (ks.length === 0) {
            return F.of(empty5);
          }
          var fr = F.of({});
          var _loop_1 = function(key2) {
            fr = F.ap(F.map(fr, function(r) {
              return function(b) {
                var _a;
                return Object.assign({}, r, (_a = {}, _a[key2] = b, _a));
              };
            }), f(key2, ta[key2]));
          };
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            _loop_1(key);
          }
          return fr;
        };
      };
    };
    filter5 = function(predicate) {
      return filterWithIndex3(function(_, a) {
        return predicate(a);
      });
    };
    filterMap4 = function(f) {
      return filterMapWithIndex3(function(_, a) {
        return f(a);
      });
    };
    partition4 = function(predicate) {
      return partitionWithIndex3(function(_, a) {
        return predicate(a);
      });
    };
    partitionMap4 = function(f) {
      return partitionMapWithIndex3(function(_, a) {
        return f(a);
      });
    };
    compact4 = function(r) {
      var out = {};
      for (var k in r) {
        if (has.call(r, k)) {
          var oa = r[k];
          if (isSome(oa)) {
            out[k] = oa.value;
          }
        }
      }
      return out;
    };
    separate4 = function(r) {
      var left4 = {};
      var right4 = {};
      for (var k in r) {
        if (has.call(r, k)) {
          var e = r[k];
          if (isLeft(e)) {
            left4[k] = e.left;
          } else {
            right4[k] = e.right;
          }
        }
      }
      return separated(left4, right4);
    };
    URI8 = "ReadonlyRecord";
    Functor8 = {
      URI: URI8,
      map: _map8
    };
    flap9 = flap(Functor8);
    Compactable4 = {
      URI: URI8,
      compact: compact4,
      separate: separate4
    };
    Foldable5 = {
      URI: URI8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2)
    };
    FoldableWithIndex3 = {
      URI: URI8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2)
    };
    Traversable6 = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6
    };
    TraversableWithIndex3 = {
      URI: URI8,
      map: _map8,
      mapWithIndex: _mapWithIndex3,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      traverseWithIndex: _traverseWithIndex3(Ord2)
    };
    _wither4 = witherDefault(Traversable6, Compactable4);
    _wilt4 = wiltDefault(Traversable6, Compactable4);
    Witherable4 = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      compact: compact4,
      separate: separate4,
      filter: _filter4,
      filterMap: _filterMap4,
      partition: _partition4,
      partitionMap: _partitionMap4,
      wither: _wither4,
      wilt: _wilt4
    };
    readonlyRecord = {
      URI: URI8,
      map: _map8,
      reduce: _reduce6(Ord2),
      foldMap: _foldMap6(Ord2),
      reduceRight: _reduceRight6(Ord2),
      traverse: _traverse6(Ord2),
      sequence: sequence6,
      compact: compact4,
      separate: separate4,
      filter: _filter4,
      filterMap: _filterMap4,
      partition: _partition4,
      partitionMap: _partitionMap4,
      mapWithIndex: _mapWithIndex3,
      reduceWithIndex: _reduceWithIndex3(Ord2),
      foldMapWithIndex: _foldMapWithIndex3(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex3(Ord2),
      filterMapWithIndex: _filterMapWithIndex2,
      filterWithIndex: _filterWithIndex2,
      partitionMapWithIndex: _partitionMapWithIndex2,
      partitionWithIndex: _partitionWithIndex2,
      traverseWithIndex: _traverseWithIndex3(Ord2),
      wither: _wither4,
      wilt: _wilt4
    };
  }
});

// node_modules/fp-ts/es6/Record.js
var Record_exports = {};
__export(Record_exports, {
  Compactable: () => Compactable5,
  Filterable: () => Filterable3,
  FilterableWithIndex: () => FilterableWithIndex2,
  Foldable: () => Foldable6,
  FoldableWithIndex: () => FoldableWithIndex4,
  Functor: () => Functor9,
  FunctorWithIndex: () => FunctorWithIndex3,
  Traversable: () => Traversable7,
  TraversableWithIndex: () => TraversableWithIndex4,
  URI: () => URI9,
  Witherable: () => Witherable5,
  collect: () => collect2,
  compact: () => compact5,
  deleteAt: () => deleteAt2,
  difference: () => difference3,
  elem: () => elem6,
  empty: () => empty6,
  every: () => every4,
  filter: () => filter6,
  filterMap: () => filterMap5,
  filterMapWithIndex: () => filterMapWithIndex4,
  filterWithIndex: () => filterWithIndex4,
  flap: () => flap10,
  foldMap: () => foldMap8,
  foldMapWithIndex: () => foldMapWithIndex6,
  fromEntries: () => fromEntries,
  fromFoldable: () => fromFoldable2,
  fromFoldableMap: () => fromFoldableMap2,
  getDifferenceMagma: () => getDifferenceMagma2,
  getEq: () => getEq8,
  getFoldable: () => getFoldable,
  getFoldableWithIndex: () => getFoldableWithIndex,
  getIntersectionSemigroup: () => getIntersectionSemigroup2,
  getMonoid: () => getMonoid5,
  getShow: () => getShow8,
  getTraversable: () => getTraversable,
  getTraversableWithIndex: () => getTraversableWithIndex,
  getUnionMonoid: () => getUnionMonoid2,
  getUnionSemigroup: () => getUnionSemigroup3,
  getWitherable: () => getWitherable2,
  has: () => has3,
  hasOwnProperty: () => hasOwnProperty3,
  insertAt: () => insertAt3,
  intersection: () => intersection4,
  isEmpty: () => isEmpty4,
  isSubrecord: () => isSubrecord2,
  keys: () => keys2,
  lookup: () => lookup4,
  map: () => map9,
  mapWithIndex: () => mapWithIndex5,
  modifyAt: () => modifyAt3,
  partition: () => partition5,
  partitionMap: () => partitionMap5,
  partitionMapWithIndex: () => partitionMapWithIndex4,
  partitionWithIndex: () => partitionWithIndex4,
  pop: () => pop,
  record: () => record2,
  reduce: () => reduce8,
  reduceRight: () => reduceRight8,
  reduceRightWithIndex: () => reduceRightWithIndex6,
  reduceWithIndex: () => reduceWithIndex6,
  separate: () => separate5,
  sequence: () => sequence7,
  singleton: () => singleton3,
  size: () => size3,
  some: () => some5,
  toArray: () => toArray,
  toEntries: () => toEntries,
  toUnfoldable: () => toUnfoldable,
  traverse: () => traverse7,
  traverseWithIndex: () => traverseWithIndex5,
  union: () => union6,
  updateAt: () => updateAt3,
  upsertAt: () => upsertAt2,
  wilt: () => wilt3,
  wither: () => wither3
});
function collect2(O) {
  if (typeof O === "function") {
    return collect2(Ord2)(O);
  }
  var keysO = keys_2(O);
  return function(f) {
    return function(r) {
      var out = [];
      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
        var key = _a[_i];
        out.push(f(key, r[key]));
      }
      return out;
    };
  };
}
function toUnfoldable(U) {
  return function(r) {
    var sas = toArray(r);
    var len = sas.length;
    return U.unfold(0, function(b) {
      return b < len ? some([sas[b], b + 1]) : none;
    });
  };
}
function deleteAt2(k) {
  return function(r) {
    if (!has.call(r, k)) {
      return r;
    }
    var out = Object.assign({}, r);
    delete out[k];
    return out;
  };
}
function pop(k) {
  var deleteAtk = deleteAt2(k);
  return function(r) {
    var oa = lookup4(k, r);
    return isNone(oa) ? none : some([oa.value, deleteAtk(r)]);
  };
}
function reduceWithIndex6() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceWithIndex5(args[0]) : reduceWithIndex5(Ord2).apply(void 0, args);
}
function foldMapWithIndex6(O) {
  return "compare" in O ? foldMapWithIndex5(O) : foldMapWithIndex5(Ord2)(O);
}
function reduceRightWithIndex6() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceRightWithIndex5(args[0]) : reduceRightWithIndex5(Ord2).apply(void 0, args);
}
function traverseWithIndex5(F) {
  return traverseWithIndex4(F);
}
function traverse7(F) {
  return traverse6(F);
}
function sequence7(F) {
  return sequence6(F);
}
function partitionWithIndex4(predicateWithIndex) {
  return partitionWithIndex3(predicateWithIndex);
}
function filterWithIndex4(predicateWithIndex) {
  return filterWithIndex3(predicateWithIndex);
}
function fromFoldable2(M, F) {
  return fromFoldable(M, F);
}
function fromFoldableMap2(M, F) {
  return fromFoldableMap(M, F);
}
function reduce8() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduce7(args[0]) : reduce7(Ord2).apply(void 0, args);
}
function foldMap8(O) {
  return "compare" in O ? foldMap7(O) : foldMap7(Ord2)(O);
}
function reduceRight8() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.length === 1 ? reduceRight7(args[0]) : reduceRight7(Ord2).apply(void 0, args);
}
function getShow8(O) {
  return "compare" in O ? getShow7(O) : getShow7(Ord2)(O);
}
var __assign2, size3, isEmpty4, keys_2, keys2, toArray, upsertAt2, has3, updateAt3, modifyAt3, isSubrecord2, lookup4, mapWithIndex5, map9, singleton3, wither3, wilt3, partitionMapWithIndex4, filterMapWithIndex4, toEntries, fromEntries, every4, some5, elem6, union6, intersection4, difference3, _map9, _mapWithIndex4, _reduce7, _foldMap7, _reduceRight7, _filter5, _filterMap5, _partition5, _partitionMap5, _reduceWithIndex4, _foldMapWithIndex4, _reduceRightWithIndex4, _partitionMapWithIndex3, _partitionWithIndex3, _filterMapWithIndex3, _filterWithIndex3, _traverse7, _sequence2, _traverseWithIndex4, filter6, filterMap5, partition5, partitionMap5, compact5, separate5, URI9, getEq8, getMonoid5, Functor9, flap10, FunctorWithIndex3, getFoldable, getFoldableWithIndex, Compactable5, Filterable3, FilterableWithIndex2, getTraversable, getTraversableWithIndex, getWitherable2, getUnionSemigroup3, getUnionMonoid2, getIntersectionSemigroup2, getDifferenceMagma2, Foldable6, FoldableWithIndex4, Traversable7, TraversableWithIndex4, _wither5, _wilt5, Witherable5, empty6, insertAt3, hasOwnProperty3, record2;
var init_Record = __esm({
  "node_modules/fp-ts/es6/Record.js"() {
    init_Array();
    init_function();
    init_Functor();
    init_internal();
    init_ReadonlyRecord();
    init_Semigroup();
    init_string();
    init_Witherable();
    __assign2 = function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    size3 = size2;
    isEmpty4 = isEmpty3;
    keys_2 = function(O) {
      return function(r) {
        return Object.keys(r).sort(O.compare);
      };
    };
    keys2 = keys_2(Ord2);
    toArray = collect2(Ord2)(function(k, a) {
      return [
        k,
        a
      ];
    });
    upsertAt2 = upsertAt;
    has3 = has2;
    updateAt3 = function(k, a) {
      return modifyAt3(k, function() {
        return a;
      });
    };
    modifyAt3 = function(k, f) {
      return function(r) {
        if (!has3(k, r)) {
          return none;
        }
        var out = Object.assign({}, r);
        out[k] = f(r[k]);
        return some(out);
      };
    };
    isSubrecord2 = isSubrecord;
    lookup4 = lookup3;
    mapWithIndex5 = mapWithIndex4;
    map9 = map8;
    singleton3 = singleton2;
    wither3 = function(F) {
      var traverseF = traverse7(F);
      return function(f) {
        return function(fa) {
          return F.map(pipe(fa, traverseF(f)), compact5);
        };
      };
    };
    wilt3 = function(F) {
      var traverseF = traverse7(F);
      return function(f) {
        return function(fa) {
          return F.map(pipe(fa, traverseF(f)), separate5);
        };
      };
    };
    partitionMapWithIndex4 = partitionMapWithIndex3;
    filterMapWithIndex4 = filterMapWithIndex3;
    toEntries = toArray;
    fromEntries = function(fa) {
      return fromFoldable2(last(), Foldable3)(fa);
    };
    every4 = every3;
    some5 = some4;
    elem6 = elem5;
    union6 = function(M) {
      var unionM = union5(M);
      return function(second) {
        return function(first2) {
          if (isEmpty4(first2)) {
            return __assign2({}, second);
          }
          if (isEmpty4(second)) {
            return __assign2({}, first2);
          }
          return unionM(second)(first2);
        };
      };
    };
    intersection4 = function(M) {
      return function(second) {
        return function(first2) {
          if (isEmpty4(first2) || isEmpty4(second)) {
            return {};
          }
          return intersection3(M)(second)(first2);
        };
      };
    };
    difference3 = function(second) {
      return function(first2) {
        if (isEmpty4(first2)) {
          return __assign2({}, second);
        }
        if (isEmpty4(second)) {
          return __assign2({}, first2);
        }
        return difference2(second)(first2);
      };
    };
    _map9 = _map8;
    _mapWithIndex4 = _mapWithIndex3;
    _reduce7 = _reduce6;
    _foldMap7 = _foldMap6;
    _reduceRight7 = _reduceRight6;
    _filter5 = _filter4;
    _filterMap5 = _filterMap4;
    _partition5 = _partition4;
    _partitionMap5 = _partitionMap4;
    _reduceWithIndex4 = _reduceWithIndex3;
    _foldMapWithIndex4 = _foldMapWithIndex3;
    _reduceRightWithIndex4 = _reduceRightWithIndex3;
    _partitionMapWithIndex3 = _partitionMapWithIndex2;
    _partitionWithIndex3 = _partitionWithIndex2;
    _filterMapWithIndex3 = _filterMapWithIndex2;
    _filterWithIndex3 = _filterWithIndex2;
    _traverse7 = _traverse6;
    _sequence2 = _sequence;
    _traverseWithIndex4 = function(O) {
      return function(F) {
        var keysO = keys_2(O);
        return function(ta, f) {
          var ks = keysO(ta);
          if (ks.length === 0) {
            return F.of({});
          }
          var fr = F.of({});
          var _loop_1 = function(key2) {
            fr = F.ap(F.map(fr, function(r) {
              return function(b) {
                r[key2] = b;
                return r;
              };
            }), f(key2, ta[key2]));
          };
          for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
            var key = ks_1[_i];
            _loop_1(key);
          }
          return fr;
        };
      };
    };
    filter6 = filter5;
    filterMap5 = filterMap4;
    partition5 = partition4;
    partitionMap5 = partitionMap4;
    compact5 = compact4;
    separate5 = separate4;
    URI9 = "Record";
    getEq8 = getEq7;
    getMonoid5 = getMonoid4;
    Functor9 = {
      URI: URI9,
      map: _map9
    };
    flap10 = flap(Functor9);
    FunctorWithIndex3 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4
    };
    getFoldable = function(O) {
      return {
        URI: URI9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O)
      };
    };
    getFoldableWithIndex = function(O) {
      return {
        URI: URI9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        reduceWithIndex: _reduceWithIndex4(O),
        foldMapWithIndex: _foldMapWithIndex4(O),
        reduceRightWithIndex: _reduceRightWithIndex4(O)
      };
    };
    Compactable5 = {
      URI: URI9,
      compact: compact5,
      separate: separate5
    };
    Filterable3 = {
      URI: URI9,
      map: _map9,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5
    };
    FilterableWithIndex2 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      filterMapWithIndex: _filterMapWithIndex3,
      filterWithIndex: _filterWithIndex3,
      partitionMapWithIndex: _partitionMapWithIndex3,
      partitionWithIndex: _partitionWithIndex3
    };
    getTraversable = function(O) {
      return {
        URI: URI9,
        map: _map9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        traverse: _traverse7(O),
        sequence: _sequence2(O)
      };
    };
    getTraversableWithIndex = function(O) {
      return {
        URI: URI9,
        map: _map9,
        mapWithIndex: _mapWithIndex4,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        reduceWithIndex: _reduceWithIndex4(O),
        foldMapWithIndex: _foldMapWithIndex4(O),
        reduceRightWithIndex: _reduceRightWithIndex4(O),
        traverse: _traverse7(O),
        sequence: _sequence2(O),
        traverseWithIndex: _traverseWithIndex4(O)
      };
    };
    getWitherable2 = function(O) {
      var T = getTraversable(O);
      return {
        URI: URI9,
        map: _map9,
        reduce: _reduce7(O),
        foldMap: _foldMap7(O),
        reduceRight: _reduceRight7(O),
        traverse: T.traverse,
        sequence: T.sequence,
        compact: compact5,
        separate: separate5,
        filter: _filter5,
        filterMap: _filterMap5,
        partition: _partition5,
        partitionMap: _partitionMap5,
        wither: witherDefault(T, Compactable5),
        wilt: wiltDefault(T, Compactable5)
      };
    };
    getUnionSemigroup3 = function(S) {
      var unionS = union6(S);
      return {
        concat: function(first2, second) {
          return unionS(second)(first2);
        }
      };
    };
    getUnionMonoid2 = function(S) {
      return {
        concat: getUnionSemigroup3(S).concat,
        empty: {}
      };
    };
    getIntersectionSemigroup2 = function(S) {
      var intersectionS = intersection4(S);
      return {
        concat: function(first2, second) {
          return intersectionS(second)(first2);
        }
      };
    };
    getDifferenceMagma2 = function() {
      return {
        concat: function(first2, second) {
          return difference3(second)(first2);
        }
      };
    };
    Foldable6 = {
      URI: URI9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2)
    };
    FoldableWithIndex4 = {
      URI: URI9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2)
    };
    Traversable7 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7
    };
    TraversableWithIndex4 = {
      URI: URI9,
      map: _map9,
      mapWithIndex: _mapWithIndex4,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      traverseWithIndex: _traverseWithIndex4(Ord2)
    };
    _wither5 = witherDefault(Traversable7, Compactable5);
    _wilt5 = wiltDefault(Traversable7, Compactable5);
    Witherable5 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      wither: _wither5,
      wilt: _wilt5
    };
    empty6 = {};
    insertAt3 = upsertAt2;
    hasOwnProperty3 = hasOwnProperty2;
    record2 = {
      URI: URI9,
      map: _map9,
      reduce: _reduce7(Ord2),
      foldMap: _foldMap7(Ord2),
      reduceRight: _reduceRight7(Ord2),
      traverse: _traverse7(Ord2),
      sequence: sequence7,
      compact: compact5,
      separate: separate5,
      filter: _filter5,
      filterMap: _filterMap5,
      partition: _partition5,
      partitionMap: _partitionMap5,
      mapWithIndex: _mapWithIndex4,
      reduceWithIndex: _reduceWithIndex4(Ord2),
      foldMapWithIndex: _foldMapWithIndex4(Ord2),
      reduceRightWithIndex: _reduceRightWithIndex4(Ord2),
      filterMapWithIndex: _filterMapWithIndex3,
      filterWithIndex: _filterWithIndex3,
      partitionMapWithIndex: _partitionMapWithIndex3,
      partitionWithIndex: _partitionWithIndex3,
      traverseWithIndex: _traverseWithIndex4(Ord2),
      wither: _wither5,
      wilt: _wilt5
    };
  }
});

// node_modules/fp-ts/es6/pipeable.js
var pipeable_exports = {};
__export(pipeable_exports, {
  pipe: () => pipe2,
  pipeable: () => pipeable
});
function pipeable(I) {
  var r = {};
  if (isFunctor(I)) {
    var map10 = function(f) {
      return function(fa) {
        return I.map(fa, f);
      };
    };
    r.map = map10;
  }
  if (isContravariant(I)) {
    var contramap2 = function(f) {
      return function(fa) {
        return I.contramap(fa, f);
      };
    };
    r.contramap = contramap2;
  }
  if (isFunctorWithIndex(I)) {
    var mapWithIndex6 = function(f) {
      return function(fa) {
        return I.mapWithIndex(fa, f);
      };
    };
    r.mapWithIndex = mapWithIndex6;
  }
  if (isApply(I)) {
    var ap8 = function(fa) {
      return function(fab) {
        return I.ap(fab, fa);
      };
    };
    var apFirst8 = function(fb) {
      return function(fa) {
        return I.ap(I.map(fa, function(a) {
          return function() {
            return a;
          };
        }), fb);
      };
    };
    r.ap = ap8;
    r.apFirst = apFirst8;
    r.apSecond = function(fb) {
      return function(fa) {
        return I.ap(I.map(fa, function() {
          return function(b) {
            return b;
          };
        }), fb);
      };
    };
  }
  if (isChain(I)) {
    var chain7 = function(f) {
      return function(ma) {
        return I.chain(ma, f);
      };
    };
    var chainFirst8 = function(f) {
      return function(ma) {
        return I.chain(ma, function(a) {
          return I.map(f(a), function() {
            return a;
          });
        });
      };
    };
    var flatten7 = function(mma) {
      return I.chain(mma, identity);
    };
    r.chain = chain7;
    r.chainFirst = chainFirst8;
    r.flatten = flatten7;
  }
  if (isBifunctor(I)) {
    var bimap2 = function(f, g) {
      return function(fa) {
        return I.bimap(fa, f, g);
      };
    };
    var mapLeft2 = function(f) {
      return function(fa) {
        return I.mapLeft(fa, f);
      };
    };
    r.bimap = bimap2;
    r.mapLeft = mapLeft2;
  }
  if (isExtend(I)) {
    var extend7 = function(f) {
      return function(wa) {
        return I.extend(wa, f);
      };
    };
    var duplicate7 = function(wa) {
      return I.extend(wa, identity);
    };
    r.extend = extend7;
    r.duplicate = duplicate7;
  }
  if (isFoldable(I)) {
    var reduce9 = function(b, f) {
      return function(fa) {
        return I.reduce(fa, b, f);
      };
    };
    var foldMap9 = function(M) {
      var foldMapM = I.foldMap(M);
      return function(f) {
        return function(fa) {
          return foldMapM(fa, f);
        };
      };
    };
    var reduceRight9 = function(b, f) {
      return function(fa) {
        return I.reduceRight(fa, b, f);
      };
    };
    r.reduce = reduce9;
    r.foldMap = foldMap9;
    r.reduceRight = reduceRight9;
  }
  if (isFoldableWithIndex(I)) {
    var reduceWithIndex7 = function(b, f) {
      return function(fa) {
        return I.reduceWithIndex(fa, b, f);
      };
    };
    var foldMapWithIndex7 = function(M) {
      var foldMapM = I.foldMapWithIndex(M);
      return function(f) {
        return function(fa) {
          return foldMapM(fa, f);
        };
      };
    };
    var reduceRightWithIndex7 = function(b, f) {
      return function(fa) {
        return I.reduceRightWithIndex(fa, b, f);
      };
    };
    r.reduceWithIndex = reduceWithIndex7;
    r.foldMapWithIndex = foldMapWithIndex7;
    r.reduceRightWithIndex = reduceRightWithIndex7;
  }
  if (isAlt(I)) {
    var alt5 = function(that) {
      return function(fa) {
        return I.alt(fa, that);
      };
    };
    r.alt = alt5;
  }
  if (isCompactable(I)) {
    r.compact = I.compact;
    r.separate = I.separate;
  }
  if (isFilterable(I)) {
    var filter7 = function(predicate) {
      return function(fa) {
        return I.filter(fa, predicate);
      };
    };
    var filterMap6 = function(f) {
      return function(fa) {
        return I.filterMap(fa, f);
      };
    };
    var partition6 = function(predicate) {
      return function(fa) {
        return I.partition(fa, predicate);
      };
    };
    var partitionMap6 = function(f) {
      return function(fa) {
        return I.partitionMap(fa, f);
      };
    };
    r.filter = filter7;
    r.filterMap = filterMap6;
    r.partition = partition6;
    r.partitionMap = partitionMap6;
  }
  if (isFilterableWithIndex(I)) {
    var filterWithIndex5 = function(predicateWithIndex) {
      return function(fa) {
        return I.filterWithIndex(fa, predicateWithIndex);
      };
    };
    var filterMapWithIndex5 = function(f) {
      return function(fa) {
        return I.filterMapWithIndex(fa, f);
      };
    };
    var partitionWithIndex5 = function(predicateWithIndex) {
      return function(fa) {
        return I.partitionWithIndex(fa, predicateWithIndex);
      };
    };
    var partitionMapWithIndex5 = function(f) {
      return function(fa) {
        return I.partitionMapWithIndex(fa, f);
      };
    };
    r.filterWithIndex = filterWithIndex5;
    r.filterMapWithIndex = filterMapWithIndex5;
    r.partitionWithIndex = partitionWithIndex5;
    r.partitionMapWithIndex = partitionMapWithIndex5;
  }
  if (isProfunctor(I)) {
    var promap = function(f, g) {
      return function(fa) {
        return I.promap(fa, f, g);
      };
    };
    r.promap = promap;
  }
  if (isSemigroupoid(I)) {
    var compose = function(that) {
      return function(fa) {
        return I.compose(fa, that);
      };
    };
    r.compose = compose;
  }
  if (isMonadThrow(I)) {
    var fromOption4 = function(onNone) {
      return function(ma) {
        return ma._tag === "None" ? I.throwError(onNone()) : I.of(ma.value);
      };
    };
    var fromEither4 = function(ma) {
      return ma._tag === "Left" ? I.throwError(ma.left) : I.of(ma.right);
    };
    var fromPredicate5 = function(predicate, onFalse) {
      return function(a) {
        return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
      };
    };
    var filterOrElse3 = function(predicate, onFalse) {
      return function(ma) {
        return I.chain(ma, function(a) {
          return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
        });
      };
    };
    r.fromOption = fromOption4;
    r.fromEither = fromEither4;
    r.fromPredicate = fromPredicate5;
    r.filterOrElse = filterOrElse3;
  }
  return r;
}
var isFunctor, isContravariant, isFunctorWithIndex, isApply, isChain, isBifunctor, isExtend, isFoldable, isFoldableWithIndex, isAlt, isCompactable, isFilterable, isFilterableWithIndex, isProfunctor, isSemigroupoid, isMonadThrow, pipe2;
var init_pipeable = __esm({
  "node_modules/fp-ts/es6/pipeable.js"() {
    init_function();
    isFunctor = function(I) {
      return typeof I.map === "function";
    };
    isContravariant = function(I) {
      return typeof I.contramap === "function";
    };
    isFunctorWithIndex = function(I) {
      return typeof I.mapWithIndex === "function";
    };
    isApply = function(I) {
      return typeof I.ap === "function";
    };
    isChain = function(I) {
      return typeof I.chain === "function";
    };
    isBifunctor = function(I) {
      return typeof I.bimap === "function";
    };
    isExtend = function(I) {
      return typeof I.extend === "function";
    };
    isFoldable = function(I) {
      return typeof I.reduce === "function";
    };
    isFoldableWithIndex = function(I) {
      return typeof I.reduceWithIndex === "function";
    };
    isAlt = function(I) {
      return typeof I.alt === "function";
    };
    isCompactable = function(I) {
      return typeof I.compact === "function";
    };
    isFilterable = function(I) {
      return typeof I.filter === "function";
    };
    isFilterableWithIndex = function(I) {
      return typeof I.filterWithIndex === "function";
    };
    isProfunctor = function(I) {
      return typeof I.promap === "function";
    };
    isSemigroupoid = function(I) {
      return typeof I.compose === "function";
    };
    isMonadThrow = function(I) {
      return typeof I.throwError === "function";
    };
    pipe2 = pipe;
  }
});

// node_modules/io-ts-reporters/target/src/utils.js
var require_utils = __commonJS({
  "node_modules/io-ts-reporters/target/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeUntil = void 0;
    var takeUntil = function(predicate) {
      return function(as) {
        var init4 = [];
        for (var i = 0; i < as.length; i++) {
          init4[i] = as[i];
          if (predicate(as[i])) {
            return init4;
          }
        }
        return init4;
      };
    };
    exports.takeUntil = takeUntil;
  }
});

// node_modules/io-ts-reporters/target/src/index.js
var require_src = __commonJS({
  "node_modules/io-ts-reporters/target/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reporter = exports.formatValidationErrors = exports.formatValidationError = exports.TYPE_MAX_LEN = void 0;
    var A = (init_Array(), __toCommonJS(Array_exports));
    var E = (init_Either(), __toCommonJS(Either_exports));
    var NEA = (init_NonEmptyArray(), __toCommonJS(NonEmptyArray_exports));
    var O = (init_Option(), __toCommonJS(Option_exports));
    var R = (init_Record(), __toCommonJS(Record_exports));
    var pipeable_1 = (init_pipeable(), __toCommonJS(pipeable_exports));
    var t = (init_es6(), __toCommonJS(es6_exports));
    var utils_1 = require_utils();
    var isUnionType = function(_a) {
      var type2 = _a.type;
      return type2 instanceof t.UnionType;
    };
    var jsToString = function(value) {
      return value === void 0 ? "undefined" : JSON.stringify(value);
    };
    var keyPath = function(ctx) {
      return ctx.map(function(c) {
        return c.key;
      }).filter(Boolean).join(".");
    };
    var getErrorFromCtx = function(validation) {
      return A.last(validation.context);
    };
    var getValidationContext = function(validation) {
      return validation.context;
    };
    exports.TYPE_MAX_LEN = 160;
    var truncateType = function(type2, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.truncateLongTypes, truncateLongTypes = _a === void 0 ? true : _a;
      if (truncateLongTypes && type2.length > exports.TYPE_MAX_LEN) {
        return type2.slice(0, exports.TYPE_MAX_LEN - 3) + "...";
      }
      return type2;
    };
    var errorMessageSimple = function(expectedType, path, error, options) {
      return [
        "Expecting " + truncateType(expectedType, options),
        path === "" ? "" : "at " + path,
        "but instead got: " + jsToString(error.value),
        error.message ? "(" + error.message + ")" : ""
      ].filter(Boolean).join(" ");
    };
    var errorMessageUnion = function(expectedTypes, path, value, options) {
      return [
        "Expecting one of:\n",
        expectedTypes.map(function(type2) {
          return "    " + truncateType(type2, options);
        }).join("\n"),
        path === "" ? "\n" : "\nat " + path + " ",
        "but instead got: " + jsToString(value)
      ].filter(Boolean).join("");
    };
    var findExpectedType = function(ctx) {
      return pipeable_1.pipe(ctx, A.findIndex(isUnionType), O.chain(function(n) {
        return A.lookup(n + 1, ctx);
      }));
    };
    var formatValidationErrorOfUnion = function(path, errors, options) {
      var expectedTypes = pipeable_1.pipe(errors, A.map(getValidationContext), A.map(findExpectedType), A.compact);
      var value = pipeable_1.pipe(expectedTypes, A.head, O.map(function(v) {
        return v.actual;
      }), O.getOrElse(function() {
        return void 0;
      }));
      var expected = expectedTypes.map(function(_a) {
        var type2 = _a.type;
        return type2.name;
      });
      return expected.length > 0 ? O.some(errorMessageUnion(expected, path, value, options)) : O.none;
    };
    var formatValidationCommonError = function(path, error, options) {
      return pipeable_1.pipe(error, getErrorFromCtx, O.map(function(errorContext) {
        return errorMessageSimple(errorContext.type.name, path, error, options);
      }));
    };
    var groupByKey = NEA.groupBy(function(error) {
      return pipeable_1.pipe(error.context, utils_1.takeUntil(isUnionType), keyPath);
    });
    var format = function(path, errors, options) {
      return NEA.tail(errors).length > 0 ? formatValidationErrorOfUnion(path, errors, options) : formatValidationCommonError(path, NEA.head(errors), options);
    };
    var formatValidationError = function(error, options) {
      return formatValidationCommonError(keyPath(error.context), error, options);
    };
    exports.formatValidationError = formatValidationError;
    var formatValidationErrors = function(errors, options) {
      return pipeable_1.pipe(errors, groupByKey, R.mapWithIndex(function(path, errors2) {
        return format(path, errors2, options);
      }), R.compact, R.toArray, A.map(function(_a) {
        var _key = _a[0], error = _a[1];
        return error;
      }));
    };
    exports.formatValidationErrors = formatValidationErrors;
    var reporter = function(validation, options) {
      return pipeable_1.pipe(validation, E.mapLeft(function(errors) {
        return exports.formatValidationErrors(errors, options);
      }), E.fold(function(errors) {
        return errors;
      }, function() {
        return [];
      }));
    };
    exports.reporter = reporter;
    var prettyReporter = { report: exports.reporter };
    exports.default = prettyReporter;
  }
});

// node_modules/dataloader/index.js
var require_dataloader = __commonJS({
  "node_modules/dataloader/index.js"(exports, module) {
    "use strict";
    var DataLoader = function() {
      function DataLoader2(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
      }
      var _proto = DataLoader2.prototype;
      _proto.load = function load(key) {
        if (key === null || key === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      };
      _proto.loadMany = function loadMany(keys3) {
        if (!isArrayLike(keys3)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys3 + "."));
        }
        var loadPromises = [];
        for (var i = 0; i < keys3.length; i++) {
          loadPromises.push(this.load(keys3[i])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      };
      _proto.clear = function clear(key) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          cacheMap["delete"](cacheKey);
        }
        return this;
      };
      _proto.clearAll = function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      };
      _proto.prime = function prime(key, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      };
      return DataLoader2;
    }();
    var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        process.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise = loader._batchLoadFn(batch.keys);
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i = 0; i < batch.callbacks.length; i++) {
          var value = values[i];
          if (value instanceof Error) {
            batch.callbacks[i].reject(value);
          } else {
            batch.callbacks[i].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i = 0; i < batch.keys.length; i++) {
        loader.clear(batch.keys[i]);
        batch.callbacks[i].reject(error);
      }
    }
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i = 0; i < batch.cacheHits.length; i++) {
          batch.cacheHits[i]();
        }
      }
    }
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key) {
          return key;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    function isArrayLike(x) {
      return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
    }
    module.exports = DataLoader;
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind8(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind8 = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend7(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind8(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend: extend7,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match5 ? decodeURIComponent(match5[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.25.0"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i) {
      validators[type2] = function validator(thing) {
        return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys3 = Object.keys(options);
      var i = keys3.length;
      while (i-- > 0) {
        var opt = keys3[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      if (!config.url) {
        throw new Error("Provided config url is not valid");
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain7 = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain7, requestInterceptorChain);
        chain7 = chain7.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain7.length) {
          promise = promise.then(chain7.shift(), chain7.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      if (!config.url) {
        throw new Error("Provided config url is not valid");
      }
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var bind8 = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind8(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module.exports = axios;
    module.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// node_modules/ton/package.json
var require_package = __commonJS({
  "node_modules/ton/package.json"(exports, module) {
    module.exports = {
      name: "ton",
      version: "12.1.3",
      repository: "https://github.com/tonwhales/ton.git",
      author: "Steve Korshakov <steve@korshakov.com>",
      license: "MIT",
      main: "dist/index.js",
      files: [
        "dist"
      ],
      scripts: {
        build: "rm -fr dist && tsc --declaration",
        test: "jest --verbose --runInBand",
        release: "yarn build && yarn test && yarn publish"
      },
      devDependencies: {
        "@types/bn.js": "^5.1.0",
        "@types/jest": "^27.0.1",
        "@types/node": "^16.7.10",
        buffer: "^6.0.3",
        expect: "^27.1.0",
        jest: "^27.1.0",
        "jest-mock": "^27.1.0",
        karma: "^6.3.4",
        "karma-chrome-launcher": "^3.1.0",
        "karma-jasmine": "^4.0.1",
        "karma-typescript": "^5.5.2",
        "karma-webpack": "^5.0.0",
        tonweb: "0.0.18",
        "ts-jest": "^27.0.5",
        "ts-loader": "^9.2.5",
        "ts-node": "^10.7.0",
        typescript: "^4.4.2",
        webpack: "^5.51.2"
      },
      dependencies: {
        axios: "^0.25.0",
        "bn.js": "5.2.0",
        dataloader: "^2.0.0",
        "ethjs-unit": "0.1.6",
        "fp-ts": "^2.11.1",
        "io-ts": "^2.2.16",
        "io-ts-reporters": "^2.0.0",
        "symbol.inspect": "1.0.1",
        teslabot: "^1.3.0",
        "ton-crypto": "2.1.0",
        tweetnacl: "1.0.3"
      }
    };
  }
});

// node_modules/ton/dist/client/api/HttpApi.js
var require_HttpApi = __commonJS({
  "node_modules/ton/dist/client/api/HttpApi.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpApi = void 0;
    var t = __importStar((init_es6(), __toCommonJS(es6_exports)));
    var Either_1 = require_Either();
    var io_ts_reporters_1 = __importDefault(require_src());
    var dataloader_1 = __importDefault(require_dataloader());
    var axios_1 = __importDefault(require_axios2());
    var version = require_package().version;
    var blockIdExt = t.type({
      "@type": t.literal("ton.blockIdExt"),
      workchain: t.number,
      shard: t.string,
      seqno: t.number,
      root_hash: t.string,
      file_hash: t.string
    });
    var addressInformation = t.type({
      balance: t.union([t.number, t.string]),
      state: t.union([t.literal("active"), t.literal("uninitialized"), t.literal("frozen")]),
      data: t.string,
      code: t.string,
      last_transaction_id: t.type({
        "@type": t.literal("internal.transactionId"),
        lt: t.string,
        hash: t.string
      }),
      block_id: blockIdExt,
      sync_utime: t.number
    });
    var bocResponse = t.type({
      "@type": t.literal("ok")
    });
    var feeResponse = t.type({
      "@type": t.literal("query.fees"),
      source_fees: t.type({
        "@type": t.literal("fees"),
        in_fwd_fee: t.number,
        storage_fee: t.number,
        gas_fee: t.number,
        fwd_fee: t.number
      })
    });
    var callGetMethod = t.type({
      gas_used: t.number,
      exit_code: t.number,
      stack: t.array(t.unknown)
    });
    var messageData = t.union([
      t.type({
        "@type": t.literal("msg.dataRaw"),
        "body": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataText"),
        "text": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataDecryptedText"),
        "text": t.string
      }),
      t.type({
        "@type": t.literal("msg.dataEncryptedText"),
        "text": t.string
      })
    ]);
    var message = t.type({
      source: t.string,
      destination: t.string,
      value: t.string,
      fwd_fee: t.string,
      ihr_fee: t.string,
      created_lt: t.string,
      body_hash: t.string,
      msg_data: messageData
    });
    var transaction = t.type({
      data: t.string,
      utime: t.number,
      transaction_id: t.type({
        lt: t.string,
        hash: t.string
      }),
      fee: t.string,
      storage_fee: t.string,
      other_fee: t.string,
      in_msg: t.union([t.undefined, message]),
      out_msgs: t.array(message)
    });
    var getTransactions = t.array(transaction);
    var getMasterchain = t.type({
      state_root_hash: t.string,
      last: blockIdExt,
      init: blockIdExt
    });
    var getShards = t.type({
      shards: t.array(blockIdExt)
    });
    var blockShortTxt = t.type({
      "@type": t.literal("blocks.shortTxId"),
      mode: t.number,
      account: t.string,
      lt: t.string,
      hash: t.string
    });
    var getBlockTransactions = t.type({
      id: blockIdExt,
      req_count: t.number,
      incomplete: t.boolean,
      transactions: t.array(blockShortTxt)
    });
    var TypedCache = class {
      constructor(namespace, cache, codec, keyEncoder) {
        this.namespace = namespace;
        this.cache = cache;
        this.codec = codec;
        this.keyEncoder = keyEncoder;
      }
      async get(key) {
        let ex = await this.cache.get(this.namespace, this.keyEncoder(key));
        if (ex) {
          let decoded = this.codec.decode(JSON.parse(ex));
          if ((0, Either_1.isRight)(decoded)) {
            return decoded.right;
          }
        }
        return null;
      }
      async set(key, value) {
        if (value !== null) {
          await this.cache.set(this.namespace, this.keyEncoder(key), JSON.stringify(value));
        } else {
          await this.cache.set(this.namespace, this.keyEncoder(key), null);
        }
      }
    };
    var HttpApi = class {
      constructor(endpoint, cache, parameters) {
        this.endpoint = endpoint;
        this.cache = cache;
        this.parameters = {
          timeout: (parameters === null || parameters === void 0 ? void 0 : parameters.timeout) || 3e4,
          apiKey: parameters === null || parameters === void 0 ? void 0 : parameters.apiKey
        };
        this.shardCache = new TypedCache("ton-shard", cache, t.array(blockIdExt), (src) => src + "");
        this.shardLoader = new dataloader_1.default(async (src) => {
          return await Promise.all(src.map(async (v) => {
            const cached = await this.shardCache.get(v);
            if (cached) {
              return cached;
            }
            let loaded = (await this.doCall("shards", { seqno: v }, getShards)).shards;
            await this.shardCache.set(v, loaded);
            return loaded;
          }));
        });
        this.shardTransactionsCache = new TypedCache("ton-shard-tx", cache, getBlockTransactions, (src) => src.workchain + ":" + src.shard + ":" + src.seqno);
        this.shardTransactionsLoader = new dataloader_1.default(async (src) => {
          return await Promise.all(src.map(async (v) => {
            const cached = await this.shardTransactionsCache.get(v);
            if (cached) {
              return cached;
            }
            let loaded = await this.doCall("getBlockTransactions", { workchain: v.workchain, seqno: v.seqno, shard: v.shard }, getBlockTransactions);
            await this.shardTransactionsCache.set(v, loaded);
            return loaded;
          }));
        }, { cacheKeyFn: (src) => src.workchain + ":" + src.shard + ":" + src.seqno });
      }
      getAddressInformation(address) {
        return this.doCall("getAddressInformation", { address: address.toString() }, addressInformation);
      }
      async getTransactions(address, opts) {
        const inclusive = opts.inclusive;
        delete opts.inclusive;
        let hash = void 0;
        if (opts.hash) {
          hash = Buffer.from(opts.hash, "base64").toString("hex");
        }
        let limit = opts.limit;
        if (opts.hash && opts.lt && inclusive !== true) {
          limit++;
        }
        let res = await this.doCall("getTransactions", { address: address.toString(), ...opts, limit, hash }, getTransactions);
        if (res.length > limit) {
          res = res.slice(0, limit);
        }
        if (opts.hash && opts.lt && inclusive !== true) {
          res.shift();
          return res;
        } else {
          return res;
        }
      }
      async getMasterchainInfo() {
        return await this.doCall("getMasterchainInfo", {}, getMasterchain);
      }
      async getShards(seqno) {
        return await this.shardLoader.load(seqno);
      }
      async getBlockTransactions(workchain, seqno, shard) {
        return await this.shardTransactionsLoader.load({ workchain, seqno, shard });
      }
      async getTransaction(address, lt, hash) {
        let convHash = Buffer.from(hash, "base64").toString("hex");
        let res = await this.doCall("getTransactions", { address: address.toString(), lt, hash: convHash, limit: 1 }, getTransactions);
        let ex = res.find((v) => v.transaction_id.lt === lt && v.transaction_id.hash === hash);
        if (ex) {
          return ex;
        } else {
          return null;
        }
      }
      async callGetMethod(address, method, params) {
        return await this.doCall("runGetMethod", { address: address.toString(), method, stack: params }, callGetMethod);
      }
      async sendBoc(body) {
        await this.doCall("sendBoc", { boc: body.toString("base64") }, bocResponse);
      }
      async estimateFee(address, args) {
        return await this.doCall("estimateFee", {
          address: address.toFriendly(),
          body: (await args.body.toBoc({ idx: false })).toString("base64"),
          "init_data": args.initData ? (await args.initData.toBoc({ idx: false })).toString("base64") : "",
          "init_code": args.initCode ? (await args.initCode.toBoc({ idx: false })).toString("base64") : "",
          ignore_chksig: args.ignoreSignature
        }, feeResponse);
      }
      async doCall(method, body, codec) {
        let headers = {
          "Content-Type": "application/json",
          "X-Ton-Client-Version": version
        };
        if (this.parameters.apiKey) {
          headers["X-API-Key"] = this.parameters.apiKey;
        }
        let res = await axios_1.default.post(this.endpoint, JSON.stringify({
          id: "1",
          jsonrpc: "2.0",
          method,
          params: body
        }), {
          headers,
          timeout: this.parameters.timeout
        });
        if (res.status !== 200 || !res.data.ok) {
          throw Error("Received error: " + JSON.stringify(res.data));
        }
        let decoded = codec.decode(res.data.result);
        if ((0, Either_1.isRight)(decoded)) {
          return decoded.right;
        } else {
          throw Error("Malformed response: " + io_ts_reporters_1.default.report(decoded).join(", "));
        }
      }
    };
    exports.HttpApi = HttpApi;
  }
});

// node_modules/ton/dist/messages/ExternalMessage.js
var require_ExternalMessage = __commonJS({
  "node_modules/ton/dist/messages/ExternalMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalMessage = void 0;
    var ExternalMessage = class {
      constructor(opts) {
        this.to = opts.to;
        this.body = opts.body;
        if (opts.from !== void 0 && opts.from !== null) {
          this.from = opts.from;
        } else {
          this.from = null;
        }
        if (opts.importFee !== void 0 && opts.importFee !== null) {
          this.importFee = opts.importFee;
        } else {
          this.importFee = 0;
        }
      }
      writeTo(cell) {
        cell.bits.writeUint(2, 2);
        cell.bits.writeAddress(this.from);
        cell.bits.writeAddress(this.to);
        cell.bits.writeCoins(this.importFee);
        this.body.writeTo(cell);
      }
    };
    exports.ExternalMessage = ExternalMessage;
  }
});

// node_modules/ton/dist/messages/CommonMessageInfo.js
var require_CommonMessageInfo = __commonJS({
  "node_modules/ton/dist/messages/CommonMessageInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonMessageInfo = void 0;
    var Cell_1 = require_Cell();
    var CommonMessageInfo = class {
      constructor(opts) {
        if (opts && opts.stateInit !== null && opts.stateInit !== void 0) {
          this.stateInit = opts.stateInit;
        } else {
          this.stateInit = null;
        }
        if (opts && opts.body !== null && opts.body !== void 0) {
          this.body = opts.body;
        } else {
          this.body = null;
        }
      }
      writeTo(cell) {
        if (this.stateInit) {
          cell.bits.writeBit(1);
          const stateInitCell = new Cell_1.Cell();
          this.stateInit.writeTo(stateInitCell);
          if (cell.bits.available - 1 >= stateInitCell.bits.cursor) {
            cell.bits.writeBit(0);
            cell.writeCell(stateInitCell);
          } else {
            cell.bits.writeBit(1);
            cell.refs.push(stateInitCell);
          }
        } else {
          cell.bits.writeBit(0);
        }
        if (this.body) {
          const bodyCell = new Cell_1.Cell();
          this.body.writeTo(bodyCell);
          if (cell.bits.available >= bodyCell.bits.cursor) {
            cell.bits.writeBit(0);
            cell.writeCell(bodyCell);
          } else {
            cell.bits.writeBit(1);
            cell.refs.push(bodyCell);
          }
        } else {
          cell.bits.writeBit(0);
        }
      }
    };
    exports.CommonMessageInfo = CommonMessageInfo;
  }
});

// node_modules/ton/dist/messages/StateInit.js
var require_StateInit = __commonJS({
  "node_modules/ton/dist/messages/StateInit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StateInit = void 0;
    var StateInit = class {
      constructor(opts) {
        if (opts.code !== null && opts.code !== void 0) {
          this.code = opts.code;
        } else {
          this.code = null;
        }
        if (opts.data !== null && opts.data !== void 0) {
          this.data = opts.data;
        } else {
          this.data = null;
        }
      }
      writeTo(cell) {
        cell.bits.writeBit(0);
        cell.bits.writeBit(0);
        cell.bits.writeBit(!!this.code);
        cell.bits.writeBit(!!this.data);
        cell.bits.writeBit(0);
        if (this.code) {
          cell.refs.push(this.code);
        }
        if (this.data) {
          cell.refs.push(this.data);
        }
      }
    };
    exports.StateInit = StateInit;
  }
});

// node_modules/ton/dist/contracts/sources/WalletV1R2Source.js
var require_WalletV1R2Source = __commonJS({
  "node_modules/ton/dist/contracts/sources/WalletV1R2Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV1R2Source = void 0;
    var __1 = require_dist2();
    var WalletV1R2Source = class {
      constructor(opts) {
        this.type = "org.ton.wallets.simple.r2";
        this.walletVersion = "v1";
        this.backup = () => {
          const store = new __1.ConfigStore();
          store.setInt("wc", this.workchain);
          store.setBuffer("pk", this.publicKey);
          return store.save();
        };
        this.describe = () => {
          return "Simple Wallet Contract (R2)";
        };
        this.publicKey = opts.publicKey;
        this.initialCode = opts.initialCode;
        this.initialData = opts.initialData;
        this.workchain = opts.workchain;
        Object.freeze(this);
      }
      static create(opts) {
        let publicKey = opts.publicKey;
        let workchain = opts.workchain;
        let initialCode = __1.Cell.fromBoc("B5EE9C724101010100530000A2FF0020DD2082014C97BA9730ED44D0D70B1FE0A4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED54D0E2786F")[0];
        let initialData = new __1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeBuffer(publicKey);
        return new WalletV1R2Source({ publicKey, initialCode, initialData, workchain });
      }
      static restore(backup) {
        const store = new __1.ConfigStore(backup);
        return WalletV1R2Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
      }
    };
    exports.WalletV1R2Source = WalletV1R2Source;
  }
});

// node_modules/ton/dist/contracts/sources/WalletV1R3Source.js
var require_WalletV1R3Source = __commonJS({
  "node_modules/ton/dist/contracts/sources/WalletV1R3Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV1R3Source = void 0;
    var __1 = require_dist2();
    var WalletV1R3Source = class {
      constructor(opts) {
        this.type = "org.ton.wallets.simple.r3";
        this.walletVersion = "v1";
        this.backup = () => {
          const store = new __1.ConfigStore();
          store.setInt("wc", this.workchain);
          store.setBuffer("pk", this.publicKey);
          return store.save();
        };
        this.describe = () => {
          return "Simple Wallet Contract (R3)";
        };
        this.publicKey = opts.publicKey;
        this.initialCode = opts.initialCode;
        this.initialData = opts.initialData;
        this.workchain = opts.workchain;
        Object.freeze(this);
      }
      static create(opts) {
        let publicKey = opts.publicKey;
        let workchain = opts.workchain;
        let initialCode = __1.Cell.fromBoc("B5EE9C7241010101005F0000BAFF0020DD2082014C97BA218201339CBAB19C71B0ED44D0D31FD70BFFE304E0A4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED54B5B86E42")[0];
        let initialData = new __1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeBuffer(publicKey);
        return new WalletV1R3Source({ publicKey, initialCode, initialData, workchain });
      }
      static restore(backup) {
        const store = new __1.ConfigStore(backup);
        return WalletV1R3Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
      }
    };
    exports.WalletV1R3Source = WalletV1R3Source;
  }
});

// node_modules/ton/dist/contracts/sources/WalletV2R1Source.js
var require_WalletV2R1Source = __commonJS({
  "node_modules/ton/dist/contracts/sources/WalletV2R1Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV2R1Source = void 0;
    var __1 = require_dist2();
    var WalletV2R1Source = class {
      constructor(opts) {
        this.type = "org.ton.wallets.v2";
        this.walletVersion = "v2";
        this.backup = () => {
          const store = new __1.ConfigStore();
          store.setInt("wc", this.workchain);
          store.setBuffer("pk", this.publicKey);
          return store.save();
        };
        this.describe = () => {
          return "Wallet V2 Contract";
        };
        this.publicKey = opts.publicKey;
        this.initialCode = opts.initialCode;
        this.initialData = opts.initialData;
        this.workchain = opts.workchain;
        Object.freeze(this);
      }
      static create(opts) {
        let publicKey = opts.publicKey;
        let workchain = opts.workchain;
        let initialCode = __1.Cell.fromBoc("B5EE9C724101010100570000AAFF0020DD2082014C97BA9730ED44D0D70B1FE0A4F2608308D71820D31FD31F01F823BBF263ED44D0D31FD3FFD15131BAF2A103F901541042F910F2A2F800029320D74A96D307D402FB00E8D1A4C8CB1FCBFFC9ED54A1370BB6")[0];
        let initialData = new __1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeBuffer(publicKey);
        return new WalletV2R1Source({ publicKey, initialCode, initialData, workchain });
      }
      static restore(backup) {
        const store = new __1.ConfigStore(backup);
        return WalletV2R1Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
      }
    };
    exports.WalletV2R1Source = WalletV2R1Source;
  }
});

// node_modules/ton/dist/contracts/sources/WalletV2R2Source.js
var require_WalletV2R2Source = __commonJS({
  "node_modules/ton/dist/contracts/sources/WalletV2R2Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV2R2Source = void 0;
    var __1 = require_dist2();
    var WalletV2R2Source = class {
      constructor(opts) {
        this.type = "org.ton.wallets.v2.r2";
        this.walletVersion = "v2";
        this.backup = () => {
          const store = new __1.ConfigStore();
          store.setInt("wc", this.workchain);
          store.setBuffer("pk", this.publicKey);
          return store.save();
        };
        this.describe = () => {
          return "Wallet V2 Contract (R2)";
        };
        this.publicKey = opts.publicKey;
        this.workchain = opts.workchain;
        this.initialCode = opts.initialCode;
        this.initialData = opts.initialData;
        Object.freeze(this);
      }
      static create(opts) {
        let publicKey = opts.publicKey;
        let workchain = opts.workchain;
        let initialCode = __1.Cell.fromBoc("B5EE9C724101010100630000C2FF0020DD2082014C97BA218201339CBAB19C71B0ED44D0D31FD70BFFE304E0A4F2608308D71820D31FD31F01F823BBF263ED44D0D31FD3FFD15131BAF2A103F901541042F910F2A2F800029320D74A96D307D402FB00E8D1A4C8CB1FCBFFC9ED54044CD7A1")[0];
        let initialData = new __1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeBuffer(publicKey);
        return new WalletV2R2Source({ publicKey, initialCode, initialData, workchain });
      }
      static restore(backup) {
        const store = new __1.ConfigStore(backup);
        return WalletV2R2Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
      }
    };
    exports.WalletV2R2Source = WalletV2R2Source;
  }
});

// node_modules/ton/dist/contracts/sources/WalletV3R1Source.js
var require_WalletV3R1Source = __commonJS({
  "node_modules/ton/dist/contracts/sources/WalletV3R1Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV3R1Source = void 0;
    var __1 = require_dist2();
    var WalletV3R1Source = class {
      constructor(opts) {
        this.type = "org.ton.wallets.v3";
        this.walletVersion = "v3";
        this.backup = () => {
          const store = new __1.ConfigStore();
          store.setInt("wc", this.workchain);
          store.setInt("walletId", this.walletId);
          store.setBuffer("pk", this.publicKey);
          return store.save();
        };
        this.describe = () => {
          return `Wallet V3 Contract. WalletID = ${this.walletId}`;
        };
        this.publicKey = opts.publicKey;
        this.workchain = opts.workchain;
        this.walletId = opts.walletId;
        this.initialCode = opts.initialCode;
        this.initialData = opts.initialData;
        Object.freeze(this);
      }
      static create(opts) {
        let publicKey = opts.publicKey;
        let workchain = opts.workchain;
        let walletId;
        if (opts.walletId !== null && opts.walletId !== void 0) {
          walletId = opts.walletId;
        } else {
          walletId = 698983191 + workchain;
        }
        let initialCode = __1.Cell.fromBoc("B5EE9C724101010100620000C0FF0020DD2082014C97BA9730ED44D0D70B1FE0A4F2608308D71820D31FD31FD31FF82313BBF263ED44D0D31FD31FD3FFD15132BAF2A15144BAF2A204F901541055F910F2A3F8009320D74A96D307D402FB00E8D101A4C8CB1FCB1FCBFFC9ED543FBE6EE0")[0];
        let initialData = new __1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeUint(walletId, 32);
        initialData.bits.writeBuffer(publicKey);
        return new WalletV3R1Source({
          publicKey,
          workchain,
          walletId,
          initialCode,
          initialData
        });
      }
      static restore(backup) {
        const store = new __1.ConfigStore(backup);
        return WalletV3R1Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc"), walletId: store.getInt("walletId") });
      }
    };
    exports.WalletV3R1Source = WalletV3R1Source;
  }
});

// node_modules/ton/dist/contracts/sources/WalletV3R2Source.js
var require_WalletV3R2Source = __commonJS({
  "node_modules/ton/dist/contracts/sources/WalletV3R2Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV3R2Source = void 0;
    var __1 = require_dist2();
    var WalletV3R2Source = class {
      constructor(opts) {
        this.type = "org.ton.wallets.v3.r2";
        this.walletVersion = "v3";
        this.backup = () => {
          const store = new __1.ConfigStore();
          store.setInt("wc", this.workchain);
          store.setInt("walletId", this.walletId);
          store.setBuffer("pk", this.publicKey);
          return store.save();
        };
        this.describe = () => {
          return `Wallet V3 Contract (R2). WalletID = ${this.walletId}`;
        };
        this.publicKey = opts.publicKey;
        this.workchain = opts.workchain;
        this.walletId = opts.walletId;
        this.initialCode = opts.initialCode;
        this.initialData = opts.initialData;
        Object.freeze(this);
      }
      static create(opts) {
        let publicKey = opts.publicKey;
        let workchain = opts.workchain;
        let walletId;
        if (opts.walletId !== null && opts.walletId !== void 0) {
          walletId = opts.walletId;
        } else {
          walletId = 698983191 + workchain;
        }
        let initialCode = __1.Cell.fromBoc("B5EE9C724101010100710000DEFF0020DD2082014C97BA218201339CBAB19F71B0ED44D0D31FD31F31D70BFFE304E0A4F2608308D71820D31FD31FD31FF82313BBF263ED44D0D31FD31FD3FFD15132BAF2A15144BAF2A204F901541055F910F2A3F8009320D74A96D307D402FB00E8D101A4C8CB1FCB1FCBFFC9ED5410BD6DAD")[0];
        let initialData = new __1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeUint(walletId, 32);
        initialData.bits.writeBuffer(publicKey);
        return new WalletV3R2Source({
          publicKey,
          workchain,
          walletId,
          initialCode,
          initialData
        });
      }
      static restore(backup) {
        const store = new __1.ConfigStore(backup);
        return WalletV3R2Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc"), walletId: store.getInt("walletId") });
      }
    };
    exports.WalletV3R2Source = WalletV3R2Source;
  }
});

// node_modules/ton/dist/contracts/sources/WalletV4Source.js
var require_WalletV4Source = __commonJS({
  "node_modules/ton/dist/contracts/sources/WalletV4Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV4Source = void 0;
    var __1 = require_dist2();
    var WalletV4Source = class {
      constructor(args) {
        this.type = "org.ton.wallets.v4";
        this.walletVersion = "v4";
        this.initialCode = args.initialCode;
        this.initialData = args.initialData;
        this.workchain = args.workchain;
        this.walletId = args.walletId;
        this.publicKey = args.publicKey;
      }
      static create(opts) {
        const walletId = opts.walletId ? opts.walletId : 698983191;
        let initialCode = __1.Cell.fromBoc(WalletV4Source.SOURCE)[0];
        let initialData = new __1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeUint(walletId, 32);
        initialData.bits.writeBuffer(opts.publicKey);
        initialData.bits.writeBit(0);
        return new WalletV4Source({ initialCode, initialData, workchain: opts.workchain, walletId, publicKey: opts.publicKey });
      }
      static restore(backup) {
        const store = new __1.ConfigStore(backup);
        return WalletV4Source.create({
          workchain: store.getInt("wc"),
          publicKey: store.getBuffer("pk"),
          walletId: store.getInt("walletId")
        });
      }
      describe() {
        return "Wallet v4 #" + this.walletId;
      }
      backup() {
        const config = new __1.ConfigStore();
        config.setInt("wc", this.workchain);
        config.setBuffer("pk", this.publicKey);
        config.setInt("walletId", this.walletId);
        return config.save();
      }
    };
    exports.WalletV4Source = WalletV4Source;
    WalletV4Source.SOURCE = Buffer.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64");
  }
});

// node_modules/ton/dist/contracts/messages/WalletV1SigningMessage.js
var require_WalletV1SigningMessage = __commonJS({
  "node_modules/ton/dist/contracts/messages/WalletV1SigningMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV1SigningMessage = void 0;
    var Cell_1 = require_Cell();
    var WalletV1SigningMessage = class {
      constructor(args) {
        this.order = args.order;
        this.sendMode = args.sendMode;
        if (args.seqno !== void 0 && args.seqno !== null) {
          this.seqno = args.seqno;
        } else {
          this.seqno = 0;
        }
      }
      writeTo(cell) {
        cell.bits.writeUint(this.seqno, 32);
        cell.bits.writeUint8(this.sendMode);
        let orderCell = new Cell_1.Cell();
        this.order.writeTo(orderCell);
        cell.refs.push(orderCell);
      }
    };
    exports.WalletV1SigningMessage = WalletV1SigningMessage;
  }
});

// node_modules/ton/dist/contracts/messages/WalletV2SigningMessage.js
var require_WalletV2SigningMessage = __commonJS({
  "node_modules/ton/dist/contracts/messages/WalletV2SigningMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV2SigningMessage = void 0;
    var Cell_1 = require_Cell();
    var WalletV2SigningMessage = class {
      constructor(args) {
        this.order = args.order;
        this.sendMode = args.sendMode;
        if (args.timeout !== void 0 && args.timeout !== null) {
          this.timeout = args.timeout;
        } else {
          this.timeout = Math.floor(Date.now() / 1e3) + 60;
        }
        if (args.seqno !== void 0 && args.seqno !== null) {
          this.seqno = args.seqno;
        } else {
          this.seqno = 0;
        }
      }
      writeTo(cell) {
        cell.bits.writeUint(this.seqno, 32);
        if (this.seqno === 0) {
          for (let i = 0; i < 32; i++) {
            cell.bits.writeBit(1);
          }
        } else {
          cell.bits.writeUint(this.timeout, 32);
        }
        cell.bits.writeUint8(this.sendMode);
        let orderCell = new Cell_1.Cell();
        this.order.writeTo(orderCell);
        cell.refs.push(orderCell);
      }
    };
    exports.WalletV2SigningMessage = WalletV2SigningMessage;
  }
});

// node_modules/ton/dist/contracts/messages/WalletV3SigningMessage.js
var require_WalletV3SigningMessage = __commonJS({
  "node_modules/ton/dist/contracts/messages/WalletV3SigningMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV3SigningMessage = void 0;
    var Cell_1 = require_Cell();
    var WalletV3SigningMessage = class {
      constructor(args) {
        this.order = args.order;
        this.sendMode = args.sendMode;
        if (args.timeout !== void 0 && args.timeout !== null) {
          this.timeout = args.timeout;
        } else {
          this.timeout = Math.floor(Date.now() / 1e3) + 60;
        }
        if (args.seqno !== void 0 && args.seqno !== null) {
          this.seqno = args.seqno;
        } else {
          this.seqno = 0;
        }
        if (args.walletId !== null && args.walletId !== void 0) {
          this.walletId = args.walletId;
        } else {
          this.walletId = 698983191;
        }
      }
      writeTo(cell) {
        cell.bits.writeUint(this.walletId, 32);
        if (this.seqno === 0) {
          for (let i = 0; i < 32; i++) {
            cell.bits.writeBit(1);
          }
        } else {
          cell.bits.writeUint(this.timeout, 32);
        }
        cell.bits.writeUint(this.seqno, 32);
        cell.bits.writeUint8(this.sendMode);
        let orderCell = new Cell_1.Cell();
        this.order.writeTo(orderCell);
        cell.refs.push(orderCell);
      }
    };
    exports.WalletV3SigningMessage = WalletV3SigningMessage;
  }
});

// node_modules/ton/dist/contracts/messages/WalletV4SigningMessage.js
var require_WalletV4SigningMessage = __commonJS({
  "node_modules/ton/dist/contracts/messages/WalletV4SigningMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV4SigningMessage = void 0;
    var Cell_1 = require_Cell();
    var WalletV4SigningMessage = class {
      constructor(args) {
        this.order = args.order;
        this.sendMode = args.sendMode;
        if (args.timeout !== void 0 && args.timeout !== null) {
          this.timeout = args.timeout;
        } else {
          this.timeout = Math.floor(Date.now() / 1e3) + 60;
        }
        if (args.seqno !== void 0 && args.seqno !== null) {
          this.seqno = args.seqno;
        } else {
          this.seqno = 0;
        }
        if (args.walletId !== null && args.walletId !== void 0) {
          this.walletId = args.walletId;
        } else {
          this.walletId = 698983191;
        }
      }
      writeTo(cell) {
        cell.bits.writeUint(this.walletId, 32);
        if (this.seqno === 0) {
          for (let i = 0; i < 32; i++) {
            cell.bits.writeBit(1);
          }
        } else {
          cell.bits.writeUint(this.timeout, 32);
        }
        cell.bits.writeUint(this.seqno, 32);
        cell.bits.writeUint8(0);
        if (this.order) {
          cell.bits.writeUint8(this.sendMode);
          let orderCell = new Cell_1.Cell();
          this.order.writeTo(orderCell);
          cell.refs.push(orderCell);
        }
      }
    };
    exports.WalletV4SigningMessage = WalletV4SigningMessage;
  }
});

// node_modules/ton/dist/contracts/messages/createWalletTransfer.js
var require_createWalletTransfer = __commonJS({
  "node_modules/ton/dist/contracts/messages/createWalletTransfer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletTransferV4 = exports.createWalletTransferV3 = exports.createWalletTransferV2 = exports.createWalletTransferV1 = void 0;
    var ton_crypto_1 = require_dist();
    var __1 = require_dist2();
    var WalletV1SigningMessage_1 = require_WalletV1SigningMessage();
    var WalletV2SigningMessage_1 = require_WalletV2SigningMessage();
    var WalletV3SigningMessage_1 = require_WalletV3SigningMessage();
    var WalletV4SigningMessage_1 = require_WalletV4SigningMessage();
    function createWalletTransferV1(args) {
      let signingMessage = new WalletV1SigningMessage_1.WalletV1SigningMessage({
        seqno: args.seqno,
        sendMode: args.sendMode,
        order: args.order
      });
      const cell = new __1.Cell();
      signingMessage.writeTo(cell);
      let signature = (0, ton_crypto_1.sign)(cell.hash(), args.secretKey);
      const body = new __1.Cell();
      body.bits.writeBuffer(signature);
      signingMessage.writeTo(body);
      return body;
    }
    exports.createWalletTransferV1 = createWalletTransferV1;
    function createWalletTransferV2(args) {
      let signingMessage = new WalletV2SigningMessage_1.WalletV2SigningMessage({
        seqno: args.seqno,
        sendMode: args.sendMode,
        order: args.order,
        timeout: args.timeout
      });
      const cell = new __1.Cell();
      signingMessage.writeTo(cell);
      let signature = (0, ton_crypto_1.sign)(cell.hash(), args.secretKey);
      const body = new __1.Cell();
      body.bits.writeBuffer(signature);
      signingMessage.writeTo(body);
      return body;
    }
    exports.createWalletTransferV2 = createWalletTransferV2;
    function createWalletTransferV3(args) {
      let signingMessage = new WalletV3SigningMessage_1.WalletV3SigningMessage({
        timeout: args.timeout,
        walletId: args.walletId,
        seqno: args.seqno,
        sendMode: args.sendMode,
        order: args.order
      });
      const cell = new __1.Cell();
      signingMessage.writeTo(cell);
      let signature = (0, ton_crypto_1.sign)(cell.hash(), args.secretKey);
      const body = new __1.Cell();
      body.bits.writeBuffer(signature);
      signingMessage.writeTo(body);
      return body;
    }
    exports.createWalletTransferV3 = createWalletTransferV3;
    function createWalletTransferV4(args) {
      let signingMessage = new WalletV4SigningMessage_1.WalletV4SigningMessage({
        timeout: args.timeout,
        walletId: args.walletId,
        seqno: args.seqno,
        sendMode: args.sendMode,
        order: args.order
      });
      const cell = new __1.Cell();
      signingMessage.writeTo(cell);
      let signature;
      if (args.secretKey) {
        signature = (0, ton_crypto_1.sign)(cell.hash(), args.secretKey);
      } else {
        signature = Buffer.alloc(64);
      }
      const body = new __1.Cell();
      body.bits.writeBuffer(signature);
      signingMessage.writeTo(body);
      return body;
    }
    exports.createWalletTransferV4 = createWalletTransferV4;
  }
});

// node_modules/ton/dist/contracts/contractAddress.js
var require_contractAddress = __commonJS({
  "node_modules/ton/dist/contracts/contractAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contractAddress = void 0;
    var __1 = require_dist2();
    function contractAddress(source) {
      let cell = new __1.Cell();
      let state = new __1.StateInit({ code: source.initialCode, data: source.initialData });
      state.writeTo(cell);
      let hash = cell.hash();
      return new __1.Address(source.workchain, hash);
    }
    exports.contractAddress = contractAddress;
  }
});

// node_modules/ton/dist/contracts/WalletContract.js
var require_WalletContract = __commonJS({
  "node_modules/ton/dist/contracts/WalletContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletContract = void 0;
    var createWalletTransfer_1 = require_createWalletTransfer();
    var contractAddress_1 = require_contractAddress();
    var WalletContract = class {
      constructor(client, source, address) {
        this.client = client;
        this.address = address;
        this.source = source;
      }
      static create(client, source) {
        let address = (0, contractAddress_1.contractAddress)(source);
        return new WalletContract(client, source, address);
      }
      async getSeqNo() {
        if (await this.client.isContractDeployed(this.address)) {
          let res = await this.client.callGetMethod(this.address, "seqno");
          return parseInt(res.stack[0][1], 16);
        } else {
          return 0;
        }
      }
      createTransfer(args) {
        switch (this.source.walletVersion) {
          case "v1":
            return (0, createWalletTransfer_1.createWalletTransferV1)({ seqno: args.seqno, sendMode: args.sendMode, secretKey: args.secretKey, order: args.order });
          case "v2":
            return (0, createWalletTransfer_1.createWalletTransferV2)({ seqno: args.seqno, sendMode: args.sendMode, secretKey: args.secretKey, order: args.order, timeout: args.timeout });
          case "v3":
            return (0, createWalletTransfer_1.createWalletTransferV3)({ seqno: args.seqno, sendMode: args.sendMode, secretKey: args.secretKey, order: args.order, walletId: this.source.walletId, timeout: args.timeout });
          case "v4":
            return (0, createWalletTransfer_1.createWalletTransferV4)({ seqno: args.seqno, sendMode: args.sendMode, secretKey: args.secretKey, order: args.order, walletId: this.source.walletId, timeout: args.timeout });
          default:
            throw Error("Unknown contract type: " + this.source.type);
        }
      }
    };
    exports.WalletContract = WalletContract;
  }
});

// node_modules/ton/dist/messages/InternalMessage.js
var require_InternalMessage = __commonJS({
  "node_modules/ton/dist/messages/InternalMessage.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InternalMessage = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var InternalMessage = class {
      constructor(opts) {
        this.to = opts.to;
        this.value = new bn_js_1.default(opts.value);
        this.bounce = opts.bounce;
        this.body = opts.body;
        if (opts.from) {
          this.from = opts.from;
        } else {
          this.from = null;
        }
        if (opts.ihrDisabled !== null && opts.ihrDisabled !== void 0) {
          this.ihrDisabled = opts.ihrDisabled;
        } else {
          this.ihrDisabled = true;
        }
        if (opts.bounced !== null && opts.bounced !== void 0) {
          this.bounced = opts.bounced;
        } else {
          this.bounced = false;
        }
        if (opts.ihrFees !== null && opts.ihrFees !== void 0) {
          this.ihrFees = new bn_js_1.default(opts.ihrFees);
        } else {
          this.ihrFees = new bn_js_1.default(0);
        }
        if (opts.fwdFees !== null && opts.fwdFees !== void 0) {
          this.fwdFees = new bn_js_1.default(opts.fwdFees);
        } else {
          this.fwdFees = new bn_js_1.default(0);
        }
        if (opts.createdAt !== null && opts.createdAt !== void 0) {
          this.createdAt = new bn_js_1.default(opts.createdAt);
        } else {
          this.createdAt = new bn_js_1.default(0);
        }
        if (opts.createdLt !== null && opts.createdLt !== void 0) {
          this.createdLt = new bn_js_1.default(opts.createdLt);
        } else {
          this.createdLt = new bn_js_1.default(0);
        }
      }
      writeTo(cell) {
        cell.bits.writeBit(0);
        cell.bits.writeBit(this.ihrDisabled);
        cell.bits.writeBit(this.bounce);
        cell.bits.writeBit(this.bounced);
        cell.bits.writeAddress(this.from);
        cell.bits.writeAddress(this.to);
        cell.bits.writeCoins(this.value);
        cell.bits.writeBit(false);
        cell.bits.writeCoins(this.ihrFees);
        cell.bits.writeCoins(this.fwdFees);
        cell.bits.writeUint(this.createdLt, 64);
        cell.bits.writeUint(this.createdAt, 32);
        this.body.writeTo(cell);
      }
    };
    exports.InternalMessage = InternalMessage;
  }
});

// node_modules/ton/dist/client/SendMode.js
var require_SendMode = __commonJS({
  "node_modules/ton/dist/client/SendMode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SendMode = void 0;
    var SendMode;
    (function(SendMode2) {
      SendMode2[SendMode2["CARRRY_ALL_REMAINING_BALANCE"] = 128] = "CARRRY_ALL_REMAINING_BALANCE";
      SendMode2[SendMode2["CARRRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRRY_ALL_REMAINING_INCOMING_VALUE";
      SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
      SendMode2[SendMode2["PAY_GAS_SEPARATLY"] = 1] = "PAY_GAS_SEPARATLY";
      SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    })(SendMode = exports.SendMode || (exports.SendMode = {}));
  }
});

// node_modules/ton/dist/client/Wallet.js
var require_Wallet = __commonJS({
  "node_modules/ton/dist/client/Wallet.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Wallet_client;
    var _Wallet_contract;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wallet = exports.validateWalletType = exports.allTypes = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var ton_crypto_1 = require_dist();
    var __1 = require_dist2();
    var WalletV1R2Source_1 = require_WalletV1R2Source();
    var WalletV1R3Source_1 = require_WalletV1R3Source();
    var WalletV2R1Source_1 = require_WalletV2R1Source();
    var WalletV2R2Source_1 = require_WalletV2R2Source();
    var WalletV3R1Source_1 = require_WalletV3R1Source();
    var WalletV3R2Source_1 = require_WalletV3R2Source();
    var WalletV4Source_1 = require_WalletV4Source();
    var WalletContract_1 = require_WalletContract();
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    var InternalMessage_1 = require_InternalMessage();
    var SendMode_1 = require_SendMode();
    exports.allTypes = [
      "org.ton.wallets.simple.r2",
      "org.ton.wallets.simple.r3",
      "org.ton.wallets.v2",
      "org.ton.wallets.v2.r2",
      "org.ton.wallets.v4",
      "org.ton.wallets.v3.r2",
      "org.ton.wallets.v3"
    ];
    function validateWalletType(src) {
      if (src === "org.ton.wallets.simple" || src === "org.ton.wallets.simple.r2" || src === "org.ton.wallets.simple.r3" || src === "org.ton.wallets.v2" || src === "org.ton.wallets.v2.r2" || src === "org.ton.wallets.v3" || src === "org.ton.wallets.v3.r2" || src === "org.ton.wallets.v4") {
        return src;
      }
      return null;
    }
    exports.validateWalletType = validateWalletType;
    function createContract(client, type2, publicKey, workchain) {
      if (type2 === "org.ton.wallets.simple") {
        throw Error("Unsupported wallet");
      } else if (type2 === "org.ton.wallets.simple.r2") {
        return WalletContract_1.WalletContract.create(client, WalletV1R2Source_1.WalletV1R2Source.create({ publicKey, workchain }));
      } else if (type2 === "org.ton.wallets.simple.r3") {
        return WalletContract_1.WalletContract.create(client, WalletV1R3Source_1.WalletV1R3Source.create({ publicKey, workchain }));
      } else if (type2 === "org.ton.wallets.v2") {
        return WalletContract_1.WalletContract.create(client, WalletV2R1Source_1.WalletV2R1Source.create({ publicKey, workchain }));
      } else if (type2 === "org.ton.wallets.v2.r2") {
        return WalletContract_1.WalletContract.create(client, WalletV2R2Source_1.WalletV2R2Source.create({ publicKey, workchain }));
      } else if (type2 === "org.ton.wallets.v3") {
        return WalletContract_1.WalletContract.create(client, WalletV3R1Source_1.WalletV3R1Source.create({ publicKey, workchain }));
      } else if (type2 === "org.ton.wallets.v3.r2") {
        return WalletContract_1.WalletContract.create(client, WalletV3R2Source_1.WalletV3R2Source.create({ publicKey, workchain }));
      } else if (type2 === "org.ton.wallets.v4") {
        return WalletContract_1.WalletContract.create(client, WalletV4Source_1.WalletV4Source.create({ publicKey, workchain }));
      } else {
        throw Error("Unknown wallet type: " + type2);
      }
    }
    var Wallet = class {
      constructor(client, address) {
        _Wallet_client.set(this, void 0);
        _Wallet_contract.set(this, null);
        __classPrivateFieldSet(this, _Wallet_client, client, "f");
        this.address = address;
      }
      static open(client, address) {
        return new Wallet(client, address);
      }
      static openDefault(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let c = createContract(client, "org.ton.wallets.v3", publicKey, workchain);
        let w = new Wallet(client, c.address);
        w.prepare(workchain, publicKey, "org.ton.wallets.v3");
        return w;
      }
      static openByType(client, workchain, secretKey, type2) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let c = createContract(client, type2, publicKey, workchain);
        let w = new Wallet(client, c.address);
        w.prepare(workchain, publicKey, type2);
        return w;
      }
      static openFromSource(client, source) {
        let address = (0, __1.contractAddress)(source);
        let w = new Wallet(client, address);
        w.prepareFromSource(source);
        return w;
      }
      static async findActiveBySecretKey(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let types = [];
        for (let type2 of exports.allTypes) {
          let contra = createContract(client, type2, publicKey, workchain);
          let deployed = await client.isContractDeployed(contra.address);
          let balance = await client.getBalance(contra.address);
          if (deployed || balance.gt(new bn_js_1.default(0))) {
            types.push({ address: contra.address, type: type2, balance, deployed });
          }
        }
        return types;
      }
      static async findBestBySecretKey(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let allActive = await this.findActiveBySecretKey(client, workchain, secretKey);
        if (allActive.length === 0) {
          return this.openDefault(client, workchain, secretKey);
        }
        let maxBalance = allActive[0].balance;
        let bestContract = allActive[0].type;
        for (let i = 1; i < allActive.length; i++) {
          let ac = allActive[i];
          if (ac.balance.gte(maxBalance)) {
            maxBalance = ac.balance;
            bestContract = ac.type;
          }
        }
        if (maxBalance.gt(new bn_js_1.default(0))) {
          let c2 = createContract(client, bestContract, publicKey, workchain);
          ;
          let w2 = new Wallet(client, c2.address);
          w2.prepare(workchain, publicKey, bestContract);
          return w2;
        }
        let c = createContract(client, allActive[allActive.length - 1].type, publicKey, workchain);
        let w = new Wallet(client, c.address);
        w.prepare(workchain, publicKey, allActive[allActive.length - 1].type);
        return w;
      }
      get prepared() {
        return !!__classPrivateFieldGet(this, _Wallet_contract, "f");
      }
      async getSeqNo() {
        if (await __classPrivateFieldGet(this, _Wallet_client, "f").isContractDeployed(this.address)) {
          let res = await __classPrivateFieldGet(this, _Wallet_client, "f").callGetMethod(this.address, "seqno");
          return parseInt(res.stack[0][1], 16);
        } else {
          return 0;
        }
      }
      prepare(workchain, publicKey, type2 = "org.ton.wallets.v3") {
        let contra = createContract(__classPrivateFieldGet(this, _Wallet_client, "f"), type2, publicKey, workchain);
        if (!contra.address.equals(this.address)) {
          throw Error("Contract have different address");
        }
        __classPrivateFieldSet(this, _Wallet_contract, contra, "f");
      }
      prepareFromSource(source) {
        let contra = WalletContract_1.WalletContract.create(__classPrivateFieldGet(this, _Wallet_client, "f"), source);
        if (!contra.address.equals(this.address)) {
          throw Error("Contract have different address");
        }
        __classPrivateFieldSet(this, _Wallet_contract, contra, "f");
      }
      async transfer(args) {
        const contract = __classPrivateFieldGet(this, _Wallet_contract, "f");
        if (!contract) {
          throw Error("Please, prepare wallet first");
        }
        let payload = null;
        if (args.payload) {
          if (typeof args.payload === "string") {
            payload = new __1.CommentMessage(args.payload);
          } else if (Buffer.isBuffer(args.payload)) {
            payload = new __1.BinaryMessage(args.payload);
          } else if (args.payload instanceof __1.Cell) {
            payload = new __1.CellMessage(args.payload);
          }
        }
        const transfer = await contract.createTransfer({
          secretKey: args.secretKey,
          seqno: args.seqno,
          sendMode: args.sendMode || SendMode_1.SendMode.IGNORE_ERRORS + SendMode_1.SendMode.PAY_GAS_SEPARATLY,
          timeout: args.timeout,
          order: new InternalMessage_1.InternalMessage({
            to: args.to,
            value: args.value,
            bounce: args.bounce,
            body: new CommonMessageInfo_1.CommonMessageInfo({ body: payload })
          })
        });
        await __classPrivateFieldGet(this, _Wallet_client, "f").sendExternalMessage(contract, transfer);
      }
      transferSign(args) {
        const contract = __classPrivateFieldGet(this, _Wallet_contract, "f");
        if (!contract) {
          throw Error("Please, prepare wallet first");
        }
        let payload = null;
        if (args.payload) {
          if (typeof args.payload === "string") {
            payload = new __1.CommentMessage(args.payload);
          } else if (Buffer.isBuffer(args.payload)) {
            payload = new __1.BinaryMessage(args.payload);
          } else if (args.payload instanceof __1.Cell) {
            payload = new __1.CellMessage(args.payload);
          }
        }
        const transfer = contract.createTransfer({
          secretKey: args.secretKey,
          seqno: args.seqno,
          sendMode: args.sendMode || SendMode_1.SendMode.IGNORE_ERRORS + SendMode_1.SendMode.PAY_GAS_SEPARATLY,
          timeout: args.timeout,
          order: new InternalMessage_1.InternalMessage({
            to: args.to,
            value: args.value,
            bounce: args.bounce,
            body: new CommonMessageInfo_1.CommonMessageInfo({ body: payload })
          })
        });
        const message = new __1.ExternalMessage({
          to: contract.address,
          body: new CommonMessageInfo_1.CommonMessageInfo({
            stateInit: new __1.StateInit({ code: contract.source.initialCode, data: contract.source.initialData }),
            body: new __1.CellMessage(transfer)
          })
        });
        const res = new __1.Cell();
        message.writeTo(res);
        return res;
      }
      async transferCommit(transfer) {
        await __classPrivateFieldGet(this, _Wallet_client, "f").sendFile(transfer.toBoc({ idx: false }));
      }
    };
    exports.Wallet = Wallet;
    _Wallet_client = /* @__PURE__ */ new WeakMap(), _Wallet_contract = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/ton/dist/boc/Builder.js
var require_Builder = __commonJS({
  "node_modules/ton/dist/boc/Builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.beginCell = exports.Builder = void 0;
    var BitString_1 = require_BitString();
    var Cell_1 = require_Cell();
    var Builder = class {
      constructor() {
        this.bits = BitString_1.BitString.alloc(1023);
        this.refs = [];
        this.ended = false;
        this.storeRef = (src) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.refs.push(src);
          return this;
        };
        this.storeBit = (value) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeBit(value);
          return this;
        };
        this.storeBitArray = (value) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeBitArray(value);
          return this;
        };
        this.storeUint = (value, bitLength) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeUint(value, bitLength);
          return this;
        };
        this.storeInt = (value, bitLength) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeInt(value, bitLength);
          return this;
        };
        this.storeUint8 = (value) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeUint8(value);
          return this;
        };
        this.storeVarUint = (value, bitLength) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeVarUInt(value, bitLength);
          return this;
        };
        this.storeBuffer = (buffer) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeBuffer(buffer);
          return this;
        };
        this.storeCoins = (amount) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeCoins(amount);
          return this;
        };
        this.storeAddress = (address) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeAddress(address);
          return this;
        };
        this.storeBitString = (value) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.bits.writeBitString(value);
          return this;
        };
        this.storeDict = (src) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          if (src) {
            this.bits.writeBit(true);
            this.refs.push(src);
          } else {
            this.bits.writeBit(false);
          }
          return this;
        };
        this.storeRefMaybe = (src) => {
          return this.storeDict(src);
        };
      }
      endCell() {
        if (this.ended) {
          throw Error("Already ended");
        }
        this.ended = true;
        let res = new Cell_1.Cell("ordinary", this.bits);
        for (let r of this.refs) {
          res.refs.push(r);
        }
        return res;
      }
    };
    exports.Builder = Builder;
    function beginCell() {
      return new Builder();
    }
    exports.beginCell = beginCell;
  }
});

// node_modules/ton/dist/boc/dict/parseDict.js
var require_parseDict = __commonJS({
  "node_modules/ton/dist/boc/dict/parseDict.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDictRefs = exports.parseDictBitString = exports.parseDict = void 0;
    var bn_js_1 = require_bn();
    function doParse(prefix, slice, n, res, extractor) {
      let lb0 = slice.readBit() ? 1 : 0;
      let prefixLength = 0;
      let pp = prefix;
      if (lb0 === 0) {
        prefixLength = slice.readUnaryLength();
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.readBit() ? "1" : "0";
        }
      } else {
        let lb1 = slice.readBit() ? 1 : 0;
        if (lb1 === 0) {
          prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += slice.readBit() ? "1" : "0";
          }
        } else {
          let bit = slice.readBit() ? "1" : "0";
          prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += bit;
          }
        }
      }
      if (n - prefixLength === 0) {
        res.set(new bn_js_1.BN(pp, 2).toString(10), extractor(slice));
      } else {
        let left4 = slice.readCell();
        let right4 = slice.readCell();
        if (!left4.isExotic) {
          doParse(pp + "0", left4.beginParse(), n - prefixLength - 1, res, extractor);
        }
        if (!right4.isExotic) {
          doParse(pp + "1", right4.beginParse(), n - prefixLength - 1, res, extractor);
        }
      }
    }
    function parseDict(slice, keySize, extractor) {
      let res = /* @__PURE__ */ new Map();
      doParse("", slice, keySize, res, extractor);
      return res;
    }
    exports.parseDict = parseDict;
    function parseDictBitString(slice, keySize) {
      let res = /* @__PURE__ */ new Map();
      doParse("", slice, keySize, res, (slice2) => slice2.readRemaining());
      return res;
    }
    exports.parseDictBitString = parseDictBitString;
    function parseDictRefs(slice, keySize) {
      let res = /* @__PURE__ */ new Map();
      doParse("", slice, keySize, res, (slice2) => slice2.readRef());
      return res;
    }
    exports.parseDictRefs = parseDictRefs;
  }
});

// node_modules/ton/dist/contracts/configs/configParsing.js
var require_configParsing = __commonJS({
  "node_modules/ton/dist/contracts/configs/configParsing.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFullConfig = exports.parseVotingSetup = exports.parseProposalSetup = exports.configParse29 = exports.configParse28 = exports.configParseMsgPrices = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParseValidatorSet = exports.configParse12 = exports.configParse40 = exports.configParse8 = exports.configParse18 = exports.configParse17 = exports.configParse16 = exports.configParse15 = exports.configParseMasterAddressRequired = exports.parseBridge = exports.parseValidatorSet = exports.parseValidatorDescr = exports.configParseWorkchainDescriptor = exports.configParseMasterAddress = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var __1 = require_dist2();
    var parseDict_1 = require_parseDict();
    function configParseMasterAddress(slice) {
      if (slice) {
        return new __1.Address(-1, slice.readBuffer(32));
      } else {
        return null;
      }
    }
    exports.configParseMasterAddress = configParseMasterAddress;
    function configParseWorkchainDescriptor(slice) {
      if (slice.readUint(8).toNumber() !== 166) {
        throw Error("Invalid config");
      }
      let enabledSince = slice.readUint(32).toNumber();
      let actialMinSplit = slice.readUint(8).toNumber();
      let min_split = slice.readUint(8).toNumber();
      let max_split = slice.readUint(8).toNumber();
      let basic = slice.readBit();
      let active = slice.readBit();
      let accept_msgs = slice.readBit();
      let flags = slice.readUint(13).toNumber();
      let zerostateRootHash = slice.readBuffer(32);
      let zerostateFileHash = slice.readBuffer(32);
      let version = slice.readUint(32).toNumber();
      if (slice.readBit()) {
        throw Error("Invalid config");
      }
      let vmVersion = slice.readUint(32).toNumber();
      let vmMode = slice.readUint(64);
      return {
        enabledSince,
        actialMinSplit,
        min_split,
        max_split,
        basic,
        active,
        accept_msgs,
        flags,
        zerostateRootHash,
        zerostateFileHash,
        version,
        format: {
          vmVersion,
          vmMode
        }
      };
    }
    exports.configParseWorkchainDescriptor = configParseWorkchainDescriptor;
    function readPublicKey(slice) {
      if (slice.readUint(32).toNumber() !== 2390828938) {
        throw Error("Invalid config");
      }
      return slice.readBuffer(32);
    }
    function parseValidatorDescr(slice) {
      let header = slice.readUint(8).toNumber();
      if (header === 83) {
        return {
          publicKey: readPublicKey(slice),
          weight: slice.readUint(64),
          adnlAddress: null
        };
      } else if (header === 115) {
        return {
          publicKey: readPublicKey(slice),
          weight: slice.readUint(64),
          adnlAddress: slice.readBuffer(32)
        };
      } else {
        throw Error("Invalid config");
      }
    }
    exports.parseValidatorDescr = parseValidatorDescr;
    function parseValidatorSet(slice) {
      let header = slice.readUint(8).toNumber();
      if (header === 17) {
        let timeSince = slice.readUint(32).toNumber();
        let timeUntil = slice.readUint(32).toNumber();
        let total = slice.readUint(16).toNumber();
        let main = slice.readUint(16).toNumber();
        let list = (0, parseDict_1.parseDict)(slice.readRef(), 16, parseValidatorDescr);
        return {
          timeSince,
          timeUntil,
          total,
          main,
          totalWeight: null,
          list
        };
      } else if (header === 18) {
        let timeSince = slice.readUint(32).toNumber();
        let timeUntil = slice.readUint(32).toNumber();
        let total = slice.readUint(16).toNumber();
        let main = slice.readUint(16).toNumber();
        let totalWeight = slice.readUint(64);
        let exists4 = slice.readBit();
        let list = exists4 ? (0, parseDict_1.parseDict)(slice.readRef(), 16, parseValidatorDescr) : null;
        return {
          timeSince,
          timeUntil,
          total,
          main,
          totalWeight,
          list
        };
      }
    }
    exports.parseValidatorSet = parseValidatorSet;
    function parseBridge(slice) {
      let bridgeAddress = slice.readBuffer(32);
      let oracleMultisigAddress = slice.readBuffer(32);
      let oracles = slice.readBit() ? (0, parseDict_1.parseDict)(slice.readRef(), 256, (slice2) => slice2.readBuffer(32)) : null;
      let externalChainAddress = slice.readBuffer(32);
      return {
        bridgeAddress,
        oracleMultisigAddress,
        oracles,
        externalChainAddress
      };
    }
    exports.parseBridge = parseBridge;
    function configParseMasterAddressRequired(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      return configParseMasterAddress(slice);
    }
    exports.configParseMasterAddressRequired = configParseMasterAddressRequired;
    function configParse15(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      let validatorsElectedFor = slice.readUintNumber(32);
      let electorsStartBefore = slice.readUintNumber(32);
      let electorsEndBefore = slice.readUintNumber(32);
      let stakeHeldFor = slice.readUintNumber(32);
      return {
        validatorsElectedFor,
        electorsStartBefore,
        electorsEndBefore,
        stakeHeldFor
      };
    }
    exports.configParse15 = configParse15;
    function configParse16(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      let maxValidators = slice.readUintNumber(16);
      let maxMainValidators = slice.readUintNumber(16);
      let minValidators = slice.readUintNumber(16);
      return {
        maxValidators,
        maxMainValidators,
        minValidators
      };
    }
    exports.configParse16 = configParse16;
    function configParse17(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      let minStake = slice.readCoins();
      let maxStake = slice.readCoins();
      let minTotalStake = slice.readCoins();
      let maxStakeFactor = slice.readUintNumber(32);
      return {
        minStake,
        maxStake,
        minTotalStake,
        maxStakeFactor
      };
    }
    exports.configParse17 = configParse17;
    function configParse18(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      let result = [];
      (0, parseDict_1.parseDict)(slice, 32, (slice2) => {
        let header = slice2.readUintNumber(8);
        if (header !== 204) {
          throw Error("Invalid config");
        }
        let utime_since = slice2.readUint(32);
        let bit_price_ps = slice2.readUint(64);
        let cell_price_ps = slice2.readUint(64);
        let mc_bit_price_ps = slice2.readUint(64);
        let mc_cell_price_ps = slice2.readUint(64);
        return {
          utime_since,
          bit_price_ps,
          cell_price_ps,
          mc_bit_price_ps,
          mc_cell_price_ps
        };
      }).forEach((a) => {
        result.push(a);
      });
      return result;
    }
    exports.configParse18 = configParse18;
    function configParse8(slice) {
      if (!slice) {
        return {
          version: 0,
          capabilities: new bn_js_1.default(0)
        };
      }
      let version = slice.readUintNumber(32);
      let capabilities = slice.readUint(64);
      return {
        version,
        capabilities
      };
    }
    exports.configParse8 = configParse8;
    function configParse40(slice) {
      if (!slice) {
        return null;
      }
      let header = slice.readUintNumber(8);
      if (header !== 1) {
        throw Error("Invalid config");
      }
      let defaultFlatFine = slice.readCoins();
      let defaultProportionaFine = slice.readCoins();
      let severityFlatMult = slice.readUintNumber(16);
      let severityProportionalMult = slice.readUintNumber(16);
      let unfunishableInterval = slice.readUintNumber(16);
      let longInterval = slice.readUintNumber(16);
      let longFlatMult = slice.readUintNumber(16);
      let longProportionalMult = slice.readUintNumber(16);
      let mediumInterval = slice.readUintNumber(16);
      let mediumFlatMult = slice.readUintNumber(16);
      let mediumProportionalMult = slice.readUintNumber(16);
      return {
        defaultFlatFine,
        defaultProportionaFine,
        severityFlatMult,
        severityProportionalMult,
        unfunishableInterval,
        longInterval,
        longFlatMult,
        longProportionalMult,
        mediumInterval,
        mediumFlatMult,
        mediumProportionalMult
      };
    }
    exports.configParse40 = configParse40;
    function configParse12(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      if (slice.readUint(1).toNumber()) {
        return (0, parseDict_1.parseDict)(slice.readRef(), 32, configParseWorkchainDescriptor);
      } else {
        throw Error("No workchains exist");
      }
    }
    exports.configParse12 = configParse12;
    function configParseValidatorSet(slice) {
      if (!slice) {
        return null;
      }
      return parseValidatorSet(slice);
    }
    exports.configParseValidatorSet = configParseValidatorSet;
    function configParseBridge(slice) {
      if (!slice) {
        return null;
      }
      return parseBridge(slice);
    }
    exports.configParseBridge = configParseBridge;
    function parseGasLimitsInternal(slice) {
      const tag = slice.readUintNumber(8);
      if (tag === 222) {
        const gasPrice = slice.readUint(64);
        const gasLimit = slice.readUint(64);
        const specialGasLimit = slice.readUint(64);
        const gasCredit = slice.readUint(64);
        const blockGasLimit = slice.readUint(64);
        const freezeDueLimit = slice.readUint(64);
        const deleteDueLimit = slice.readUint(64);
        return {
          gasPrice,
          gasLimit,
          specialGasLimit,
          gasCredit,
          blockGasLimit,
          freezeDueLimit,
          deleteDueLimit
        };
      } else if (tag === 221) {
        const gasPrice = slice.readUint(64);
        const gasLimit = slice.readUint(64);
        const gasCredit = slice.readUint(64);
        const blockGasLimit = slice.readUint(64);
        const freezeDueLimit = slice.readUint(64);
        const deleteDueLimit = slice.readUint(64);
        return {
          gasPrice,
          gasLimit,
          gasCredit,
          blockGasLimit,
          freezeDueLimit,
          deleteDueLimit
        };
      } else {
        throw Error("Invalid config");
      }
    }
    function configParseGasLimitsPrices(slice) {
      if (!slice) {
        throw Error("Invalid config");
      }
      const tag = slice.readUintNumber(8);
      if (tag === 209) {
        const flatLimit = slice.readUint(64);
        const flatGasPrice = slice.readUint(64);
        const other = parseGasLimitsInternal(slice);
        return {
          flatLimit,
          flatGasPrice,
          other
        };
      } else {
        throw Error("Invalid config");
      }
    }
    exports.configParseGasLimitsPrices = configParseGasLimitsPrices;
    function configParseMsgPrices(slice) {
      if (!slice) {
        throw new Error("Invalid config");
      }
      let magic = slice.readUintNumber(8);
      if (magic !== 234) {
        throw new Error("Invalid msg prices param");
      }
      return {
        lumpPrice: slice.readUint(64),
        bitPrice: slice.readUint(64),
        cellPrice: slice.readUint(64),
        ihrPriceFactor: slice.readUint(32),
        firstFrac: slice.readUint(16),
        nextFrac: slice.readUint(16)
      };
    }
    exports.configParseMsgPrices = configParseMsgPrices;
    function configParse28(slice) {
      if (!slice) {
        throw new Error("Invalid config");
      }
      let magic = slice.readUintNumber(8);
      if (magic === 193) {
        let masterCatchainLifetime = slice.readUintNumber(32);
        let shardCatchainLifetime = slice.readUintNumber(32);
        let shardValidatorsLifetime = slice.readUintNumber(32);
        let shardValidatorsCount = slice.readUintNumber(32);
        return {
          masterCatchainLifetime,
          shardCatchainLifetime,
          shardValidatorsLifetime,
          shardValidatorsCount
        };
      }
      if (magic === 194) {
        let flags = slice.readUintNumber(7);
        let suffleMasterValidators = slice.readBit();
        let masterCatchainLifetime = slice.readUintNumber(32);
        let shardCatchainLifetime = slice.readUintNumber(32);
        let shardValidatorsLifetime = slice.readUintNumber(32);
        let shardValidatorsCount = slice.readUintNumber(32);
        return {
          flags,
          suffleMasterValidators,
          masterCatchainLifetime,
          shardCatchainLifetime,
          shardValidatorsLifetime,
          shardValidatorsCount
        };
      }
      throw new Error("Invalid config");
    }
    exports.configParse28 = configParse28;
    function configParse29(slice) {
      if (!slice) {
        throw new Error("Invalid config");
      }
      let magic = slice.readUintNumber(8);
      if (magic === 214) {
        let roundCandidates = slice.readUintNumber(32);
        let nextCandidateDelay = slice.readUintNumber(32);
        let consensusTimeout = slice.readUintNumber(32);
        let fastAttempts = slice.readUintNumber(32);
        let attemptDuration = slice.readUintNumber(32);
        let catchainMaxDeps = slice.readUintNumber(32);
        let maxBlockBytes = slice.readUintNumber(32);
        let maxColaltedBytes = slice.readUintNumber(32);
        return {
          roundCandidates,
          nextCandidateDelay,
          consensusTimeout,
          fastAttempts,
          attemptDuration,
          catchainMaxDeps,
          maxBlockBytes,
          maxColaltedBytes
        };
      } else if (magic === 215) {
        let flags = slice.readUintNumber(7);
        let newCatchainIds = slice.readBit();
        let roundCandidates = slice.readUintNumber(8);
        let nextCandidateDelay = slice.readUintNumber(32);
        let consensusTimeout = slice.readUintNumber(32);
        let fastAttempts = slice.readUintNumber(32);
        let attemptDuration = slice.readUintNumber(32);
        let catchainMaxDeps = slice.readUintNumber(32);
        let maxBlockBytes = slice.readUintNumber(32);
        let maxColaltedBytes = slice.readUintNumber(32);
        return {
          flags,
          newCatchainIds,
          roundCandidates,
          nextCandidateDelay,
          consensusTimeout,
          fastAttempts,
          attemptDuration,
          catchainMaxDeps,
          maxBlockBytes,
          maxColaltedBytes
        };
      } else if (magic === 216) {
        let flags = slice.readUintNumber(7);
        let newCatchainIds = slice.readBit();
        let roundCandidates = slice.readUintNumber(8);
        let nextCandidateDelay = slice.readUintNumber(32);
        let consensusTimeout = slice.readUintNumber(32);
        let fastAttempts = slice.readUintNumber(32);
        let attemptDuration = slice.readUintNumber(32);
        let catchainMaxDeps = slice.readUintNumber(32);
        let maxBlockBytes = slice.readUintNumber(32);
        let maxColaltedBytes = slice.readUintNumber(32);
        let protoVersion = slice.readUintNumber(16);
        return {
          flags,
          newCatchainIds,
          roundCandidates,
          nextCandidateDelay,
          consensusTimeout,
          fastAttempts,
          attemptDuration,
          catchainMaxDeps,
          maxBlockBytes,
          maxColaltedBytes,
          protoVersion
        };
      } else if (magic === 217) {
        let flags = slice.readUintNumber(7);
        let newCatchainIds = slice.readBit();
        let roundCandidates = slice.readUintNumber(8);
        let nextCandidateDelay = slice.readUintNumber(32);
        let consensusTimeout = slice.readUintNumber(32);
        let fastAttempts = slice.readUintNumber(32);
        let attemptDuration = slice.readUintNumber(32);
        let catchainMaxDeps = slice.readUintNumber(32);
        let maxBlockBytes = slice.readUintNumber(32);
        let maxColaltedBytes = slice.readUintNumber(32);
        let protoVersion = slice.readUintNumber(16);
        let catchainMaxBlocksCoeff = slice.readUintNumber(32);
        return {
          flags,
          newCatchainIds,
          roundCandidates,
          nextCandidateDelay,
          consensusTimeout,
          fastAttempts,
          attemptDuration,
          catchainMaxDeps,
          maxBlockBytes,
          maxColaltedBytes,
          protoVersion,
          catchainMaxBlocksCoeff
        };
      }
      throw new Error("Invalid config");
    }
    exports.configParse29 = configParse29;
    function parseProposalSetup(slice) {
      let magic = slice.readUintNumber(8);
      if (magic !== 54) {
        throw new Error("Invalid config");
      }
      let minTotalRounds = slice.readUintNumber(8);
      let maxTotalRounds = slice.readUintNumber(8);
      let minWins = slice.readUintNumber(8);
      let maxLoses = slice.readUintNumber(8);
      let minStoreSec = slice.readUintNumber(32);
      let maxStoreSec = slice.readUintNumber(32);
      let bitPrice = slice.readUintNumber(32);
      let cellPrice = slice.readUintNumber(32);
      return { minTotalRounds, maxTotalRounds, minWins, maxLoses, minStoreSec, maxStoreSec, bitPrice, cellPrice };
    }
    exports.parseProposalSetup = parseProposalSetup;
    function parseVotingSetup(slice) {
      if (!slice) {
        throw new Error("Invalid config");
      }
      let magic = slice.readUintNumber(8);
      if (magic !== 145) {
        throw new Error("Invalid config");
      }
      let normalParams = parseProposalSetup(slice.readRef());
      let criticalParams = parseProposalSetup(slice.readRef());
      return { normalParams, criticalParams };
    }
    exports.parseVotingSetup = parseVotingSetup;
    function parseFullConfig(configs) {
      return {
        configAddress: configParseMasterAddressRequired(configs.get("0")),
        electorAddress: configParseMasterAddressRequired(configs.get("1")),
        minterAddress: configParseMasterAddress(configs.get("2")),
        feeCollectorAddress: configParseMasterAddress(configs.get("3")),
        dnsRootAddress: configParseMasterAddress(configs.get("4")),
        globalVersion: configParse8(configs.get("8")),
        workchains: configParse12(configs.get("12")),
        voting: parseVotingSetup(configs.get("11")),
        validators: {
          ...configParse15(configs.get("15")),
          ...configParse16(configs.get("16")),
          ...configParse17(configs.get("17"))
        },
        storagePrices: configParse18(configs.get("18")),
        gasPrices: {
          masterchain: configParseGasLimitsPrices(configs.get("20")),
          workchain: configParseGasLimitsPrices(configs.get("21"))
        },
        msgPrices: {
          masterchain: configParseMsgPrices(configs.get("24")),
          workchain: configParseMsgPrices(configs.get("25"))
        },
        validatorSets: {
          prevValidators: configParseValidatorSet(configs.get("32")),
          prevTempValidators: configParseValidatorSet(configs.get("33")),
          currentValidators: configParseValidatorSet(configs.get("34")),
          currentTempValidators: configParseValidatorSet(configs.get("35")),
          nextValidators: configParseValidatorSet(configs.get("36")),
          nextTempValidators: configParseValidatorSet(configs.get("37"))
        },
        validatorsPunish: configParse40(configs.get("40")),
        bridges: {
          ethereum: configParseBridge(configs.get("71")),
          binance: configParseBridge(configs.get("72")),
          polygon: configParseBridge(configs.get("73"))
        },
        catchain: configParse28(configs.get("28")),
        consensus: configParse29(configs.get("29"))
      };
    }
    exports.parseFullConfig = parseFullConfig;
  }
});

// node_modules/ton/dist/contracts/ConfigContract.js
var require_ConfigContract = __commonJS({
  "node_modules/ton/dist/contracts/ConfigContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigContract = void 0;
    var __1 = require_dist2();
    var BitStringReader_1 = require_BitStringReader();
    var Builder_1 = require_Builder();
    var parseDict_1 = require_parseDict();
    var configParsing_1 = require_configParsing();
    var ConfigContract = class {
      constructor(client) {
        this.address = __1.Address.parseRaw("-1:5555555555555555555555555555555555555555555555555555555555555555");
        this.source = new __1.UnknownContractSource("org.ton.config", -1, "Config Contract");
        this.client = client;
      }
      async getSeqNo() {
        let res = await this.client.callGetMethod(this.address, "seqno");
        return parseInt(res.stack[0][1], 16);
      }
      async getPublicKey() {
        let data = (await this.client.getContractState(this.address)).data;
        let cell = __1.Cell.fromBoc(data)[0];
        let reader = new BitStringReader_1.BitStringReader(cell.bits);
        reader.readUint(32);
        return reader.readUint(256);
      }
      async getConfigsRaw() {
        let data = (await this.client.getContractState(this.address)).data;
        let slice = __1.Cell.fromBoc(data)[0].beginParse();
        let dict = slice.readRef();
        let res = (0, parseDict_1.parseDictRefs)(dict, 32);
        return res;
      }
      async getConfigs() {
        let configs = await this.getConfigsRaw();
        return (0, configParsing_1.parseFullConfig)(configs);
      }
      async createProposal(args) {
        return (0, Builder_1.beginCell)().storeUint(1851150418, 32).storeUint(args.queryId, 64).storeUint(args.expiresAt, 32).storeRef((0, Builder_1.beginCell)().storeUint(243, 8).storeUint(args.paramId, 32).storeRefMaybe(args.paramValue).storeRefMaybe(args.ifHashEqual).endCell()).storeBit(args.critical).endCell();
      }
    };
    exports.ConfigContract = ConfigContract;
  }
});

// node_modules/ton/dist/client/TonCache.js
var require_TonCache = __commonJS({
  "node_modules/ton/dist/client/TonCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemoryCache = void 0;
    var InMemoryCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
        this.set = async (namespace, key, value) => {
          if (value !== null) {
            this.cache.set(namespace + "$$" + key, value);
          } else {
            this.cache.delete(namespace + "$$" + key);
          }
        };
        this.get = async (namespace, key) => {
          let res = this.cache.get(namespace + "$$" + key);
          if (res !== void 0) {
            return res;
          } else {
            return null;
          }
        };
      }
    };
    exports.InMemoryCache = InMemoryCache;
  }
});

// node_modules/ton/dist/client/TonClient.js
var require_TonClient = __commonJS({
  "node_modules/ton/dist/client/TonClient.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _TonClient_api;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonClient = void 0;
    var ton_crypto_1 = require_dist();
    var Address_1 = require_Address();
    var Cell_1 = require_Cell();
    var HttpApi_1 = require_HttpApi();
    var ExternalMessage_1 = require_ExternalMessage();
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    var StateInit_1 = require_StateInit();
    var Wallet_1 = require_Wallet();
    var bn_js_1 = require_bn();
    var __1 = require_dist2();
    var ConfigContract_1 = require_ConfigContract();
    var TonCache_1 = require_TonCache();
    function convertMessage(t) {
      return {
        source: t.source !== "" ? Address_1.Address.parseFriendly(t.source).address : null,
        destination: t.destination !== "" ? Address_1.Address.parseFriendly(t.destination).address : null,
        forwardFee: new bn_js_1.BN(t.fwd_fee),
        ihrFee: new bn_js_1.BN(t.ihr_fee),
        value: new bn_js_1.BN(t.value),
        createdLt: t.created_lt,
        body: t.msg_data["@type"] === "msg.dataRaw" ? { type: "data", data: Buffer.from(t.msg_data.body, "base64") } : t.msg_data["@type"] === "msg.dataText" ? { type: "text", text: Buffer.from(t.msg_data.text, "base64").toString("utf-8") } : null
      };
    }
    function convertTransaction(r) {
      return {
        id: { lt: r.transaction_id.lt, hash: r.transaction_id.hash },
        time: r.utime,
        data: r.data,
        storageFee: new bn_js_1.BN(r.storage_fee),
        otherFee: new bn_js_1.BN(r.other_fee),
        fee: new bn_js_1.BN(r.fee),
        inMessage: r.in_msg ? convertMessage(r.in_msg) : null,
        outMessages: r.out_msgs.map(convertMessage)
      };
    }
    var TonClient = class {
      constructor(parameters) {
        _TonClient_api.set(this, void 0);
        this.services = {
          configs: new ConfigContract_1.ConfigContract(this)
        };
        this.parameters = {
          endpoint: parameters.endpoint,
          cache: parameters.cache ? parameters.cache : new TonCache_1.InMemoryCache()
        };
        __classPrivateFieldSet(this, _TonClient_api, new HttpApi_1.HttpApi(this.parameters.endpoint, this.parameters.cache, {
          timeout: parameters.timeout,
          apiKey: parameters.apiKey,
          adapter: parameters.httpAdapter
        }), "f");
      }
      async getBalance(address) {
        return (await this.getContractState(address)).balance;
      }
      async callGetMethod(address, name, params = []) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, params);
        if (res.exit_code !== 0) {
          throw Error("Unable to execute get method. Got exit_code: " + res.exit_code);
        }
        return { gas_used: res.gas_used, stack: res.stack };
      }
      async callGetMethodWithError(address, name, params = []) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, params);
        return { gas_used: res.gas_used, stack: res.stack, exit_code: res.exit_code };
      }
      async getTransactions(address, opts) {
        let tx = await __classPrivateFieldGet(this, _TonClient_api, "f").getTransactions(address, opts);
        let res = [];
        for (let r of tx) {
          res.push(convertTransaction(r));
        }
        return res;
      }
      async getTransaction(address, lt, hash) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").getTransaction(address, lt, hash);
        if (res) {
          return convertTransaction(res);
        } else {
          return null;
        }
      }
      async getMasterchainInfo() {
        let r = await __classPrivateFieldGet(this, _TonClient_api, "f").getMasterchainInfo();
        return {
          workchain: r.init.workchain,
          shard: r.last.shard,
          initSeqno: r.init.seqno,
          latestSeqno: r.last.seqno
        };
      }
      async getWorkchainShards(seqno) {
        let r = await __classPrivateFieldGet(this, _TonClient_api, "f").getShards(seqno);
        return r.map((m) => ({
          workchain: m.workchain,
          shard: m.shard,
          seqno: m.seqno
        }));
      }
      async getShardTransactions(workchain, seqno, shard) {
        let tx = await __classPrivateFieldGet(this, _TonClient_api, "f").getBlockTransactions(workchain, seqno, shard);
        if (tx.incomplete) {
          throw Error("Unsupported");
        }
        return tx.transactions.map((v) => ({
          account: Address_1.Address.parseRaw(v.account),
          lt: v.lt,
          hash: v.hash
        }));
      }
      async sendMessage(src) {
        const cell = new Cell_1.Cell();
        src.writeTo(cell);
        const boc = await cell.toBoc({ idx: false });
        await __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(boc);
      }
      async sendFile(src) {
        await __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(src);
      }
      async estimateExternalMessageFee(address, args) {
        return await __classPrivateFieldGet(this, _TonClient_api, "f").estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
      }
      async sendExternalMessage(contract, src) {
        if (await this.isContractDeployed(contract.address)) {
          const message = new ExternalMessage_1.ExternalMessage({
            to: contract.address,
            body: new CommonMessageInfo_1.CommonMessageInfo({
              body: new __1.CellMessage(src)
            })
          });
          await this.sendMessage(message);
        } else {
          const message = new ExternalMessage_1.ExternalMessage({
            to: contract.address,
            body: new CommonMessageInfo_1.CommonMessageInfo({
              stateInit: new StateInit_1.StateInit({ code: contract.source.initialCode, data: contract.source.initialData }),
              body: new __1.CellMessage(src)
            })
          });
          await this.sendMessage(message);
        }
      }
      async isContractDeployed(address) {
        return (await this.getContractState(address)).state === "active";
      }
      async getContractState(address) {
        let info = await __classPrivateFieldGet(this, _TonClient_api, "f").getAddressInformation(address);
        let balance = new bn_js_1.BN(info.balance);
        let state = info.state;
        return {
          balance,
          state,
          code: info.code !== "" ? Buffer.from(info.code, "base64") : null,
          data: info.data !== "" ? Buffer.from(info.data, "base64") : null,
          lastTransaction: info.last_transaction_id.lt !== "0" ? {
            lt: info.last_transaction_id.lt,
            hash: info.last_transaction_id.hash
          } : null,
          blockId: {
            workchain: info.block_id.workchain,
            shard: info.block_id.shard,
            seqno: info.block_id.seqno
          },
          timestampt: info.sync_utime
        };
      }
      openWalletFromAddress(args) {
        return Wallet_1.Wallet.open(this, args.source);
      }
      findWalletFromSecretKey(args) {
        return Wallet_1.Wallet.findBestBySecretKey(this, args.workchain, args.secretKey);
      }
      openWalletDefaultFromSecretKey(args) {
        return Wallet_1.Wallet.openDefault(this, args.workchain, args.secretKey);
      }
      openWalletFromSecretKey(args) {
        return Wallet_1.Wallet.openByType(this, args.workchain, args.secretKey, args.type);
      }
      openWalletFromCustomContract(src) {
        return Wallet_1.Wallet.openFromSource(this, src);
      }
      async createNewWallet(args) {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24, args.password);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic, args.password);
        let kind = args.type || "org.ton.wallets.v3";
        let wallet = Wallet_1.Wallet.openByType(this, args.workchain, key.secretKey, kind);
        return {
          mnemonic,
          key,
          wallet
        };
      }
    };
    exports.TonClient = TonClient;
    _TonClient_api = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number2, base, endian) {
        if (BN.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max5(left4, right4) {
        if (left4.cmp(right4) > 0)
          return left4;
        return right4;
      };
      BN.min = function min5(left4, right4) {
        if (left4.cmp(right4) < 0)
          return left4;
        return right4;
      };
      BN.prototype._init = function init4(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number2, start);
        } else {
          this._parseBase(number2, base, start);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number2, base, endian) {
        assert(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
            w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number2.length; i += 3) {
            w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number2, start) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number2.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number2, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number2, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i, number2.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size4) {
        while (this.length < size4) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType2(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right4 = (num.words[i] | 0) * mul;
          w -= right4 & 67108863;
          carry = (w >> 26) - (right4 / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/number-to-bn/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/number-to-bn/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number2, base, endian) {
        if (BN.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max5(left4, right4) {
        if (left4.cmp(right4) > 0)
          return left4;
        return right4;
      };
      BN.min = function min5(left4, right4) {
        if (left4.cmp(right4) < 0)
          return left4;
        return right4;
      };
      BN.prototype._init = function init4(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number2, start);
        } else {
          this._parseBase(number2, base, start);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number2, base, endian) {
        assert(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
            w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number2.length; i += 3) {
            w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number2, start) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number2.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number2, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number2, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number2, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i, number2.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy3(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size4) {
        while (this.length < size4) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray2(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType2, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType2(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right4 = (num.words[i] | 0) * mul;
          w -= right4 & 67108863;
          carry = (w >> 26) - (right4 / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-hex-prefixed/src/index.js
var require_src2 = __commonJS({
  "node_modules/is-hex-prefixed/src/index.js"(exports, module) {
    module.exports = function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
      }
      return str.slice(0, 2) === "0x";
    };
  }
});

// node_modules/strip-hex-prefix/src/index.js
var require_src3 = __commonJS({
  "node_modules/strip-hex-prefix/src/index.js"(exports, module) {
    var isHexPrefixed = require_src2();
    module.exports = function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
  }
});

// node_modules/number-to-bn/src/index.js
var require_src4 = __commonJS({
  "node_modules/number-to-bn/src/index.js"(exports, module) {
    var BN = require_bn3();
    var stripHexPrefix = require_src3();
    module.exports = function numberToBN(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        var multiplier = new BN(1);
        var formattedString = String(arg).toLowerCase().trim();
        var isHexPrefixed = formattedString.substr(0, 2) === "0x" || formattedString.substr(0, 3) === "-0x";
        var stringArg = stripHexPrefix(formattedString);
        if (stringArg.substr(0, 1) === "-") {
          stringArg = stripHexPrefix(stringArg.slice(1));
          multiplier = new BN(-1, 10);
        }
        stringArg = stringArg === "" ? "0" : stringArg;
        if (!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/) || stringArg.match(/^[a-fA-F]+$/) || isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/)) {
          return new BN(stringArg, 16).mul(multiplier);
        }
        if ((stringArg.match(/^-?[0-9]+$/) || stringArg === "") && isHexPrefixed === false) {
          return new BN(stringArg, 10).mul(multiplier);
        }
      } else if (typeof arg === "object" && arg.toString && (!arg.pop && !arg.push)) {
        if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) {
          return new BN(arg.toString(10), 10);
        }
      }
      throw new Error("[number-to-bn] while converting number " + JSON.stringify(arg) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.");
    };
  }
});

// node_modules/ethjs-unit/lib/index.js
var require_lib = __commonJS({
  "node_modules/ethjs-unit/lib/index.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var numberToBN = require_src4();
    var zero4 = new BN(0);
    var negative1 = new BN(-1);
    var unitMap = {
      "noether": "0",
      "wei": "1",
      "kwei": "1000",
      "Kwei": "1000",
      "babbage": "1000",
      "femtoether": "1000",
      "mwei": "1000000",
      "Mwei": "1000000",
      "lovelace": "1000000",
      "picoether": "1000000",
      "gwei": "1000000000",
      "Gwei": "1000000000",
      "shannon": "1000000000",
      "nanoether": "1000000000",
      "nano": "1000000000",
      "szabo": "1000000000000",
      "microether": "1000000000000",
      "micro": "1000000000000",
      "finney": "1000000000000000",
      "milliether": "1000000000000000",
      "milli": "1000000000000000",
      "ether": "1000000000000000000",
      "kether": "1000000000000000000000",
      "grand": "1000000000000000000000",
      "mether": "1000000000000000000000000",
      "gether": "1000000000000000000000000000",
      "tether": "1000000000000000000000000000000"
    };
    function getValueOfUnit(unitInput) {
      var unit = unitInput ? unitInput.toLowerCase() : "ether";
      var unitValue = unitMap[unit];
      if (typeof unitValue !== "string") {
        throw new Error("[ethjs-unit] the unit provided " + unitInput + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
      }
      return new BN(unitValue, 10);
    }
    function numberToString(arg) {
      if (typeof arg === "string") {
        if (!arg.match(/^-?[0-9.]+$/)) {
          throw new Error("while converting number to string, invalid number value '" + arg + "', should be a number matching (^-?[0-9.]+).");
        }
        return arg;
      } else if (typeof arg === "number") {
        return String(arg);
      } else if (typeof arg === "object" && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
        if (arg.toPrecision) {
          return String(arg.toPrecision());
        } else {
          return arg.toString(10);
        }
      }
      throw new Error("while converting number to string, invalid number value '" + arg + "' type " + typeof arg + ".");
    }
    function fromWei(weiInput, unit, optionsInput) {
      var wei = numberToBN(weiInput);
      var negative = wei.lt(zero4);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var options = optionsInput || {};
      if (negative) {
        wei = wei.mul(negative1);
      }
      var fraction = wei.mod(base).toString(10);
      while (fraction.length < baseLength) {
        fraction = "0" + fraction;
      }
      if (!options.pad) {
        fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      }
      var whole = wei.div(base).toString(10);
      if (options.commify) {
        whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      var value = "" + whole + (fraction == "0" ? "" : "." + fraction);
      if (negative) {
        value = "-" + value;
      }
      return value;
    }
    function toWei(etherInput, unit) {
      var ether = numberToString(etherInput);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var negative = ether.substring(0, 1) === "-";
      if (negative) {
        ether = ether.substring(1);
      }
      if (ether === ".") {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, invalid value");
      }
      var comps = ether.split(".");
      if (comps.length > 2) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei,  too many decimal points");
      }
      var whole = comps[0], fraction = comps[1];
      if (!whole) {
        whole = "0";
      }
      if (!fraction) {
        fraction = "0";
      }
      if (fraction.length > baseLength) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, too many decimal places");
      }
      while (fraction.length < baseLength) {
        fraction += "0";
      }
      whole = new BN(whole);
      fraction = new BN(fraction);
      var wei = whole.mul(base).add(fraction);
      if (negative) {
        wei = wei.mul(negative1);
      }
      return new BN(wei.toString(10), 10);
    }
    module.exports = {
      unitMap,
      numberToString,
      getValueOfUnit,
      fromWei,
      toWei
    };
  }
});

// node_modules/ton/dist/utils/convert.js
var require_convert = __commonJS({
  "node_modules/ton/dist/utils/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromNano = exports.toNano = void 0;
    var ethUnit = require_lib();
    function toNano(src) {
      return ethUnit.toWei(src, "gwei");
    }
    exports.toNano = toNano;
    function fromNano(src) {
      return ethUnit.fromWei(src, "gwei");
    }
    exports.fromNano = fromNano;
  }
});

// node_modules/ton/dist/keystore/KeyStore.js
var require_KeyStore = __commonJS({
  "node_modules/ton/dist/keystore/KeyStore.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _KeyStore_salt;
    var _KeyStore_publicKey;
    var _KeyStore_records;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyStore = exports.createKeyStoreKey = void 0;
    var ton_crypto_1 = require_dist();
    var t = __importStar((init_es6(), __toCommonJS(es6_exports)));
    var Either_1 = require_Either();
    var __1 = require_dist2();
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    var codec = t.type({
      version: t.number,
      salt: t.string,
      publicKey: t.string,
      records: t.array(t.type({
        name: t.string,
        address: t.string,
        kind: t.string,
        config: t.string,
        publicKey: t.string,
        secretKey: t.string,
        comment: t.string
      }))
    });
    async function createKeyStoreKey(password, salt) {
      let secretKey = await (0, ton_crypto_1.pbkdf2_sha512)(password, salt, 4e5, 32);
      let r = tweetnacl_1.default.box.keyPair.fromSecretKey(secretKey);
      return {
        secretKey: Buffer.from(r.secretKey),
        publicKey: Buffer.from(r.publicKey)
      };
    }
    exports.createKeyStoreKey = createKeyStoreKey;
    var KeyStore = class {
      constructor(src) {
        _KeyStore_salt.set(this, void 0);
        _KeyStore_publicKey.set(this, void 0);
        _KeyStore_records.set(this, /* @__PURE__ */ new Map());
        this.checkPassword = async (password) => {
          let key = await createKeyStoreKey(password, Buffer.from(__classPrivateFieldGet(this, _KeyStore_salt, "f"), "hex"));
          if (!key.publicKey.equals(Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), "hex"))) {
            return false;
          } else {
            return true;
          }
        };
        this.hasKey = (name) => {
          return __classPrivateFieldGet(this, _KeyStore_records, "f").has(name);
        };
        this.getKey = (name) => {
          let ex = __classPrivateFieldGet(this, _KeyStore_records, "f").get(name);
          if (ex) {
            return {
              name: ex.name,
              address: ex.address,
              kind: ex.kind,
              config: ex.config,
              comment: ex.comment,
              publicKey: Buffer.from(ex.publicKey, "hex")
            };
          }
          return null;
        };
        this.getSecret = async (name, password) => {
          if (!__classPrivateFieldGet(this, _KeyStore_records, "f").has(name)) {
            throw Error("Key with name " + name + " does not exist");
          }
          let record3 = __classPrivateFieldGet(this, _KeyStore_records, "f").get(name);
          let src2 = Buffer.from(record3.secretKey, "hex");
          let nonce = src2.slice(0, 24);
          let publicKey = src2.slice(24, 24 + 32);
          let data = src2.slice(24 + 32);
          let key = await createKeyStoreKey(password, Buffer.from(__classPrivateFieldGet(this, _KeyStore_salt, "f"), "hex"));
          if (!key.publicKey.equals(Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), "hex"))) {
            throw Error("Invalid password");
          }
          let decoded = tweetnacl_1.default.box.open(data, nonce, publicKey, key.secretKey);
          if (!decoded) {
            throw Error("Invalid password");
          }
          return Buffer.from(decoded);
        };
        this.addKey = async (record3, key) => {
          if (__classPrivateFieldGet(this, _KeyStore_records, "f").has(record3.name)) {
            throw Error("Key with name " + record3.name + " already exists");
          }
          let ephemeralKeySecret = await (0, ton_crypto_1.getSecureRandomBytes)(32);
          let ephemeralKeyPublic = Buffer.from(tweetnacl_1.default.box.keyPair.fromSecretKey(ephemeralKeySecret).publicKey);
          let nonce = await (0, ton_crypto_1.getSecureRandomBytes)(24);
          let encrypted = tweetnacl_1.default.box(key, nonce, Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), "hex"), ephemeralKeySecret);
          let data = Buffer.concat([nonce, ephemeralKeyPublic, encrypted]);
          let rec = {
            name: record3.name,
            address: record3.address,
            kind: record3.kind,
            config: record3.config,
            comment: record3.comment,
            publicKey: record3.publicKey.toString("hex"),
            secretKey: data.toString("hex")
          };
          Object.freeze(rec);
          __classPrivateFieldGet(this, _KeyStore_records, "f").set(record3.name, rec);
        };
        this.removeKey = (name) => {
          if (!__classPrivateFieldGet(this, _KeyStore_records, "f").has(name)) {
            throw Error("Key with name " + name + " does not exist");
          }
          __classPrivateFieldGet(this, _KeyStore_records, "f").delete(name);
        };
        if (src.version !== 1) {
          throw Error("Unsupported keystore");
        }
        __classPrivateFieldSet(this, _KeyStore_salt, src.salt, "f");
        __classPrivateFieldSet(this, _KeyStore_publicKey, src.publicKey, "f");
        for (let r of src.records) {
          if (__classPrivateFieldGet(this, _KeyStore_records, "f").has(r.name)) {
            throw Error("Broken keystore");
          }
          const record3 = {
            name: r.name,
            address: __1.Address.parseRaw(r.address),
            kind: r.kind,
            config: r.config,
            comment: r.comment,
            publicKey: r.publicKey,
            secretKey: r.secretKey
          };
          Object.freeze(record3);
          __classPrivateFieldGet(this, _KeyStore_records, "f").set(r.name, record3);
        }
      }
      static async createNew(password) {
        let salt = await (0, ton_crypto_1.getSecureRandomBytes)(32);
        let key = await createKeyStoreKey(password, salt);
        return new KeyStore({ version: 1, salt: salt.toString("hex"), publicKey: key.publicKey.toString("hex"), records: [] });
      }
      static async load(source) {
        if (source.length < 32) {
          throw Error("Broken keystore");
        }
        let hash = source.slice(0, 32);
        let data = source.slice(32);
        let hash2 = await (0, ton_crypto_1.sha256)(data);
        if (!hash.equals(hash2)) {
          throw Error("Broken keystore");
        }
        let parsed = JSON.parse(data.toString("utf-8"));
        let decoded = codec.decode(parsed);
        if ((0, Either_1.isLeft)(decoded)) {
          throw Error("Broken keystore");
        }
        return new KeyStore(decoded.right);
      }
      get allKeys() {
        let res = [];
        for (let k of __classPrivateFieldGet(this, _KeyStore_records, "f").keys()) {
          let r = __classPrivateFieldGet(this, _KeyStore_records, "f").get(k);
          res.push({
            name: r.name,
            address: r.address,
            kind: r.kind,
            config: r.config,
            comment: r.comment,
            publicKey: Buffer.from(r.publicKey, "hex")
          });
        }
        return res;
      }
      async save() {
        let store = {
          version: 1,
          salt: __classPrivateFieldGet(this, _KeyStore_salt, "f"),
          publicKey: __classPrivateFieldGet(this, _KeyStore_publicKey, "f"),
          records: Array.from(__classPrivateFieldGet(this, _KeyStore_records, "f").entries()).map((v) => ({
            name: v[1].name,
            address: v[1].address.toString(),
            kind: v[1].kind,
            config: v[1].config,
            comment: v[1].comment,
            publicKey: v[1].publicKey,
            secretKey: v[1].secretKey
          }))
        };
        let data = Buffer.from(JSON.stringify(store), "utf-8");
        let hash = await (0, ton_crypto_1.sha256)(data);
        return Buffer.concat([hash, data]);
      }
    };
    exports.KeyStore = KeyStore;
    _KeyStore_salt = /* @__PURE__ */ new WeakMap(), _KeyStore_publicKey = /* @__PURE__ */ new WeakMap(), _KeyStore_records = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/ton/dist/boc/Slice.js
var require_Slice = __commonJS({
  "node_modules/ton/dist/boc/Slice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Slice = void 0;
    var __1 = require_dist2();
    var Slice = class {
      constructor(sourceBits, sourceRefs) {
        this.refs = [];
        this.skip = (bits) => {
          this.bits.skip(bits);
        };
        this.readUint = (bits) => {
          return this.bits.readUint(bits);
        };
        this.readUintNumber = (bits) => {
          return this.bits.readUintNumber(bits);
        };
        this.readInt = (bits) => {
          return this.bits.readInt(bits);
        };
        this.readIntNumber = (bits) => {
          return this.bits.readIntNumber(bits);
        };
        this.readBuffer = (size4) => {
          return this.bits.readBuffer(size4);
        };
        this.readBit = () => {
          return this.bits.readBit();
        };
        this.readCoins = () => {
          return this.bits.readCoins();
        };
        this.readVarUInt = (headerBits) => {
          return this.bits.readVarUInt(headerBits);
        };
        this.readVarUIntNumber = (headerBits) => {
          return this.bits.readVarUIntNumber(headerBits);
        };
        this.readRemaining = () => {
          return this.bits.readRemaining();
        };
        this.readRemainingBytes = () => {
          if (this.bits.remaining % 8 !== 0) {
            throw Error("Number remaining of bits is not multiply of 8");
          }
          return this.bits.readBuffer(this.bits.remaining / 8);
        };
        this.readAddress = () => {
          return this.bits.readAddress();
        };
        this.readAddressInternal = () => {
          return this.bits.readAddressInternal();
        };
        this.readAddressExternal = () => {
          return this.bits.readAddressExternal();
        };
        this.readUnaryLength = () => {
          return this.bits.readUnaryLength();
        };
        this.readBitString = (n) => {
          return this.bits.readBitString(n);
        };
        this.readOptDict = (keySize, extractor) => {
          if (this.readBit()) {
            return this.readDict(keySize, extractor);
          } else {
            return null;
          }
        };
        this.readDict = (keySize, extractor) => {
          let first2 = this.refs.shift();
          if (first2) {
            return (0, __1.parseDict)(first2.beginParse(), keySize, extractor);
          } else {
            throw Error("No ref");
          }
        };
        this.readRef = () => {
          let first2 = this.refs.shift();
          if (first2) {
            return Slice.fromCell(first2);
          } else {
            throw Error("No ref");
          }
        };
        this.readCell = () => {
          let first2 = this.refs.shift();
          if (first2) {
            return first2;
          } else {
            throw Error("No ref");
          }
        };
        this.preloadCell = () => {
          let first2 = this.refs[0];
          if (first2) {
            return first2;
          } else {
            throw Error("No ref");
          }
        };
        this.clone = () => {
          const cloned = this.sourceBits.clone();
          const reader = new __1.BitStringReader(cloned);
          reader.skip(this.bits.currentOffset);
          const remaining = reader.readRemaining();
          const remainingRefs = [...this.refs];
          return new Slice(remaining, remainingRefs);
        };
        this.toCell = () => {
          const cloned = this.sourceBits.clone();
          const reader = new __1.BitStringReader(cloned);
          reader.skip(this.bits.currentOffset);
          const remaining = reader.readRemaining();
          let cell = new __1.Cell("ordinary", remaining);
          for (let r of this.refs) {
            cell.refs.push(r);
          }
          return cell;
        };
        this.sourceBits = sourceBits.clone();
        this.refs = [...sourceRefs];
        this.bits = new __1.BitStringReader(this.sourceBits);
      }
      static fromCell(cell) {
        if (cell.isExotic) {
          throw Error("Unable to create slice from exotic");
        }
        return new Slice(cell.bits, cell.refs);
      }
      get remaining() {
        return this.bits.remaining;
      }
      get remainingRefs() {
        return this.refs.length;
      }
    };
    exports.Slice = Slice;
  }
});

// node_modules/ton/dist/utils/base32.js
var require_base32 = __commonJS({
  "node_modules/ton/dist/utils/base32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base32Decode = exports.base32Encode = void 0;
    var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
    function base32Encode(buffer) {
      const length = buffer.byteLength;
      let bits = 0;
      let value = 0;
      let output = "";
      for (let i = 0; i < length; i++) {
        value = value << 8 | buffer[i];
        bits += 8;
        while (bits >= 5) {
          output += alphabet[value >>> bits - 5 & 31];
          bits -= 5;
        }
      }
      if (bits > 0) {
        output += alphabet[value << 5 - bits & 31];
      }
      return output;
    }
    exports.base32Encode = base32Encode;
    function readChar(alphabet2, char) {
      const idx = alphabet2.indexOf(char);
      if (idx === -1) {
        throw new Error("Invalid character found: " + char);
      }
      return idx;
    }
    function base32Decode(input) {
      let cleanedInput;
      cleanedInput = input.toLowerCase();
      const { length } = cleanedInput;
      let bits = 0;
      let value = 0;
      let index = 0;
      const output = Buffer.alloc(length * 5 / 8 | 0);
      for (let i = 0; i < length; i++) {
        value = value << 5 | readChar(alphabet, cleanedInput[i]);
        bits += 5;
        if (bits >= 8) {
          output[index++] = value >>> bits - 8 & 255;
          bits -= 8;
        }
      }
      return output;
    }
    exports.base32Decode = base32Decode;
  }
});

// node_modules/ton/dist/address/ADNLAddress.js
var require_ADNLAddress = __commonJS({
  "node_modules/ton/dist/address/ADNLAddress.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ADNLAddress = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var base32_1 = require_base32();
    var crc16_1 = require_crc16();
    var ADNLAddress = class {
      constructor(address) {
        this.toString = () => {
          return this.toFriendly();
        };
        this.toRaw = () => {
          return this.address.toString("hex").toUpperCase();
        };
        this.toFriendly = () => {
          let data = Buffer.concat([Buffer.from([45]), this.address]);
          let hash = (0, crc16_1.crc16)(data);
          data = Buffer.concat([data, hash]);
          return (0, base32_1.base32Encode)(data).slice(1);
        };
        this[_a] = () => this.toFriendly();
        if (address.length !== 32) {
          throw Error("Invalid address");
        }
        this.address = address;
      }
      static parseFriendly(src) {
        if (src.length !== 55) {
          throw Error("Invalid address");
        }
        src = "f" + src;
        let decoded = (0, base32_1.base32Decode)(src);
        if (decoded[0] !== 45) {
          throw Error("Invalid address");
        }
        let gotHash = decoded.slice(33);
        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
        if (!hash.equals(gotHash)) {
          throw Error("Invalid address");
        }
        return new ADNLAddress(decoded.slice(1, 33));
      }
      static parseRaw(src) {
        const data = Buffer.from(src, "base64");
        return new ADNLAddress(data);
      }
      equals(b) {
        return this.address.equals(b.address);
      }
    };
    exports.ADNLAddress = ADNLAddress;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/ton/dist/keystore/ADNLKey.js
var require_ADNLKey = __commonJS({
  "node_modules/ton/dist/keystore/ADNLKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ADNLKey = void 0;
    var ton_crypto_1 = require_dist();
    var ADNLAddress_1 = require_ADNLAddress();
    var KEY_PREFIX = Buffer.from("17236849", "hex");
    var ADNLKey = class {
      constructor(address, keyPair) {
        this.address = address;
        this.keyPair = keyPair;
      }
      static async fromKey(src) {
        if (src.length !== 36) {
          throw Error("Invalid key");
        }
        if (!src.slice(0, 4).equals(KEY_PREFIX)) {
          throw Error("Invalid key");
        }
        const keySeed = src.slice(4);
        const keyPair = (0, ton_crypto_1.keyPairFromSeed)(keySeed);
        const address = await (0, ton_crypto_1.sha256)(Buffer.concat([Buffer.from([198, 180, 19, 72]), keyPair.publicKey]));
        return new ADNLKey(new ADNLAddress_1.ADNLAddress(address), keyPair);
      }
    };
    exports.ADNLKey = ADNLKey;
  }
});

// node_modules/ton/dist/boc/dict/utils/findCommonPrefix.js
var require_findCommonPrefix = __commonJS({
  "node_modules/ton/dist/boc/dict/utils/findCommonPrefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findCommonPrefix = void 0;
    function findCommonPrefix(src) {
      if (src.length === 0) {
        return "";
      }
      if (src.length === 1) {
        return src[0];
      }
      const sorted = [...src].sort();
      let size4 = 0;
      for (let i = 0; i < sorted[0].length; i++) {
        if (sorted[0][i] !== sorted[sorted.length - 1][i]) {
          break;
        }
        size4++;
      }
      return src[0].slice(0, size4);
    }
    exports.findCommonPrefix = findCommonPrefix;
  }
});

// node_modules/ton/dist/boc/dict/serializeDict.js
var require_serializeDict = __commonJS({
  "node_modules/ton/dist/boc/dict/serializeDict.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;
    var bn_js_1 = require_bn();
    var Cell_1 = require_Cell();
    var findCommonPrefix_1 = require_findCommonPrefix();
    function pad(src, size4) {
      while (src.length < size4) {
        src = "0" + src;
      }
      return src;
    }
    function removePrefixMap(src, length) {
      if (length === 0) {
        return src;
      } else {
        let res = /* @__PURE__ */ new Map();
        for (let k of src.keys()) {
          let d = src.get(k);
          res.set(k.slice(length), d);
        }
        return res;
      }
    }
    function forkMap(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      let left4 = /* @__PURE__ */ new Map();
      let right4 = /* @__PURE__ */ new Map();
      for (let k of src.keys()) {
        let d = src.get(k);
        if (k.startsWith("0")) {
          left4.set(k.substr(1), d);
        } else {
          right4.set(k.substr(1), d);
        }
      }
      if (left4.size === 0) {
        throw Error("Internal inconsistency. Left emtpy.");
      }
      if (right4.size === 0) {
        throw Error("Internal inconsistency. Right emtpy.");
      }
      return { left: left4, right: right4 };
    }
    function buildNode(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      if (src.size === 1) {
        return { type: "leaf", value: Array.from(src.values())[0] };
      }
      let { left: left4, right: right4 } = forkMap(src);
      return {
        type: "fork",
        left: buildEdge(left4),
        right: buildEdge(right4)
      };
    }
    function buildEdge(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()));
      return { label, node: buildNode(removePrefixMap(src, label.length)) };
    }
    function buildTree(src, keyLength) {
      let converted = /* @__PURE__ */ new Map();
      for (let k of Array.from(src.keys())) {
        const padded = pad(new bn_js_1.BN(k).toString(2), keyLength);
        converted.set(padded, src.get(k));
      }
      return buildEdge(converted);
    }
    exports.buildTree = buildTree;
    function writeLabelShort(src, to) {
      to.writeBit(0);
      for (let i = 0; i < src.length; i++) {
        to.writeBit(1);
      }
      to.writeBit(0);
      for (let i = 0; i < src.length; i++) {
        to.writeBit(src[i] === "1");
      }
      return to;
    }
    exports.writeLabelShort = writeLabelShort;
    function labelShortLength(src) {
      return 1 + src.length + 1 + src.length;
    }
    function writeLabelLong(src, keyLength, to) {
      to.writeBit(1);
      to.writeBit(0);
      let length = Math.ceil(Math.log2(keyLength + 1));
      to.writeUint(src.length, length);
      for (let i = 0; i < src.length; i++) {
        to.writeBit(src[i] === "1");
      }
      return to;
    }
    exports.writeLabelLong = writeLabelLong;
    function labelLongLength(src, keyLength) {
      return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
    }
    function writeLabelSame(value, length, keyLength, to) {
      to.writeBit(1);
      to.writeBit(1);
      to.writeBit(value);
      let lenLen = Math.ceil(Math.log2(keyLength + 1));
      to.writeUint(length, lenLen);
    }
    exports.writeLabelSame = writeLabelSame;
    function labelSameLength(keyLength) {
      return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
    }
    function isSame(src) {
      if (src.length === 0 || src.length === 1) {
        return true;
      }
      for (let i = 1; i < src.length; i++) {
        if (src[i] !== src[0]) {
          return false;
        }
      }
      return true;
    }
    function detectLabelType(src, keyLength) {
      let kind = "short";
      let kindLength = labelShortLength(src);
      let longLength = labelLongLength(src, keyLength);
      if (longLength < kindLength) {
        kindLength = longLength;
        kind = "long";
      }
      if (isSame(src)) {
        let sameLength = labelSameLength(keyLength);
        if (sameLength < kindLength) {
          kindLength = sameLength;
          kind = "same";
        }
      }
      return kind;
    }
    exports.detectLabelType = detectLabelType;
    function writeLabel(src, keyLength, to) {
      let type2 = detectLabelType(src, keyLength);
      if (type2 === "short") {
        writeLabelShort(src, to);
      }
      if (type2 === "long") {
        writeLabelLong(src, keyLength, to);
      }
      if (type2 === "same") {
        writeLabelSame(src[0] === "1", src.length, keyLength, to);
      }
    }
    function writeNode(src, keyLength, serializer, to) {
      if (src.type === "leaf") {
        serializer(src.value, to);
      }
      if (src.type === "fork") {
        const leftCell = new Cell_1.Cell();
        const rightCell = new Cell_1.Cell();
        writeEdge(src.left, keyLength - 1, serializer, leftCell);
        writeEdge(src.right, keyLength - 1, serializer, rightCell);
        to.refs.push(leftCell);
        to.refs.push(rightCell);
      }
    }
    function writeEdge(src, keyLength, serializer, to) {
      writeLabel(src.label, keyLength, to.bits);
      writeNode(src.node, keyLength - src.label.length, serializer, to);
    }
    function serializeDict(src, keyLength, serializer) {
      const tree = buildTree(src, keyLength);
      const dest = new Cell_1.Cell();
      writeEdge(tree, keyLength, serializer, dest);
      return dest;
    }
    exports.serializeDict = serializeDict;
  }
});

// node_modules/ton/dist/boc/DictBuilder.js
var require_DictBuilder = __commonJS({
  "node_modules/ton/dist/boc/DictBuilder.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.beginDict = exports.DictBuilder = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var Builder_1 = require_Builder();
    var serializeDict_1 = require_serializeDict();
    var DictBuilder = class {
      constructor(keySize) {
        this.items = /* @__PURE__ */ new Map();
        this.ended = false;
        this.storeCell = (index, value) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          let key;
          if (typeof index === "number") {
            key = index.toString(10);
          } else if (bn_js_1.default.isBN(index)) {
            key = index.toString(10);
          } else if (Buffer.isBuffer(index)) {
            key = new bn_js_1.default(index.toString("hex"), "hex").toString(10);
          } else {
            throw Error("Invalid index type");
          }
          if (this.items.has(key)) {
            throw Error("Item " + index + " already exist");
          }
          this.items.set(key, value);
        };
        this.storeRef = (index, value) => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.storeCell(index, (0, Builder_1.beginCell)().storeRef(value).endCell());
        };
        this.endDict = () => {
          if (this.ended) {
            throw Error("Already ended");
          }
          this.ended = true;
          if (this.items.size === 0) {
            return null;
          }
          return (0, serializeDict_1.serializeDict)(this.items, this.keySize, (src, dst) => dst.writeCell(src));
        };
        this.endCell = () => {
          if (this.ended) {
            throw Error("Already ended");
          }
          if (this.items.size === 0) {
            throw Error("Dict is empty");
          }
          return this.endDict();
        };
        this.keySize = keySize;
      }
    };
    exports.DictBuilder = DictBuilder;
    function beginDict(keyLength) {
      return new DictBuilder(keyLength);
    }
    exports.beginDict = beginDict;
  }
});

// node_modules/ton/dist/utils/bnToAddress.js
var require_bnToAddress = __commonJS({
  "node_modules/ton/dist/utils/bnToAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bnToAddress = void 0;
    var Address_1 = require_Address();
    function bnToAddress(chain7, bn) {
      let r = bn.toString("hex");
      while (r.length < 64) {
        r = "0" + r;
      }
      return new Address_1.Address(chain7, Buffer.from(r, "hex"));
    }
    exports.bnToAddress = bnToAddress;
  }
});

// node_modules/ton/dist/boc/TupleSlice.js
var require_TupleSlice = __commonJS({
  "node_modules/ton/dist/boc/TupleSlice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleSlice = void 0;
    var bn_js_1 = require_bn();
    var bnToAddress_1 = require_bnToAddress();
    var Cell_1 = require_Cell();
    var TupleSlice = class {
      constructor(items) {
        this.items = [...items];
      }
      get remaining() {
        return this.items.length;
      }
      readNumber() {
        if (this.items[0][0] !== "num") {
          throw Error("Not a number");
        }
        let res = parseInt(this.items[0][1]);
        this.items.splice(0, 1);
        return res;
      }
      readBoolean() {
        if (this.items[0][0] !== "num") {
          throw Error("Not a number");
        }
        let res = parseInt(this.items[0][1]);
        this.items.splice(0, 1);
        return res === 0 ? false : true;
      }
      readBigNumber() {
        if (this.items[0][0] !== "num") {
          throw Error("Not a number");
        }
        let res = new bn_js_1.BN(this.items[0][1].slice(2), "hex");
        this.items.splice(0, 1);
        return res;
      }
      readCell() {
        if (this.items[0][0] !== "cell") {
          throw Error("Not a cell");
        }
        let res = Cell_1.Cell.fromBoc(Buffer.from(this.items[0][1].bytes, "base64"))[0];
        this.items.splice(0, 1);
        return res;
      }
      readNumericAddress(chain7) {
        if (this.items[0][0] !== "num") {
          throw Error("Not a number");
        }
        let bn = this.readBigNumber();
        return (0, bnToAddress_1.bnToAddress)(chain7, bn);
      }
    };
    exports.TupleSlice = TupleSlice;
  }
});

// node_modules/ton/dist/boc/TupleSlice4.js
var require_TupleSlice4 = __commonJS({
  "node_modules/ton/dist/boc/TupleSlice4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleSlice4 = void 0;
    var TupleSlice4 = class {
      constructor(items) {
        this.items = [...items];
      }
      get remaining() {
        return this.items.length;
      }
      pop() {
        if (this.items.length === 0) {
          throw Error("EOF");
        }
        let res = this.items[0];
        this.items.splice(0, 1);
        return res;
      }
      readBigNumber() {
        let popped = this.pop();
        if (popped.type !== "int") {
          throw Error("Not a number");
        }
        return popped.value;
      }
      readNumber() {
        return this.readBigNumber().toNumber();
      }
      readBoolean() {
        let res = this.readNumber();
        return res === 0 ? false : true;
      }
      readAddress() {
        return this.readCell().beginParse().readAddress();
      }
      readCell() {
        let popped = this.pop();
        if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
          throw Error("Not a cell");
        }
        return popped.cell;
      }
      readTuple() {
        let popped = this.pop();
        if (popped.type !== "tuple") {
          throw Error("Not a number");
        }
        return new TupleSlice4(popped.items);
      }
    };
    exports.TupleSlice4 = TupleSlice4;
  }
});

// node_modules/ton/dist/introspection/getSupportedInterfaces.js
var require_getSupportedInterfaces = __commonJS({
  "node_modules/ton/dist/introspection/getSupportedInterfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSupportedInterfaces = exports.getSupportedInterfacesRaw = exports.resolveKnownInterface = void 0;
    var TupleSlice_1 = require_TupleSlice();
    var known = {
      ["123515602279859691144772641439386770278"]: "org.ton.introspection.v0",
      ["256184278959413194623484780286929323492"]: "com.tonwhales.nominators:v0",
      ["242422353946785872806511191513850808027"]: "org.ton.jetton.master.v1",
      ["311736387032003861293477945447179662681"]: "org.ton.jetton.wallet.v1"
    };
    function resolveKnownInterface(src) {
      let kn = known[src];
      if (kn) {
        return kn;
      } else {
        return null;
      }
    }
    exports.resolveKnownInterface = resolveKnownInterface;
    async function getSupportedInterfacesRaw(src, client) {
      let res = await client.callGetMethodWithError(src, "supported_interfaces");
      if (res.exit_code !== 0 && res.exit_code !== 1) {
        return [];
      }
      try {
        let slice = new TupleSlice_1.TupleSlice(res.stack);
        let firstNumber = slice.readBigNumber().toString();
        if (firstNumber !== "123515602279859691144772641439386770278") {
          return [];
        }
        let interfaces = [];
        while (slice.remaining > 0) {
          interfaces.push(slice.readBigNumber().toString());
        }
        return interfaces;
      } catch (e) {
        console.warn(e);
        return [];
      }
    }
    exports.getSupportedInterfacesRaw = getSupportedInterfacesRaw;
    async function getSupportedInterfaces(src, client) {
      let supprotedRaw = await getSupportedInterfacesRaw(src, client);
      return supprotedRaw.map((v) => {
        let k = resolveKnownInterface(v);
        if (k) {
          return { type: "known", name: k };
        } else {
          return { type: "unknown", value: v };
        }
      });
    }
    exports.getSupportedInterfaces = getSupportedInterfaces;
  }
});

// node_modules/ton/dist/utils/crc32.js
var require_crc32 = __commonJS({
  "node_modules/ton/dist/utils/crc32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc32str = exports.crc32 = void 0;
    var POLYNOMIAL = -306674912;
    var crc32_table = void 0;
    function calcTable() {
      crc32_table = new Int32Array(256);
      for (let i = 0; i < 256; i++) {
        let r = i;
        for (let bit = 8; bit > 0; --bit)
          r = r & 1 ? r >>> 1 ^ POLYNOMIAL : r >>> 1;
        crc32_table[i] = r;
      }
    }
    function crc32(bytes) {
      let crc = 4294967295;
      if (crc32_table === void 0) {
        calcTable();
      }
      for (let i = 0; i < bytes.length; ++i)
        crc = crc32_table[(crc ^ bytes[i]) & 255] ^ crc >>> 8;
      return (crc ^ -1) >>> 0;
    }
    exports.crc32 = crc32;
    function crc32str(src) {
      return crc32(Buffer.from(src));
    }
    exports.crc32str = crc32str;
  }
});

// node_modules/ton/dist/introspection/parseSupportedMessage.js
var require_parseSupportedMessage = __commonJS({
  "node_modules/ton/dist/introspection/parseSupportedMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSupportedMessage = void 0;
    var crc32_1 = require_crc32();
    function parseNominatorsMessage(op, sc) {
      if (op === (0, crc32_1.crc32str)("op::stake_deposit")) {
        let queryId = sc.readUint(64);
        let gasLimit = sc.readCoins().toNumber();
        return {
          type: "deposit",
          data: {
            "query_id": queryId,
            "gas_limit": gasLimit
          }
        };
      }
      if (op === (0, crc32_1.crc32str)("op::stake_deposit::response")) {
        return {
          type: "deposit::ok",
          data: {}
        };
      }
      if (op === (0, crc32_1.crc32str)("op::stake_withdraw")) {
        let queryId = sc.readUint(64);
        let gasLimit = sc.readCoins().toNumber();
        const stake = sc.readCoins();
        return {
          type: "withdraw",
          data: {
            "stake": stake,
            "query_id": queryId,
            "gas_limit": gasLimit
          }
        };
      }
      if (op === (0, crc32_1.crc32str)("op::stake_withdraw::delayed")) {
        return {
          type: "withdraw::delayed",
          data: {}
        };
      }
      if (op === (0, crc32_1.crc32str)("op::stake_withdraw::response")) {
        return {
          type: "withdraw::ok",
          data: {}
        };
      }
      if (op === (0, crc32_1.crc32str)("op::upgrade")) {
        let queryId = sc.readUint(64);
        let gasLimit = sc.readCoins().toNumber();
        const code = sc.readCell();
        return {
          type: "upgrade",
          data: {
            "code": code,
            "query_id": queryId,
            "gas_limit": gasLimit
          }
        };
      }
      if (op === (0, crc32_1.crc32str)("op::upgrade::response")) {
        return {
          type: "upgrade::ok",
          data: {}
        };
      }
      if (op === (0, crc32_1.crc32str)("op::upgrade")) {
        let queryId = sc.readUint(64);
        let gasLimit = sc.readCoins().toNumber();
        const code = sc.readCell();
        return {
          type: "upgrade",
          data: {
            "code": code,
            "query_id": queryId,
            "gas_limit": gasLimit
          }
        };
      }
      if (op === (0, crc32_1.crc32str)("op::upgrade::ok")) {
        return {
          type: "upgrade::ok",
          data: {}
        };
      }
      if (op === (0, crc32_1.crc32str)("op::update")) {
        let queryId = sc.readUint(64);
        let gasLimit = sc.readCoins().toNumber();
        const params = sc.readCell();
        return {
          type: "update",
          data: {
            "code": params,
            "query_id": queryId,
            "gas_limit": gasLimit
          }
        };
      }
      if (op === (0, crc32_1.crc32str)("op::update::ok")) {
        return {
          type: "update::ok",
          data: {}
        };
      }
      return null;
    }
    function parseJettonWallet(op, sc) {
      if (op === 3576854235) {
        let queryId = sc.readUint(64);
        return {
          type: "jetton::excesses",
          data: {
            "query_id": queryId
          }
        };
      }
      if (op === 260734629) {
        let queryId = sc.readUint(64);
        let amount = sc.readCoins();
        let destination = sc.readAddress();
        let responseDestination = sc.readAddress();
        let customPayload = sc.readBit() ? sc.readCell() : null;
        let forwardTonAmount = sc.readCoins();
        let forwardPayload = sc.readBit() ? sc.readCell() : sc.toCell();
        return {
          type: "jetton::transfer",
          data: {
            "query_id": queryId,
            "amount": amount,
            "destination": destination,
            "response_destination": responseDestination,
            "custom_payload": customPayload,
            "forward_ton": forwardTonAmount,
            "payload": forwardPayload
          }
        };
      }
      if (op === 1935855772) {
        let queryId = sc.readUint(64);
        let amount = sc.readCoins();
        let sender = sc.readAddress();
        let forwardPayload = sc.readBit() ? sc.readCell() : sc.toCell();
        return {
          type: "jetton::transfer_notification",
          data: {
            "query_id": queryId,
            "amount": amount,
            "sender": sender,
            "payload": forwardPayload
          }
        };
      }
      return null;
    }
    function parseJettonMaster(op, sc) {
      return null;
    }
    function parseSupportedMessage(knownInteface, message) {
      try {
        let sc = message.beginParse();
        if (sc.remaining < 32) {
          return null;
        }
        let op = sc.readUintNumber(32);
        if (op === 0) {
          return null;
        }
        if (knownInteface === "com.tonwhales.nominators:v0") {
          return parseNominatorsMessage(op, sc);
        }
        if (knownInteface === "org.ton.jetton.wallet.v1") {
          return parseJettonWallet(op, sc);
        }
        if (knownInteface === "org.ton.jetton.master.v1") {
          return parseJettonMaster(op, sc);
        }
      } catch (e) {
        console.warn(e);
      }
      return null;
    }
    exports.parseSupportedMessage = parseSupportedMessage;
  }
});

// node_modules/ton/dist/messages/CellMessage.js
var require_CellMessage = __commonJS({
  "node_modules/ton/dist/messages/CellMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CellMessage = void 0;
    var CellMessage = class {
      constructor(cell) {
        this.cell = cell;
      }
      writeTo(cell) {
        cell.writeCell(this.cell);
      }
    };
    exports.CellMessage = CellMessage;
  }
});

// node_modules/ton/dist/messages/EmptyMessage.js
var require_EmptyMessage = __commonJS({
  "node_modules/ton/dist/messages/EmptyMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptyMessage = void 0;
    var EmptyMessage = class {
      writeTo(cell) {
      }
    };
    exports.EmptyMessage = EmptyMessage;
  }
});

// node_modules/ton/dist/messages/CommentMessage.js
var require_CommentMessage = __commonJS({
  "node_modules/ton/dist/messages/CommentMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommentMessage = void 0;
    var Cell_1 = require_Cell();
    var CommentMessage = class {
      constructor(comment) {
        this.comment = comment;
      }
      writeTo(cell) {
        if (this.comment.length > 0) {
          cell.bits.writeUint(0, 32);
          let bytes = Buffer.from(this.comment);
          let dest = cell;
          while (bytes.length > 0) {
            let avaliable = Math.floor(dest.bits.available / 8);
            if (bytes.length <= avaliable) {
              dest.bits.writeBuffer(bytes);
              break;
            }
            dest.bits.writeBuffer(bytes.slice(0, avaliable));
            bytes = bytes.slice(avaliable, bytes.length);
            let nc = new Cell_1.Cell();
            dest.refs.push(nc);
            dest = nc;
          }
        }
      }
    };
    exports.CommentMessage = CommentMessage;
  }
});

// node_modules/ton/dist/messages/BinaryMessage.js
var require_BinaryMessage = __commonJS({
  "node_modules/ton/dist/messages/BinaryMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinaryMessage = void 0;
    var BinaryMessage = class {
      constructor(payload) {
        this.payload = payload;
      }
      writeTo(cell) {
        cell.bits.writeBuffer(this.payload);
      }
    };
    exports.BinaryMessage = BinaryMessage;
  }
});

// node_modules/ton/dist/contracts/sources/UnknownContractSource.js
var require_UnknownContractSource = __commonJS({
  "node_modules/ton/dist/contracts/sources/UnknownContractSource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownContractSource = void 0;
    var UnknownContractSource = class {
      constructor(type2, workchain, description) {
        this.backup = () => {
          throw Error("Unknown");
        };
        this.describe = () => {
          return this.description;
        };
        this.type = type2;
        this.workchain = workchain;
        this.description = description;
      }
      get initialCode() {
        throw Error("Unknown");
      }
      get initialData() {
        throw Error("Unknown");
      }
    };
    exports.UnknownContractSource = UnknownContractSource;
  }
});

// node_modules/ton/dist/contracts/sources/WalletV1R1Source.js
var require_WalletV1R1Source = __commonJS({
  "node_modules/ton/dist/contracts/sources/WalletV1R1Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV1R1Source = void 0;
    var __1 = require_dist2();
    var WalletV1R1Source = class {
      constructor(opts) {
        this.type = "org.ton.wallets.simple";
        this.walletVersion = "v1";
        this.backup = () => {
          const store = new __1.ConfigStore();
          store.setInt("wc", this.workchain);
          store.setBuffer("pk", this.publicKey);
          return store.save();
        };
        this.describe = () => {
          return "Simple Wallet Contract";
        };
        this.publicKey = opts.publicKey;
        this.initialCode = opts.initialCode;
        this.initialData = opts.initialData;
        this.workchain = opts.workchain;
        Object.freeze(this);
      }
      static create(opts) {
        let publicKey = opts.publicKey;
        let workchain = opts.workchain;
        let initialCode = __1.Cell.fromBoc("B5EE9C72410101010044000084FF0020DDA4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED5441FDF089")[0];
        let initialData = new __1.Cell();
        initialData.bits.writeUint(0, 32);
        initialData.bits.writeBuffer(publicKey);
        return new WalletV1R1Source({ publicKey, initialCode, initialData, workchain });
      }
      static restore(backup) {
        const store = new __1.ConfigStore(backup);
        return WalletV1R1Source.create({ publicKey: store.getBuffer("pk"), workchain: store.getInt("wc") });
      }
    };
    exports.WalletV1R1Source = WalletV1R1Source;
  }
});

// node_modules/ton/dist/utils/ConfigStore.js
var require_ConfigStore = __commonJS({
  "node_modules/ton/dist/utils/ConfigStore.js"(exports) {
    "use strict";
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ConfigStore_map;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigStore = void 0;
    var __1 = require_dist2();
    var ConfigStore = class {
      constructor(source) {
        _ConfigStore_map.set(this, /* @__PURE__ */ new Map());
        this.getString = (key) => {
          let ex = __classPrivateFieldGet(this, _ConfigStore_map, "f").get(key);
          if (!ex) {
            throw Error("Unable to find key " + key);
          }
          return ex;
        };
        this.getBuffer = (key) => {
          return Buffer.from(this.getString(key), "hex");
        };
        this.getAddress = (key) => {
          return __1.Address.parseFriendly(this.getString(key)).address;
        };
        this.getInt = (key) => {
          return parseInt(this.getString(key));
        };
        this.setBuffer = (key, value) => {
          this.setString(key, value.toString("hex"));
        };
        this.setAddress = (key, address) => {
          this.setString(key, address.toFriendly());
        };
        if (source) {
          let parts = source.split(",");
          for (let p of parts) {
            let pp = p.split("=");
            if (pp.length !== 2) {
              throw Error("Mailformed input");
            }
            if (__classPrivateFieldGet(this, _ConfigStore_map, "f").has(pp[0])) {
              throw Error("Mailformed input");
            }
            __classPrivateFieldGet(this, _ConfigStore_map, "f").set(pp[0], pp[1]);
          }
        }
      }
      setString(key, value) {
        if (key.indexOf("=") >= 0 || key.indexOf(",") >= 0) {
          throw Error("Mailformed input");
        }
        if (value.indexOf("=") >= 0 || value.indexOf(",") >= 0) {
          throw Error("Mailformed input");
        }
        __classPrivateFieldGet(this, _ConfigStore_map, "f").set(key, value);
      }
      setInt(key, value) {
        this.setString(key, value.toString(10));
      }
      save() {
        let res = "";
        for (let e of __classPrivateFieldGet(this, _ConfigStore_map, "f")) {
          if (res !== "") {
            res += ",";
          }
          res += e[0] + "=" + e[1];
        }
        return res;
      }
    };
    exports.ConfigStore = ConfigStore;
    _ConfigStore_map = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/ton/dist/client/safeSign.js
var require_safeSign = __commonJS({
  "node_modules/ton/dist/client/safeSign.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = void 0;
    var ton_crypto_1 = require_dist();
    var MIN_SEED_LENGTH = 8;
    var MAX_SEED_LENGTH = 64;
    function createSafeSignHash(cell, seed) {
      let seedData = Buffer.from(seed);
      if (seedData.length > MAX_SEED_LENGTH) {
        throw Error("Seed can	 be longer than 64 bytes");
      }
      if (seedData.length < MIN_SEED_LENGTH) {
        throw Error("Seed must be at least 8 bytes");
      }
      return (0, ton_crypto_1.sha256_sync)(Buffer.concat([Buffer.from([255, 255]), seedData, cell.hash()]));
    }
    function safeSign(cell, secretKey, seed = "ton-safe-sign-magic") {
      return (0, ton_crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
    }
    exports.safeSign = safeSign;
    function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
      return (0, ton_crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
    }
    exports.safeSignVerify = safeSignVerify;
  }
});

// node_modules/ton/dist/block/parse.js
var require_parse = __commonJS({
  "node_modules/ton/dist/block/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseShardStateUnsplit = exports.parseMasterchainStateExtra = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseTransaction = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessageRelaxed = exports.parseMessage = exports.parseStateInit = exports.parseRawTickTock = exports.parseCommonMsgInfoRelaxed = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = void 0;
    var __1 = require_dist2();
    var parseDict_1 = require_parseDict();
    function parseAccountStatus(slice) {
      const status = slice.readUintNumber(2);
      if (status === 0) {
        return "uninitialized";
      }
      if (status === 1) {
        return "frozen";
      }
      if (status === 2) {
        return "active";
      }
      if (status === 3) {
        return "non-existing";
      }
      throw Error("Invalid data");
    }
    exports.parseAccountStatus = parseAccountStatus;
    function parseCurrencyCollection(slice) {
      const coins = slice.readCoins();
      let extraCurrencies = null;
      if (slice.readBit()) {
        let dc = slice.readCell();
        if (!dc.isExotic) {
          let pd = (0, parseDict_1.parseDict)(dc.beginParse(), 32, (s) => s.readVarUIntNumber(5));
          extraCurrencies = /* @__PURE__ */ new Map();
          for (let e of pd) {
            extraCurrencies.set(parseInt(e[0], 10), e[1]);
          }
        }
      }
      return { extraCurrencies, coins };
    }
    exports.parseCurrencyCollection = parseCurrencyCollection;
    function parseCommonMsgInfo(slice) {
      if (!slice.readBit()) {
        let ihrDisabled = slice.readBit();
        let bounce = slice.readBit();
        let bounced = slice.readBit();
        let src = slice.readAddressInternal();
        let dest = slice.readAddressInternal();
        let value = parseCurrencyCollection(slice);
        let ihrFee = slice.readCoins();
        let fwdFee = slice.readCoins();
        let createdLt = slice.readUint(64);
        let createdAt = slice.readUintNumber(32);
        return {
          type: "internal",
          ihrDisabled,
          bounce,
          bounced,
          src,
          dest,
          value,
          ihrFee,
          fwdFee,
          createdLt,
          createdAt
        };
      } else if (slice.readBit()) {
        let src = slice.readAddressInternal();
        let dest = slice.readAddressExternal();
        let createdLt = slice.readUint(64);
        let createdAt = slice.readUintNumber(32);
        return {
          type: "external-out",
          src,
          dest,
          createdLt,
          createdAt
        };
      } else {
        let src = slice.readAddressExternal();
        let dest = slice.readAddressInternal();
        let importFee = slice.readCoins();
        return {
          type: "external-in",
          src,
          dest,
          importFee
        };
      }
    }
    exports.parseCommonMsgInfo = parseCommonMsgInfo;
    function parseCommonMsgInfoRelaxed(slice) {
      if (!slice.readBit()) {
        let ihrDisabled = slice.readBit();
        let bounce = slice.readBit();
        let bounced = slice.readBit();
        let src = slice.readAddress();
        let dest = slice.readAddressInternal();
        let value = parseCurrencyCollection(slice);
        let ihrFee = slice.readCoins();
        let fwdFee = slice.readCoins();
        let createdLt = slice.readUint(64);
        let createdAt = slice.readUintNumber(32);
        return {
          type: "internal",
          ihrDisabled,
          bounce,
          bounced,
          src,
          dest,
          value,
          ihrFee,
          fwdFee,
          createdLt,
          createdAt
        };
      } else if (slice.readBit()) {
        let src = slice.readAddress();
        let dest = slice.readAddressExternal();
        let createdLt = slice.readUint(64);
        let createdAt = slice.readUintNumber(32);
        return {
          type: "external-out",
          src,
          dest,
          createdLt,
          createdAt
        };
      }
      throw new Error("Invalid message info");
    }
    exports.parseCommonMsgInfoRelaxed = parseCommonMsgInfoRelaxed;
    function parseRawTickTock(slice) {
      return {
        tick: slice.readBit(),
        tock: slice.readBit()
      };
    }
    exports.parseRawTickTock = parseRawTickTock;
    function parseStateInit(slice) {
      let raw = slice.toCell();
      let splitDepth = null;
      if (slice.readBit()) {
        splitDepth = slice.readUintNumber(5);
      }
      const special = slice.readBit() ? parseRawTickTock(slice) : null;
      const hasCode = slice.readBit();
      const code = hasCode ? slice.readCell() : null;
      const hasData = slice.readBit();
      const data = hasData ? slice.readCell() : null;
      if (slice.readBit()) {
        slice.readCell();
      }
      return { splitDepth, data, code, special, raw };
    }
    exports.parseStateInit = parseStateInit;
    function parseMessage(slice) {
      const raw = slice.toCell();
      const info = parseCommonMsgInfo(slice);
      const hasInit = slice.readBit();
      let init4 = null;
      if (hasInit) {
        if (!slice.readBit()) {
          init4 = parseStateInit(slice);
        } else {
          init4 = parseStateInit(slice.readRef());
        }
      }
      const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();
      return {
        info,
        init: init4,
        body,
        raw
      };
    }
    exports.parseMessage = parseMessage;
    function parseMessageRelaxed(slice) {
      const raw = slice.toCell();
      const info = parseCommonMsgInfoRelaxed(slice);
      const hasInit = slice.readBit();
      let init4 = null;
      if (hasInit) {
        if (!slice.readBit()) {
          init4 = parseStateInit(slice);
        } else {
          init4 = parseStateInit(slice.readRef());
        }
      }
      const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();
      return {
        info,
        init: init4,
        body,
        raw
      };
    }
    exports.parseMessageRelaxed = parseMessageRelaxed;
    function parseHashUpdate(slice) {
      if (slice.readUintNumber(8) !== 114) {
        throw Error("Invalid data");
      }
      const oldHash = slice.readBuffer(32);
      const newHash = slice.readBuffer(32);
      return { oldHash, newHash };
    }
    exports.parseHashUpdate = parseHashUpdate;
    function parseAccountChange(slice) {
      if (!slice.readBit()) {
        return "unchanged";
      }
      if (slice.readBit()) {
        return "frozen";
      } else {
        return "deleted";
      }
    }
    exports.parseAccountChange = parseAccountChange;
    function parseStorageUsedShort(slice) {
      return {
        cells: slice.readVarUIntNumber(3),
        bits: slice.readVarUIntNumber(3)
      };
    }
    exports.parseStorageUsedShort = parseStorageUsedShort;
    function parseStoragePhase(slice) {
      const storageFeesCollected = slice.readCoins();
      let storageFeesDue = null;
      if (slice.readBit()) {
        storageFeesDue = slice.readCoins();
      }
      const statusChange = parseAccountChange(slice);
      return {
        storageFeesCollected,
        storageFeesDue,
        statusChange
      };
    }
    exports.parseStoragePhase = parseStoragePhase;
    function parseCreditPhase(slice) {
      let dueFeesColelcted = slice.readBit() ? slice.readCoins() : null;
      const credit = parseCurrencyCollection(slice);
      return {
        dueFeesColelcted,
        credit
      };
    }
    exports.parseCreditPhase = parseCreditPhase;
    function parseComputePhase(slice) {
      if (!slice.readBit()) {
        const skipReason = slice.readUintNumber(2);
        if (skipReason === 0) {
          return {
            type: "skipped",
            reason: "no-state"
          };
        }
        if (skipReason === 1) {
          return {
            type: "skipped",
            reason: "bad-state"
          };
        }
        if (skipReason === 2) {
          return {
            type: "skipped",
            reason: "no-gas"
          };
        }
      }
      const success2 = slice.readBit();
      const messageStateUsed = slice.readBit();
      const accountActivated = slice.readBit();
      let gasFees = slice.readCoins();
      const vmState = slice.readRef();
      let gasUsed = vmState.readVarUInt(3);
      let gasLimit = vmState.readVarUInt(3);
      let gasCredit = vmState.readBit() ? vmState.readVarUInt(2) : null;
      let mode = vmState.readUintNumber(8);
      let exitCode = vmState.readUintNumber(32);
      let exitArg = vmState.readBit() ? vmState.readUintNumber(32) : null;
      let vmSteps = vmState.readUintNumber(32);
      let vmInitStateHash = vmState.readBuffer(32);
      let vmFinalStateHash = vmState.readBuffer(32);
      return {
        type: "computed",
        success: success2,
        messageStateUsed,
        accountActivated,
        gasFees,
        gasUsed,
        gasLimit,
        gasCredit,
        mode,
        exitCode,
        exitArg,
        vmSteps,
        vmInitStateHash,
        vmFinalStateHash
      };
    }
    exports.parseComputePhase = parseComputePhase;
    function parseActionPhase(slice) {
      const success2 = slice.readBit();
      const valid = slice.readBit();
      const noFunds = slice.readBit();
      const statusChange = parseAccountChange(slice);
      const totalFwdFees = slice.readBit() ? slice.readCoins() : null;
      const totalActionFees = slice.readBit() ? slice.readCoins() : null;
      const resultCode = slice.readUintNumber(32);
      const resultArg = slice.readBit() ? slice.readUintNumber(32) : null;
      const totalActions = slice.readUintNumber(16);
      const specialActions = slice.readUintNumber(16);
      const skippedActions = slice.readUintNumber(16);
      const messagesCreated = slice.readUintNumber(16);
      const actionListHash = slice.readBuffer(32);
      const totalMessageSizes = parseStorageUsedShort(slice);
      return {
        success: success2,
        valid,
        noFunds,
        statusChange,
        totalFwdFees,
        totalActionFees,
        resultCode,
        resultArg,
        totalActions,
        specialActions,
        skippedActions,
        messagesCreated,
        actionListHash,
        totalMessageSizes
      };
    }
    exports.parseActionPhase = parseActionPhase;
    function parseBouncePhase(slice) {
      if (slice.readBit()) {
        const msgSize = parseStorageUsedShort(slice);
        const msgFees = slice.readCoins();
        const fwdFees = slice.readCoins();
        return {
          type: "ok",
          msgSize,
          msgFees,
          fwdFees
        };
      }
      if (slice.readBit()) {
        const msgSize = parseStorageUsedShort(slice);
        const fwdFees = slice.readCoins();
        return {
          type: "no-funds",
          msgSize,
          fwdFees
        };
      }
      return {
        type: "negative-funds"
      };
    }
    exports.parseBouncePhase = parseBouncePhase;
    function parseTransactionDescription(slice) {
      const type2 = slice.readUintNumber(4);
      if (type2 === 0) {
        const creditFirst = slice.readBit();
        let storagePhase = null;
        let creditPhase = null;
        if (slice.readBit()) {
          storagePhase = parseStoragePhase(slice);
        }
        if (slice.readBit()) {
          creditPhase = parseCreditPhase(slice);
        }
        let computePhase = parseComputePhase(slice);
        let actionPhase = null;
        if (slice.readBit()) {
          actionPhase = parseActionPhase(slice.readRef());
        }
        let aborted = slice.readBit();
        let bouncePhase = null;
        if (slice.readBit()) {
          bouncePhase = parseBouncePhase(slice);
        }
        const destroyed = slice.readBit();
        return {
          type: "generic",
          creditFirst,
          storagePhase,
          creditPhase,
          computePhase,
          actionPhase,
          bouncePhase,
          aborted,
          destroyed
        };
      }
      if (type2 === 1) {
        let storagePhase = parseStoragePhase(slice);
        return {
          type: "storage",
          storagePhase
        };
      }
      if (type2 === 2 || type2 === 3) {
        const isTock = type2 === 3;
        let storagePhase = parseStoragePhase(slice);
        let computePhase = parseComputePhase(slice);
        let actionPhase = null;
        if (slice.readBit()) {
          actionPhase = parseActionPhase(slice.readRef());
        }
        const aborted = slice.readBit();
        const destroyed = slice.readBit();
        return {
          type: "tick-tock",
          isTock,
          storagePhase,
          computePhase,
          actionPhase,
          aborted,
          destroyed
        };
      }
      throw Error("Unsupported transaction type");
    }
    exports.parseTransactionDescription = parseTransactionDescription;
    function parseTransaction(workchain, slice) {
      if (slice.readUintNumber(4) !== 7) {
        throw Error("Invalid data");
      }
      const addressHash = slice.readBuffer(32);
      const address = new __1.Address(workchain, addressHash);
      const lt = slice.readUint(64);
      const prevTransHash = slice.readBuffer(32);
      const prevTransLt = slice.readUint(64);
      const time = slice.readUintNumber(32);
      const outMessagesCount = slice.readUintNumber(15);
      const oldStatus = parseAccountStatus(slice);
      const newStatus = parseAccountStatus(slice);
      const messages = slice.readRef();
      let hasInMessage = messages.readBit();
      let hasOutMessages = messages.readBit();
      let inMessage = null;
      if (hasInMessage) {
        inMessage = parseMessage(messages.readRef());
      }
      let outMessages = [];
      if (hasOutMessages) {
        let dict = messages.readDict(15, (slice2) => parseMessage(slice2.readRef()));
        for (let msg of Array.from(dict.values())) {
          outMessages.push(msg);
        }
      }
      let fees = parseCurrencyCollection(slice);
      let update = parseHashUpdate(slice.readRef());
      let description = parseTransactionDescription(slice.readRef());
      return {
        address,
        lt,
        time,
        outMessagesCount,
        oldStatus,
        newStatus,
        fees,
        update,
        description,
        inMessage,
        outMessages,
        prevTransaction: {
          hash: prevTransHash,
          lt: prevTransLt
        }
      };
    }
    exports.parseTransaction = parseTransaction;
    function parseStorageUsed(cs) {
      return {
        cells: cs.readVarUIntNumber(3),
        bits: cs.readVarUIntNumber(3),
        publicCells: cs.readVarUIntNumber(3)
      };
    }
    exports.parseStorageUsed = parseStorageUsed;
    function parseStorageInfo(cs) {
      return {
        used: parseStorageUsed(cs),
        lastPaid: cs.readUintNumber(32),
        duePayment: cs.readBit() ? cs.readCoins() : null
      };
    }
    exports.parseStorageInfo = parseStorageInfo;
    function parseAccountState(cs) {
      if (cs.readBit()) {
        return { type: "active", state: parseStateInit(cs) };
      } else if (cs.readBit()) {
        return { type: "frozen", stateHash: cs.readBuffer(32) };
      } else {
        return { type: "uninit" };
      }
    }
    exports.parseAccountState = parseAccountState;
    function parseAccountStorage(cs) {
      return { lastTransLt: cs.readUint(64), balance: parseCurrencyCollection(cs), state: parseAccountState(cs) };
    }
    exports.parseAccountStorage = parseAccountStorage;
    function parseAccount(cs) {
      if (cs.readBit()) {
        return {
          address: cs.readAddressInternal(),
          storageStat: parseStorageInfo(cs),
          storage: parseAccountStorage(cs)
        };
      } else {
        return null;
      }
    }
    exports.parseAccount = parseAccount;
    function parseShardIdent(cs) {
      if (cs.readUintNumber(2) !== 0) {
        throw Error("Invalid data");
      }
      let shardPrefixBits = cs.readUintNumber(6);
      let workchainId = cs.readIntNumber(32);
      let shardPrefix = cs.readUint(64);
      return {
        shardPrefixBits,
        workchainId,
        shardPrefix
      };
    }
    exports.parseShardIdent = parseShardIdent;
    function parseShardAccount(cs) {
      let accountCell = cs.readCell();
      let address = null;
      if (!accountCell.isExotic) {
        address = accountCell.beginParse().readAddress();
      }
      return {
        address,
        lastTransHash: cs.readBuffer(32),
        lastTransLt: cs.readUint(64)
      };
    }
    exports.parseShardAccount = parseShardAccount;
    function parseDepthBalanceInfo(cs) {
      return {
        splitDepth: cs.readUintNumber(5),
        balance: parseCurrencyCollection(cs)
      };
    }
    exports.parseDepthBalanceInfo = parseDepthBalanceInfo;
    function parseShardAccounts(cs) {
      if (!cs.readBit()) {
        return /* @__PURE__ */ new Map();
      }
      return (0, parseDict_1.parseDict)(cs.readRef(), 256, (cs2) => {
        let depthBalanceInfo = parseDepthBalanceInfo(cs2);
        let shardAccount = parseShardAccount(cs2);
        return {
          depthBalanceInfo,
          shardAccount
        };
      });
    }
    exports.parseShardAccounts = parseShardAccounts;
    function parseMasterchainStateExtra(cs) {
      if (cs.readUintNumber(16) !== 52262) {
        throw Error("Invalid data");
      }
      if (cs.readBit()) {
        cs.readCell();
      }
      let configAddress = new __1.Address(-1, cs.readBuffer(32));
      let config = cs.readCell();
      const globalBalance = parseCurrencyCollection(cs);
      return {
        config,
        configAddress,
        globalBalance
      };
    }
    exports.parseMasterchainStateExtra = parseMasterchainStateExtra;
    function parseShardStateUnsplit(cs) {
      if (cs.readUintNumber(32) !== 2418257890) {
        throw Error("Invalid data");
      }
      let globalId = cs.readIntNumber(32);
      let shardId = parseShardIdent(cs);
      let seqno = cs.readUintNumber(32);
      let vertSeqNo = cs.readUintNumber(32);
      let genUtime = cs.readUintNumber(32);
      let genLt = cs.readUint(64);
      let minRefSeqno = cs.readUintNumber(32);
      cs.readCell();
      let beforeSplit = cs.readBit();
      let accounts;
      let accountsCell = cs.readCell();
      if (accountsCell.isExotic) {
        accounts = /* @__PURE__ */ new Map();
      } else {
        accounts = parseShardAccounts(accountsCell.beginParse());
      }
      cs.readCell();
      let mcStateExtra = cs.readBit();
      let extras = null;
      if (mcStateExtra) {
        let cell = cs.readCell();
        if (!cell.isExotic) {
          extras = parseMasterchainStateExtra(cell.beginParse());
        }
      }
      ;
      return {
        globalId,
        shardId,
        seqno,
        vertSeqNo,
        genUtime,
        genLt,
        minRefSeqno,
        beforeSplit,
        accounts,
        extras
      };
    }
    exports.parseShardStateUnsplit = parseShardStateUnsplit;
  }
});

// node_modules/ton/dist/block/stack.js
var require_stack = __commonJS({
  "node_modules/ton/dist/block/stack.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseStack = exports.serializeStack = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var Builder_1 = require_Builder();
    var Cell_1 = require_Cell();
    var INT64_MIN = new bn_js_1.default("-9223372036854775808");
    var INT64_MAX = new bn_js_1.default("9223372036854775807");
    function serializeStackItem(src, builder) {
      if (src.type === "null") {
        builder.storeUint8(0);
      } else if (src.type === "int") {
        if (src.value.lte(INT64_MAX) && src.value.gte(INT64_MIN)) {
          builder.storeUint8(1);
          builder.storeInt(src.value, 64);
        } else {
          builder.storeUint(256, 15);
          builder.storeInt(src.value, 257);
        }
      } else if (src.type === "nan") {
        builder.storeInt(767, 16);
      } else if (src.type === "cell") {
        builder.storeUint8(3);
        builder.storeRef(src.cell);
      } else if (src.type === "slice") {
        builder.storeUint8(4);
        builder.storeUint(0, 10);
        builder.storeUint(src.cell.bits.cursor, 10);
        builder.storeUint(0, 3);
        builder.storeUint(src.cell.refs.length, 3);
        builder.storeRef(src.cell);
      } else if (src.type === "builder") {
        builder.storeUint8(5);
        builder.storeRef(src.cell);
      } else if (src.type === "tuple") {
        let head6 = null;
        let tail5 = null;
        for (let i = 0; i < src.items.length; i++) {
          let s = head6;
          head6 = tail5;
          tail5 = s;
          if (i > 1) {
            head6 = (0, Builder_1.beginCell)().storeRef(tail5).storeRef(head6).endCell();
          }
          let bc = (0, Builder_1.beginCell)();
          serializeStackItem(src.items[i], bc);
          tail5 = bc.endCell();
        }
        builder.storeUint8(7);
        builder.storeUint(src.items.length, 16);
        if (head6) {
          builder.storeRef(head6);
        }
        if (tail5) {
          builder.storeRef(tail5);
        }
      } else {
        throw Error("Invalid value");
      }
    }
    function parseStackItem(cs) {
      let kind = cs.readUintNumber(8);
      if (kind === 0) {
        return { type: "null" };
      } else if (kind === 1) {
        return { type: "int", value: cs.readInt(64) };
      } else if (kind === 2) {
        if (cs.readUintNumber(7) === 0) {
          return { type: "int", value: cs.readInt(257) };
        } else {
          cs.readBit();
          return { type: "nan" };
        }
      } else if (kind === 3) {
        return { type: "cell", cell: cs.readCell() };
      } else if (kind === 4) {
        let startBits = cs.readUintNumber(10);
        let endBits = cs.readUintNumber(10);
        let startRefs = cs.readUintNumber(3);
        let endRefs = cs.readUintNumber(3);
        let rs = cs.readCell().beginParse();
        rs.skip(startBits);
        let dt = rs.readBitString(endBits - startBits);
        let cell = new Cell_1.Cell("ordinary", dt);
        if (startRefs < endRefs) {
          for (let i = 0; i < startRefs; i++) {
            cs.readCell();
          }
          for (let i = 0; i < endRefs - startRefs; i++) {
            cell.refs.push(cs.readCell());
          }
        }
        return { type: "slice", cell };
      } else if (kind === 5) {
        return { type: "builder", cell: cs.readCell() };
      } else if (kind === 7) {
        let length = cs.readUintNumber(16);
        let items = [];
        if (length > 1) {
          let head6 = cs.readRef();
          let tail5 = cs.readRef();
          items.unshift(parseStackItem(tail5));
          for (let i = 0; i < length - 2; i++) {
            let ohead = head6;
            head6 = ohead.readRef();
            tail5 = ohead.readRef();
            items.unshift(parseStackItem(tail5));
          }
          items.unshift(parseStackItem(head6));
        } else if (length === 1) {
          items.push(parseStackItem(cs.readRef()));
        }
        return { type: "tuple", items };
      } else {
        throw Error("Unsupported stack item");
      }
    }
    function serializeStackTail(src, builder) {
      if (src.length > 0) {
        let tail5 = (0, Builder_1.beginCell)();
        serializeStackTail(src.slice(0, src.length - 1), tail5);
        builder.storeRef(tail5.endCell());
        serializeStackItem(src[src.length - 1], builder);
      }
    }
    function serializeStack(src) {
      let builder = (0, Builder_1.beginCell)();
      builder.storeUint(src.length, 24);
      let r = [...src];
      serializeStackTail(r, builder);
      return builder.endCell();
    }
    exports.serializeStack = serializeStack;
    function parseStack(src) {
      let res = [];
      let cs = src.beginParse();
      let size4 = cs.readUintNumber(24);
      for (let i = 0; i < size4; i++) {
        let next = cs.readRef();
        res.unshift(parseStackItem(cs));
        cs = next;
      }
      return res;
    }
    exports.parseStack = parseStack;
  }
});

// node_modules/ton/dist/utils/toUrlSafe.js
var require_toUrlSafe = __commonJS({
  "node_modules/ton/dist/utils/toUrlSafe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUrlSafe = void 0;
    function toUrlSafe(src) {
      while (src.indexOf("/") >= 0) {
        src = src.replace("/", "_");
      }
      while (src.indexOf("+") >= 0) {
        src = src.replace("+", "-");
      }
      while (src.indexOf("=") >= 0) {
        src = src.replace("=", "");
      }
      return src;
    }
    exports.toUrlSafe = toUrlSafe;
  }
});

// node_modules/ton/dist/client/TonClient4.js
var require_TonClient4 = __commonJS({
  "node_modules/ton/dist/client/TonClient4.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _TonClient4_endpoint;
    var _TonClient4_timeout;
    var _TonClient4_adapter;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TonClient4 = void 0;
    var axios_1 = __importDefault(require_axios2());
    var t = __importStar((init_es6(), __toCommonJS(es6_exports)));
    var stack_1 = require_stack();
    var Cell_1 = require_Cell();
    var toUrlSafe_1 = require_toUrlSafe();
    var TonClient4 = class {
      constructor(args) {
        _TonClient4_endpoint.set(this, void 0);
        _TonClient4_timeout.set(this, void 0);
        _TonClient4_adapter.set(this, void 0);
        __classPrivateFieldSet(this, _TonClient4_endpoint, args.endpoint, "f");
        __classPrivateFieldSet(this, _TonClient4_timeout, args.timeout || 5e3, "f");
        __classPrivateFieldSet(this, _TonClient4_adapter, args.httpAdapter, "f");
      }
      async getLastBlock() {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!lastBlockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      async getBlock(seqno) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!blockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        if (!res.data.exist) {
          throw Error("Block is out of scope");
        }
        return res.data.block;
      }
      async getBlockByUtime(ts) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!blockCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        if (!res.data.exist) {
          throw Error("Block is out of scope");
        }
        return res.data.block;
      }
      async getAccount(seqno, address) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toFriendly({ urlSafe: true }), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!accountCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      async getAccountLite(seqno, address) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toFriendly({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!accountLiteCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      async isAccountChanged(seqno, address, lt) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toFriendly({ urlSafe: true }) + "/changed/" + lt.toString(10), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!changedCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      async getAccountTransactions(address, lt, hash) {
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toFriendly({ urlSafe: true }) + "/tx/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!transactionsCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        let data = res.data;
        let tx = [];
        let cells = Cell_1.Cell.fromBoc(Buffer.from(data.boc, "base64"));
        for (let i = 0; i < data.blocks.length; i++) {
          tx.push({
            block: data.blocks[i],
            tx: cells[i]
          });
        }
        return tx;
      }
      async getConfig(seqno, ids) {
        let tail5 = "";
        if (ids && ids.length > 0) {
          tail5 = "/" + [...ids].sort().join(",");
        }
        let res = await axios_1.default.get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail5, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!configCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return res.data;
      }
      async runMethod(seqno, address, name, args) {
        let tail5 = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, stack_1.serializeStack)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
        let url = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toFriendly({ urlSafe: true }) + "/run/" + name + tail5;
        let res = await axios_1.default.get(url, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!runMethodCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return {
          exitCode: res.data.exitCode,
          result: res.data.resultRaw ? (0, stack_1.parseStack)(Cell_1.Cell.fromBoc(Buffer.from(res.data.resultRaw, "base64"))[0]) : [],
          resultRaw: res.data.resultRaw,
          block: res.data.block,
          shardBlock: res.data.shardBlock
        };
      }
      async sendMessage(message) {
        let res = await axios_1.default.post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
        if (!sendCodec.is(res.data)) {
          throw Error("Mailformed response");
        }
        return { status: res.data.status };
      }
    };
    exports.TonClient4 = TonClient4;
    _TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap();
    var lastBlockCodec = t.type({
      last: t.type({
        seqno: t.number,
        shard: t.string,
        workchain: t.number,
        fileHash: t.string,
        rootHash: t.string
      }),
      init: t.type({
        fileHash: t.string,
        rootHash: t.string
      }),
      stateRootHash: t.string,
      now: t.number
    });
    var blockCodec = t.union([t.type({
      exist: t.literal(false)
    }), t.type({
      exist: t.literal(true),
      block: t.type({
        shards: t.array(t.type({
          workchain: t.number,
          seqno: t.number,
          shard: t.string,
          rootHash: t.string,
          fileHash: t.string,
          transactions: t.array(t.type({
            account: t.string,
            hash: t.string,
            lt: t.string
          }))
        }))
      })
    })]);
    var storageStatCodec = t.type({
      lastPaid: t.number,
      duePayment: t.union([t.null, t.string]),
      used: t.type({
        bits: t.number,
        cells: t.number,
        publicCells: t.number
      })
    });
    var accountCodec = t.type({
      account: t.type({
        state: t.union([
          t.type({ type: t.literal("uninit") }),
          t.type({ type: t.literal("active"), code: t.union([t.string, t.null]), data: t.union([t.string, t.null]) }),
          t.type({ type: t.literal("frozen"), stateHash: t.string })
        ]),
        balance: t.type({
          coins: t.string
        }),
        last: t.union([
          t.null,
          t.type({
            lt: t.string,
            hash: t.string
          })
        ]),
        storageStat: t.union([t.null, storageStatCodec])
      }),
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var accountLiteCodec = t.type({
      account: t.type({
        state: t.union([
          t.type({ type: t.literal("uninit") }),
          t.type({ type: t.literal("active"), codeHash: t.string, dataHash: t.string }),
          t.type({ type: t.literal("frozen"), stateHash: t.string })
        ]),
        balance: t.type({
          coins: t.string
        }),
        last: t.union([
          t.null,
          t.type({
            lt: t.string,
            hash: t.string
          })
        ]),
        storageStat: t.union([t.null, storageStatCodec])
      })
    });
    var changedCodec = t.type({
      changed: t.boolean,
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var runMethodCodec = t.type({
      exitCode: t.number,
      resultRaw: t.union([t.string, t.null]),
      block: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      }),
      shardBlock: t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })
    });
    var configCodec = t.type({
      config: t.type({
        cell: t.string,
        address: t.string,
        globalBalance: t.type({
          coins: t.string
        })
      })
    });
    var sendCodec = t.type({
      status: t.number
    });
    var transactionsCodec = t.type({
      blocks: t.array(t.type({
        workchain: t.number,
        seqno: t.number,
        shard: t.string,
        rootHash: t.string,
        fileHash: t.string
      })),
      boc: t.string
    });
  }
});

// node_modules/ton/dist/block/fees.js
var require_fees = __commonJS({
  "node_modules/ton/dist/block/fees.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeMessageForwardFees = exports.computeExternalMessageFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeStorageFees = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var parse_1 = require_parse();
    function computeStorageFees(data) {
      const { lastPaid, now, storagePrices, storageStat, special, masterchain } = data;
      if (now <= lastPaid || storagePrices.length === 0 || now < storagePrices[0].utime_since.toNumber() || special) {
        return new bn_js_1.default(0);
      }
      let upto = Math.max(lastPaid, storagePrices[0].utime_since.toNumber());
      let total = new bn_js_1.default(0);
      for (let i = 0; i < storagePrices.length && upto < now; i++) {
        let valid_until = i < storagePrices.length - 1 ? Math.min(now, storagePrices[i + 1].utime_since.toNumber()) : now;
        let payment = new bn_js_1.default(0);
        if (upto < valid_until) {
          let delta = valid_until - upto;
          payment = payment.add(new bn_js_1.default(storageStat.cells).mul(masterchain ? storagePrices[i].mc_cell_price_ps : storagePrices[i].cell_price_ps));
          payment = payment.add(new bn_js_1.default(storageStat.bits).mul(masterchain ? storagePrices[i].mc_bit_price_ps : storagePrices[i].bit_price_ps));
          payment = payment.mul(new bn_js_1.default(delta));
        }
        upto = valid_until;
        total = total.add(payment);
      }
      return shr16ceil(total);
    }
    exports.computeStorageFees = computeStorageFees;
    function computeFwdFees(msgPrices, cells, bits) {
      return msgPrices.lumpPrice.add(shr16ceil(msgPrices.bitPrice.mul(bits).add(msgPrices.cellPrice.mul(cells))));
    }
    exports.computeFwdFees = computeFwdFees;
    function computeGasPrices(gasUsed, prices) {
      if (gasUsed.lte(prices.flatLimit)) {
        return prices.flatPrice;
      } else {
        return prices.flatPrice.add(prices.price.mul(gasUsed.sub(prices.flatLimit)).shrn(16));
      }
    }
    exports.computeGasPrices = computeGasPrices;
    function computeExternalMessageFees(msgPrices, cell) {
      let storageStats = collectCellStats(cell);
      storageStats.bits -= cell.bits.cursor;
      storageStats.cells -= 1;
      return computeFwdFees(msgPrices, new bn_js_1.default(storageStats.cells), new bn_js_1.default(storageStats.bits));
    }
    exports.computeExternalMessageFees = computeExternalMessageFees;
    function computeMessageForwardFees(msgPrices, cell) {
      let msg = (0, parse_1.parseMessageRelaxed)(cell.beginParse());
      let storageStats = { bits: 0, cells: 0 };
      if (msg.init) {
        let c = collectCellStats(msg.init.raw);
        c.bits -= msg.init.raw.bits.cursor;
        c.cells -= 1;
        storageStats.bits += c.bits;
        storageStats.cells += c.cells;
      }
      let bc = collectCellStats(msg.body);
      bc.bits -= msg.body.bits.cursor;
      bc.cells -= 1;
      storageStats.bits += bc.bits;
      storageStats.cells += bc.cells;
      let fees = computeFwdFees(msgPrices, new bn_js_1.default(storageStats.cells), new bn_js_1.default(storageStats.bits));
      let res = fees.mul(msgPrices.firstFrac).shrn(16);
      let remaining = fees.sub(res);
      return { fees: res, remaining };
    }
    exports.computeMessageForwardFees = computeMessageForwardFees;
    function collectCellStats(cell) {
      let bits = cell.bits.cursor;
      let cells = 1;
      for (let ref of cell.refs) {
        let r = collectCellStats(ref);
        cells += r.cells;
        bits += r.bits;
      }
      return { bits, cells };
    }
    function shr16ceil(src) {
      let rem = src.mod(new bn_js_1.default(65536));
      let res = src.shrn(16);
      if (!rem.eqn(0)) {
        res = res.addn(1);
      }
      return res;
    }
  }
});

// node_modules/ton/dist/traits/trait_address.js
var require_trait_address = __commonJS({
  "node_modules/ton/dist/traits/trait_address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.address = void 0;
    var TupleSlice4_1 = require_TupleSlice4();
    function address(client) {
      return async (seqno, address2, name) => {
        let executed = await client.runMethod(seqno, address2, name);
        if (executed.exitCode !== 0 && executed.exitCode !== 1) {
          throw Error("Exit code: " + executed.exitCode);
        }
        let parsed = new TupleSlice4_1.TupleSlice4(executed.result);
        return parsed.readAddress();
      };
    }
    exports.address = address;
  }
});

// node_modules/ton/dist/traits/trait_amount.js
var require_trait_amount = __commonJS({
  "node_modules/ton/dist/traits/trait_amount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.amount = void 0;
    var TupleSlice4_1 = require_TupleSlice4();
    function amount(client) {
      return async (seqno, address, name) => {
        let executed = await client.runMethod(seqno, address, name);
        if (executed.exitCode !== 0 && executed.exitCode !== 1) {
          throw Error("Exit code: " + executed.exitCode);
        }
        let parsed = new TupleSlice4_1.TupleSlice4(executed.result);
        return parsed.readBigNumber();
      };
    }
    exports.amount = amount;
  }
});

// node_modules/ton/dist/traits/trait_seqno.js
var require_trait_seqno = __commonJS({
  "node_modules/ton/dist/traits/trait_seqno.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.seqno = void 0;
    var TupleSlice4_1 = require_TupleSlice4();
    function seqno(client) {
      return async (seqno2, address, name = "seqno") => {
        let executed = await client.runMethod(seqno2, address, name);
        if (executed.exitCode !== 0 && executed.exitCode !== 1) {
          throw Error("Exit code: " + executed.exitCode);
        }
        let parsed = new TupleSlice4_1.TupleSlice4(executed.result);
        return parsed.readNumber();
      };
    }
    exports.seqno = seqno;
  }
});

// node_modules/ton/dist/traits/index.js
var require_traits = __commonJS({
  "node_modules/ton/dist/traits/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Traits = void 0;
    var trait_address_1 = require_trait_address();
    var trait_amount_1 = require_trait_amount();
    var trait_seqno_1 = require_trait_seqno();
    exports.Traits = {
      withClient: (src) => {
        return {
          seqno: (0, trait_seqno_1.seqno)(src),
          amount: (0, trait_amount_1.amount)(src),
          address: (0, trait_address_1.address)(src)
        };
      }
    };
  }
});

// node_modules/ton/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ton/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletV3R2Source = exports.WalletV3R1Source = exports.WalletV2R2Source = exports.WalletV2R1Source = exports.WalletV1R3Source = exports.WalletV1R2Source = exports.WalletV1R1Source = exports.UnknownContractSource = exports.contractAddress = exports.createWalletTransferV3 = exports.createWalletTransferV2 = exports.createWalletTransferV1 = exports.WalletContract = exports.BinaryMessage = exports.CommentMessage = exports.CommonMessageInfo = exports.StateInit = exports.EmptyMessage = exports.ExternalMessage = exports.InternalMessage = exports.CellMessage = exports.parseSupportedMessage = exports.getSupportedInterfacesRaw = exports.resolveKnownInterface = exports.getSupportedInterfaces = exports.TupleSlice4 = exports.TupleSlice = exports.bnToAddress = exports.beginDict = exports.DictBuilder = exports.beginCell = exports.Builder = exports.ADNLKey = exports.ADNLAddress = exports.Slice = exports.HttpApi = exports.InMemoryCache = exports.SendMode = exports.KeyStore = exports.fromNano = exports.toNano = exports.AddressExternal = exports.Address = exports.AllWalletContractTypes = exports.validateWalletType = exports.Wallet = exports.TonClient = exports.Cell = exports.BitStringReader = exports.BitString = void 0;
    exports.configParse15 = exports.configParseMasterAddressRequired = exports.parseBridge = exports.parseValidatorSet = exports.parseValidatorDescr = exports.configParseWorkchainDescriptor = exports.configParseMasterAddress = exports.computeMessageForwardFees = exports.computeExternalMessageFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeStorageFees = exports.TonClient4 = exports.parseStack = exports.serializeStack = exports.parseMasterchainStateExtra = exports.parseShardStateUnsplit = exports.parseShardAccounts = exports.parseDepthBalanceInfo = exports.parseShardAccount = exports.parseShardIdent = exports.parseAccount = exports.parseAccountStorage = exports.parseAccountState = exports.parseStorageInfo = exports.parseStorageUsed = exports.parseRawTickTock = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessageRelaxed = exports.parseMessage = exports.parseStateInit = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = exports.parseTransaction = exports.safeSignVerify = exports.safeSign = exports.serializeDict = exports.parseDictRefs = exports.parseDictBitString = exports.parseDict = exports.ConfigStore = void 0;
    exports.Traits = exports.configParse29 = exports.configParse28 = exports.parseFullConfig = exports.configParseMsgPrices = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParseValidatorSet = exports.configParse12 = exports.configParse40 = exports.configParse8 = exports.configParse18 = exports.configParse17 = exports.configParse16 = void 0;
    var BitString_1 = require_BitString();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitStringReader_1 = require_BitStringReader();
    Object.defineProperty(exports, "BitStringReader", { enumerable: true, get: function() {
      return BitStringReader_1.BitStringReader;
    } });
    var Cell_1 = require_Cell();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var TonClient_1 = require_TonClient();
    Object.defineProperty(exports, "TonClient", { enumerable: true, get: function() {
      return TonClient_1.TonClient;
    } });
    var Wallet_1 = require_Wallet();
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return Wallet_1.Wallet;
    } });
    Object.defineProperty(exports, "validateWalletType", { enumerable: true, get: function() {
      return Wallet_1.validateWalletType;
    } });
    Object.defineProperty(exports, "AllWalletContractTypes", { enumerable: true, get: function() {
      return Wallet_1.allTypes;
    } });
    var Address_1 = require_Address();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    var AddressExternal_1 = require_AddressExternal();
    Object.defineProperty(exports, "AddressExternal", { enumerable: true, get: function() {
      return AddressExternal_1.AddressExternal;
    } });
    var convert_1 = require_convert();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var KeyStore_1 = require_KeyStore();
    Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function() {
      return KeyStore_1.KeyStore;
    } });
    var SendMode_1 = require_SendMode();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var TonCache_1 = require_TonCache();
    Object.defineProperty(exports, "InMemoryCache", { enumerable: true, get: function() {
      return TonCache_1.InMemoryCache;
    } });
    var HttpApi_1 = require_HttpApi();
    Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function() {
      return HttpApi_1.HttpApi;
    } });
    var Slice_1 = require_Slice();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var ADNLAddress_1 = require_ADNLAddress();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var ADNLKey_1 = require_ADNLKey();
    Object.defineProperty(exports, "ADNLKey", { enumerable: true, get: function() {
      return ADNLKey_1.ADNLKey;
    } });
    var Builder_1 = require_Builder();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_1.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_1.beginCell;
    } });
    var DictBuilder_1 = require_DictBuilder();
    Object.defineProperty(exports, "DictBuilder", { enumerable: true, get: function() {
      return DictBuilder_1.DictBuilder;
    } });
    Object.defineProperty(exports, "beginDict", { enumerable: true, get: function() {
      return DictBuilder_1.beginDict;
    } });
    var bnToAddress_1 = require_bnToAddress();
    Object.defineProperty(exports, "bnToAddress", { enumerable: true, get: function() {
      return bnToAddress_1.bnToAddress;
    } });
    var TupleSlice_1 = require_TupleSlice();
    Object.defineProperty(exports, "TupleSlice", { enumerable: true, get: function() {
      return TupleSlice_1.TupleSlice;
    } });
    var TupleSlice4_1 = require_TupleSlice4();
    Object.defineProperty(exports, "TupleSlice4", { enumerable: true, get: function() {
      return TupleSlice4_1.TupleSlice4;
    } });
    var getSupportedInterfaces_1 = require_getSupportedInterfaces();
    Object.defineProperty(exports, "getSupportedInterfaces", { enumerable: true, get: function() {
      return getSupportedInterfaces_1.getSupportedInterfaces;
    } });
    Object.defineProperty(exports, "resolveKnownInterface", { enumerable: true, get: function() {
      return getSupportedInterfaces_1.resolveKnownInterface;
    } });
    Object.defineProperty(exports, "getSupportedInterfacesRaw", { enumerable: true, get: function() {
      return getSupportedInterfaces_1.getSupportedInterfacesRaw;
    } });
    var parseSupportedMessage_1 = require_parseSupportedMessage();
    Object.defineProperty(exports, "parseSupportedMessage", { enumerable: true, get: function() {
      return parseSupportedMessage_1.parseSupportedMessage;
    } });
    var CellMessage_1 = require_CellMessage();
    Object.defineProperty(exports, "CellMessage", { enumerable: true, get: function() {
      return CellMessage_1.CellMessage;
    } });
    var InternalMessage_1 = require_InternalMessage();
    Object.defineProperty(exports, "InternalMessage", { enumerable: true, get: function() {
      return InternalMessage_1.InternalMessage;
    } });
    var ExternalMessage_1 = require_ExternalMessage();
    Object.defineProperty(exports, "ExternalMessage", { enumerable: true, get: function() {
      return ExternalMessage_1.ExternalMessage;
    } });
    var EmptyMessage_1 = require_EmptyMessage();
    Object.defineProperty(exports, "EmptyMessage", { enumerable: true, get: function() {
      return EmptyMessage_1.EmptyMessage;
    } });
    var StateInit_1 = require_StateInit();
    Object.defineProperty(exports, "StateInit", { enumerable: true, get: function() {
      return StateInit_1.StateInit;
    } });
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    Object.defineProperty(exports, "CommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.CommonMessageInfo;
    } });
    var CommentMessage_1 = require_CommentMessage();
    Object.defineProperty(exports, "CommentMessage", { enumerable: true, get: function() {
      return CommentMessage_1.CommentMessage;
    } });
    var BinaryMessage_1 = require_BinaryMessage();
    Object.defineProperty(exports, "BinaryMessage", { enumerable: true, get: function() {
      return BinaryMessage_1.BinaryMessage;
    } });
    var WalletContract_1 = require_WalletContract();
    Object.defineProperty(exports, "WalletContract", { enumerable: true, get: function() {
      return WalletContract_1.WalletContract;
    } });
    var createWalletTransfer_1 = require_createWalletTransfer();
    Object.defineProperty(exports, "createWalletTransferV1", { enumerable: true, get: function() {
      return createWalletTransfer_1.createWalletTransferV1;
    } });
    Object.defineProperty(exports, "createWalletTransferV2", { enumerable: true, get: function() {
      return createWalletTransfer_1.createWalletTransferV2;
    } });
    Object.defineProperty(exports, "createWalletTransferV3", { enumerable: true, get: function() {
      return createWalletTransfer_1.createWalletTransferV3;
    } });
    var contractAddress_1 = require_contractAddress();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var UnknownContractSource_1 = require_UnknownContractSource();
    Object.defineProperty(exports, "UnknownContractSource", { enumerable: true, get: function() {
      return UnknownContractSource_1.UnknownContractSource;
    } });
    var WalletV1R1Source_1 = require_WalletV1R1Source();
    Object.defineProperty(exports, "WalletV1R1Source", { enumerable: true, get: function() {
      return WalletV1R1Source_1.WalletV1R1Source;
    } });
    var WalletV1R2Source_1 = require_WalletV1R2Source();
    Object.defineProperty(exports, "WalletV1R2Source", { enumerable: true, get: function() {
      return WalletV1R2Source_1.WalletV1R2Source;
    } });
    var WalletV1R3Source_1 = require_WalletV1R3Source();
    Object.defineProperty(exports, "WalletV1R3Source", { enumerable: true, get: function() {
      return WalletV1R3Source_1.WalletV1R3Source;
    } });
    var WalletV2R1Source_1 = require_WalletV2R1Source();
    Object.defineProperty(exports, "WalletV2R1Source", { enumerable: true, get: function() {
      return WalletV2R1Source_1.WalletV2R1Source;
    } });
    var WalletV2R2Source_1 = require_WalletV2R2Source();
    Object.defineProperty(exports, "WalletV2R2Source", { enumerable: true, get: function() {
      return WalletV2R2Source_1.WalletV2R2Source;
    } });
    var WalletV3R1Source_1 = require_WalletV3R1Source();
    Object.defineProperty(exports, "WalletV3R1Source", { enumerable: true, get: function() {
      return WalletV3R1Source_1.WalletV3R1Source;
    } });
    var WalletV3R2Source_1 = require_WalletV3R2Source();
    Object.defineProperty(exports, "WalletV3R2Source", { enumerable: true, get: function() {
      return WalletV3R2Source_1.WalletV3R2Source;
    } });
    var ConfigStore_1 = require_ConfigStore();
    Object.defineProperty(exports, "ConfigStore", { enumerable: true, get: function() {
      return ConfigStore_1.ConfigStore;
    } });
    var parseDict_1 = require_parseDict();
    Object.defineProperty(exports, "parseDict", { enumerable: true, get: function() {
      return parseDict_1.parseDict;
    } });
    Object.defineProperty(exports, "parseDictBitString", { enumerable: true, get: function() {
      return parseDict_1.parseDictBitString;
    } });
    Object.defineProperty(exports, "parseDictRefs", { enumerable: true, get: function() {
      return parseDict_1.parseDictRefs;
    } });
    var serializeDict_1 = require_serializeDict();
    Object.defineProperty(exports, "serializeDict", { enumerable: true, get: function() {
      return serializeDict_1.serializeDict;
    } });
    var safeSign_1 = require_safeSign();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parse_1.parseTransaction;
    } });
    Object.defineProperty(exports, "parseAccountStatus", { enumerable: true, get: function() {
      return parse_1.parseAccountStatus;
    } });
    Object.defineProperty(exports, "parseCurrencyCollection", { enumerable: true, get: function() {
      return parse_1.parseCurrencyCollection;
    } });
    Object.defineProperty(exports, "parseCommonMsgInfo", { enumerable: true, get: function() {
      return parse_1.parseCommonMsgInfo;
    } });
    Object.defineProperty(exports, "parseStateInit", { enumerable: true, get: function() {
      return parse_1.parseStateInit;
    } });
    Object.defineProperty(exports, "parseMessage", { enumerable: true, get: function() {
      return parse_1.parseMessage;
    } });
    Object.defineProperty(exports, "parseMessageRelaxed", { enumerable: true, get: function() {
      return parse_1.parseMessageRelaxed;
    } });
    Object.defineProperty(exports, "parseHashUpdate", { enumerable: true, get: function() {
      return parse_1.parseHashUpdate;
    } });
    Object.defineProperty(exports, "parseAccountChange", { enumerable: true, get: function() {
      return parse_1.parseAccountChange;
    } });
    Object.defineProperty(exports, "parseStorageUsedShort", { enumerable: true, get: function() {
      return parse_1.parseStorageUsedShort;
    } });
    Object.defineProperty(exports, "parseStoragePhase", { enumerable: true, get: function() {
      return parse_1.parseStoragePhase;
    } });
    Object.defineProperty(exports, "parseCreditPhase", { enumerable: true, get: function() {
      return parse_1.parseCreditPhase;
    } });
    Object.defineProperty(exports, "parseComputePhase", { enumerable: true, get: function() {
      return parse_1.parseComputePhase;
    } });
    Object.defineProperty(exports, "parseActionPhase", { enumerable: true, get: function() {
      return parse_1.parseActionPhase;
    } });
    Object.defineProperty(exports, "parseBouncePhase", { enumerable: true, get: function() {
      return parse_1.parseBouncePhase;
    } });
    Object.defineProperty(exports, "parseTransactionDescription", { enumerable: true, get: function() {
      return parse_1.parseTransactionDescription;
    } });
    Object.defineProperty(exports, "parseRawTickTock", { enumerable: true, get: function() {
      return parse_1.parseRawTickTock;
    } });
    Object.defineProperty(exports, "parseStorageUsed", { enumerable: true, get: function() {
      return parse_1.parseStorageUsed;
    } });
    Object.defineProperty(exports, "parseStorageInfo", { enumerable: true, get: function() {
      return parse_1.parseStorageInfo;
    } });
    Object.defineProperty(exports, "parseAccountState", { enumerable: true, get: function() {
      return parse_1.parseAccountState;
    } });
    Object.defineProperty(exports, "parseAccountStorage", { enumerable: true, get: function() {
      return parse_1.parseAccountStorage;
    } });
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parse_1.parseAccount;
    } });
    Object.defineProperty(exports, "parseShardIdent", { enumerable: true, get: function() {
      return parse_1.parseShardIdent;
    } });
    Object.defineProperty(exports, "parseShardAccount", { enumerable: true, get: function() {
      return parse_1.parseShardAccount;
    } });
    Object.defineProperty(exports, "parseDepthBalanceInfo", { enumerable: true, get: function() {
      return parse_1.parseDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "parseShardAccounts", { enumerable: true, get: function() {
      return parse_1.parseShardAccounts;
    } });
    Object.defineProperty(exports, "parseShardStateUnsplit", { enumerable: true, get: function() {
      return parse_1.parseShardStateUnsplit;
    } });
    Object.defineProperty(exports, "parseMasterchainStateExtra", { enumerable: true, get: function() {
      return parse_1.parseMasterchainStateExtra;
    } });
    var stack_1 = require_stack();
    Object.defineProperty(exports, "serializeStack", { enumerable: true, get: function() {
      return stack_1.serializeStack;
    } });
    Object.defineProperty(exports, "parseStack", { enumerable: true, get: function() {
      return stack_1.parseStack;
    } });
    var TonClient4_1 = require_TonClient4();
    Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function() {
      return TonClient4_1.TonClient4;
    } });
    var fees_1 = require_fees();
    Object.defineProperty(exports, "computeStorageFees", { enumerable: true, get: function() {
      return fees_1.computeStorageFees;
    } });
    Object.defineProperty(exports, "computeFwdFees", { enumerable: true, get: function() {
      return fees_1.computeFwdFees;
    } });
    Object.defineProperty(exports, "computeGasPrices", { enumerable: true, get: function() {
      return fees_1.computeGasPrices;
    } });
    Object.defineProperty(exports, "computeExternalMessageFees", { enumerable: true, get: function() {
      return fees_1.computeExternalMessageFees;
    } });
    Object.defineProperty(exports, "computeMessageForwardFees", { enumerable: true, get: function() {
      return fees_1.computeMessageForwardFees;
    } });
    var configParsing_1 = require_configParsing();
    Object.defineProperty(exports, "configParseMasterAddress", { enumerable: true, get: function() {
      return configParsing_1.configParseMasterAddress;
    } });
    Object.defineProperty(exports, "configParseWorkchainDescriptor", { enumerable: true, get: function() {
      return configParsing_1.configParseWorkchainDescriptor;
    } });
    Object.defineProperty(exports, "parseValidatorDescr", { enumerable: true, get: function() {
      return configParsing_1.parseValidatorDescr;
    } });
    Object.defineProperty(exports, "parseValidatorSet", { enumerable: true, get: function() {
      return configParsing_1.parseValidatorSet;
    } });
    Object.defineProperty(exports, "parseBridge", { enumerable: true, get: function() {
      return configParsing_1.parseBridge;
    } });
    Object.defineProperty(exports, "configParseMasterAddressRequired", { enumerable: true, get: function() {
      return configParsing_1.configParseMasterAddressRequired;
    } });
    Object.defineProperty(exports, "configParse15", { enumerable: true, get: function() {
      return configParsing_1.configParse15;
    } });
    Object.defineProperty(exports, "configParse16", { enumerable: true, get: function() {
      return configParsing_1.configParse16;
    } });
    Object.defineProperty(exports, "configParse17", { enumerable: true, get: function() {
      return configParsing_1.configParse17;
    } });
    Object.defineProperty(exports, "configParse18", { enumerable: true, get: function() {
      return configParsing_1.configParse18;
    } });
    Object.defineProperty(exports, "configParse8", { enumerable: true, get: function() {
      return configParsing_1.configParse8;
    } });
    Object.defineProperty(exports, "configParse40", { enumerable: true, get: function() {
      return configParsing_1.configParse40;
    } });
    Object.defineProperty(exports, "configParse12", { enumerable: true, get: function() {
      return configParsing_1.configParse12;
    } });
    Object.defineProperty(exports, "configParseValidatorSet", { enumerable: true, get: function() {
      return configParsing_1.configParseValidatorSet;
    } });
    Object.defineProperty(exports, "configParseBridge", { enumerable: true, get: function() {
      return configParsing_1.configParseBridge;
    } });
    Object.defineProperty(exports, "configParseGasLimitsPrices", { enumerable: true, get: function() {
      return configParsing_1.configParseGasLimitsPrices;
    } });
    Object.defineProperty(exports, "configParseMsgPrices", { enumerable: true, get: function() {
      return configParsing_1.configParseMsgPrices;
    } });
    Object.defineProperty(exports, "parseFullConfig", { enumerable: true, get: function() {
      return configParsing_1.parseFullConfig;
    } });
    Object.defineProperty(exports, "configParse28", { enumerable: true, get: function() {
      return configParsing_1.configParse28;
    } });
    Object.defineProperty(exports, "configParse29", { enumerable: true, get: function() {
      return configParsing_1.configParse29;
    } });
    var index_1 = require_traits();
    Object.defineProperty(exports, "Traits", { enumerable: true, get: function() {
      return index_1.Traits;
    } });
  }
});

export {
  require_sha,
  require_browser,
  require_nacl_fast,
  es6_exports,
  init_es6,
  require_bn,
  require_symbol,
  require_Either,
  require_src,
  require_dataloader,
  require_lib,
  require_axios2 as require_axios,
  require_dist2 as require_dist
};
//# sourceMappingURL=chunk-B53GFUID.js.map
