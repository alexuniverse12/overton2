"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRemoteConnector = void 0;
const axios_1 = __importDefault(require("axios"));
const react_1 = require("react");
const ton_1 = require("ton");
const ton_x_1 = require("ton-x");
const time_1 = require("./utils/time");
function useTonhubSession(connector, id, log) {
    const [sessionState, setSessionState] = (0, react_1.useState)();
    (0, react_1.useEffect)(() => {
        if (!connector) {
            log('[tonhub]: not using remote connector');
            return;
        }
        if (!id) {
            log('[tonhub]: no session');
            return;
        }
        log('[tonhub]: new session ' + id);
        let isActive = true;
        let lastUpdated = undefined;
        let end = () => {
            isActive = false;
        };
        (0, time_1.backoff)(() => __awaiter(this, void 0, void 0, function* () {
            while (isActive) {
                let state = yield connector.waitForSessionState(id, lastUpdated);
                if (state.state !== 'revoked') {
                    lastUpdated = state.updated;
                }
                // in case of hook is disabled before request was got
                setSessionState((prevState) => {
                    if (!isActive) {
                        return prevState;
                    }
                    return Object.assign(Object.assign({}, state), { id: id });
                });
            }
        }));
        return end;
    }, [id]);
    return sessionState;
}
function useRemoteConnector(config, active) {
    const log = (...args) => config.debug && console.log(...args);
    const connector = (0, react_1.useMemo)(() => {
        if (active)
            return new ton_x_1.TonhubConnector({ network: config.network });
        return null;
    }, [active]);
    const { connectionState, setConnectionState } = config;
    // Init
    (0, react_1.useEffect)(() => {
        if (!connector) {
            return;
        }
        if (connectionState.type === 'initing' || connectionState.type === undefined) {
            (0, time_1.backoff)(() => __awaiter(this, void 0, void 0, function* () {
                let session = yield connector.createNewSession({
                    name: config.name,
                    url: config.url,
                });
                setConnectionState({ type: 'pending', session: session.id, link: session.link, seed: session.seed });
            }));
        }
    }, [connectionState, connector]);
    const sessionId = (0, react_1.useMemo)(() => {
        if (!connector) {
            return;
        }
        if (connectionState.type === 'initing') {
            return undefined;
        }
        return connectionState.session;
    }, [connectionState, connector]);
    let session = useTonhubSession(connector, sessionId, log);
    (0, react_1.useEffect)(() => {
        if (!session || !connector) {
            return;
        }
        // store only if session revoked and ready
        if (session.state === 'revoked') {
            log('[tonhub] revoked remotely');
            setConnectionState({ type: 'initing' });
        }
        else if (session.state === 'ready') {
            setConnectionState((prevState) => {
                if (prevState.type === 'initing' || (session === null || session === void 0 ? void 0 : session.state) !== 'ready') {
                    return prevState;
                }
                if (prevState.session !== session.id) {
                    return prevState;
                }
                return {
                    type: 'online',
                    seed: prevState.seed,
                    session: prevState.session,
                    walletConfig: session.wallet,
                    address: ton_1.Address.parse(session.wallet.address)
                };
            });
        }
    }, [session]);
    if (!connector) {
        return null;
    }
    const revoke = (0, react_1.useCallback)(() => {
        log('[tonhub]: revoked by user');
        if (connectionState.type === 'online') {
            (0, time_1.backoff)(() => __awaiter(this, void 0, void 0, function* () {
                yield axios_1.default.post('https://connect.tonhubapi.com/connect/revoke', {
                    key: connectionState.session
                }, { timeout: 5000 });
            }));
        }
        setConnectionState({ type: 'initing' });
    }, [connectionState]);
    const requestSign = (request) => {
        if (!connector) {
            throw new Error('No active tonhub connector');
        }
        if (connectionState.type !== 'online') {
            throw new Error('No active tonhub session');
        }
        return connector.requestSign({
            appPublicKey: connectionState.walletConfig.appPublicKey,
            seed: connectionState.seed,
            timeout: 300000,
            payload: request.payload,
            text: request.text
        });
    };
    const requestTransaction = (request) => {
        if (!connector) {
            throw new Error('No active tonhub connector');
        }
        if (connectionState.type !== 'online') {
            throw new Error('No active tonhub session');
        }
        return connector.requestTransaction({
            appPublicKey: connectionState.walletConfig.appPublicKey,
            seed: connectionState.seed,
            timeout: 300000,
            payload: request.payload,
            text: request.text,
            to: request.to,
            value: request.value,
            stateInit: request.stateInit
        });
    };
    return {
        api: {
            requestSign,
            requestTransaction,
            revoke
        },
        state: connectionState.type === 'online' ? Object.assign(Object.assign({}, connectionState), { address: ton_1.Address.parse(connectionState.walletConfig.address) }) : connectionState
    };
}
exports.useRemoteConnector = useRemoteConnector;
